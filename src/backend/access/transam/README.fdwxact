src/backend/access/transam/README.fdwxact

Atomic Commit for Distributed Transactions
===========================================

The atomic commit feature enables us to commit and rollback either all of
foreign servers or nothing. This ensures that the database data is always left
in a consistent state in term of federated database.

Note the two-pase protocol guarantees consistency in the durability sense,
i.e. either all parts of the distributed transaction get committed, or none
of it. It doeds not guarantee the parts to get committed at the same instant,
so the data on different nodes may get committed and visible at different
times, with arbitrary delay. This is an inherent limitation of the protocol
and also the reason why it is reliable.


Commit Sequence of Global Transactions
--------------------------------------

We employee two-phase commit protocol to achieve commit among all foreign
servers atomically. The sequence of distributed transaction commit consisnts
of the following four steps:


1. Foreign Transaction Registration

FDW implementation can register the transaction opened on the foreign server
(foreign transaction) in a transaction manager on the local node by calling
the FdwXactRegisterEntry() function.  The foreign transactions are managed by
this distributed transaction manager until the end of the local transaction.


2. Pre-Commit phase (1st phase of two-phase commit)

The two-phase commit is required only if the transaction needs to be committed
on at least two nodes (this may involve the local node). If a transaction needs
to be committed on a single node, a simple COMMIT is used on the single node.

If a two-phase commit is necessary, we need to first PREPARE and then COMMIT
transactions on all remote nodes (and locally). We use a minor optimization
of the protocol - we use a simple COMMIT for the local node, which is possible
because it's the last transaction we commit. This also means we can use the
local transaction to determine whether the whole distributed transaction
committed or not.

We need to be careful about properly recording all foreign transactions that
need to be prepared and committed, so that we don't lose any of them due to
a restart, crash recovery, failover to sync replica etc.

We achieve that by writing WAL record (XLOG_FDWXACT_INSERT) for all foreign
transactions associated with the local transaction. We flush the WAL and
possibly wait for confirmation from a sync standby. Only then we actually
issue PREPARE on those foreign transactions.

This ordering and the wait for synchronous replication are necessary to not
lose information about which foreign transactions might have been PREPARED.
Imagine a PREPARE on a foreign transaction is execued right before failover
to sync replica - if the WAL-logging happens after the PREPARE, or when we
don't wait for the sync replica confirmation, we may lose this information.
The consequence will be that some of the remote nodes will have prepared
transactions that we're unaware of. While this is not a typical data loss
case (the transaction was not committed yet, so we haven't lost any use
data), it may cause all sorts of issues until the foreign transaction is
rolled back.

If any of the PREPARE commands fails for whatever reason (node failure,
connection issue, ...) we error out and issue ROLLBACK both locally and on
all remote nodes.  Only the not-yet-prepared foreign transactions are
rolled back immediately, while those where PREPARE succeeded are left to
a background resolver process.


3. Commit locally

Once all the foreign transactions are PREPAREd, we commit the local transaction.

Once we've committed the local transaction (to be exact, right after flushing
the commit WAL record to the disk), the outcome of the distributed transaction
is determined and can't be changed.  We'll try performing a COMMIT PREPARED
but even if some of the commits fail, it must be a temporary failure only.


4. Post-Commit Phase (2nd phase of two-phase commit)

The steps so far are done by the backend process committing the transaction but
this step (commit or rollback) is performed asynchronously by the foreign
transaction resolver process.

XXX This seems a bit weird, really. It might make sense when the user issues
a 2PC commit, because then the commit can be issued from a completely different
backend that may not have opened the connections etc. But when the user does
a plain COMMIT (which we translate to 2PC), why not to try at least issuing
the COMMIT PREPARED? It might fail, and we'll have to report that to the user
somehow (so that user knows the commit succeeded, but some nodes have issues).
But that should be fairly rare.

The problem here is that without this (i.e. with async COMMIT PREPARED) the
user may fail to see his own writes, which seems like a pretty annoying
thing. Yes, 2PC does not give us globally consistent stanpshots, but this
seems like a pretty annoying anomaly.

We can hand it over to the resolver processes, but then we should wait for
the process to confirm all the foreign transactions were committed. That'd
work too, I think.


Identifying Foreign Transactions In GTM
---------------------------------------

XXX We should not use GTM, because that implies "global". And we don't have
anything global here - the transaction manager is kinda within each backend,
so it's not even node-level.

XXX Maybe mention this is about identifying participants within each backend,
not a globally unique transaction ID or anything like that.

To identify foreign transaction participants (as well as FdwXact entries) there
are two ways: using {server OID, user OID} and using user mapping OID. The same
is true for FDWs to identify the connections (and transactions upon) to the
foreign server. We need to consider the case where the way to identify the
transactions is not matched between GTM and FDWs, because the problem might occur
when the user modifies the same foreign server by different roles within the
transaction. For example, consider the following execution:

BEGIN;
SET ROLE user_A;
INSERT INTO ft1 VALUES (1);
SET ROLE user_B;
INSERT INTO ft1 VALUES (1);
COMMIT;

For example, suppose that an FDW identifies the connection by {server OID, user OID}
and GTM identifies the transactions by user mapping OID, and user_A and user_B use
the public user mapping to connect server_X. In the FDW, there are two
connections: {user_A, sever_X} and {user_B, server_X}, and therefore opens two
transactions on each connection, while GTM has only one FdwXact entry because the two
connections refer to the same user mapping OID. As a result, at the end of the
transaction, GTM ends only one foreign transaction, leaving another one.

On the other hand, suppose that an FDW identifies the connection by user mapping OID
and GTM does that by {server OID, user OID}, the FDW uses only one connection and opens
a transaction since both users refer to the same user mapping OID (we expect FDWs
not to register the foreign transaction when not starting a new transaction on the
foreign server). Since GTM also has one entry it can end the foreign transaciton
properly. The downside would be that the user OID of FdwXact (i.g., FdwXact->userid)
is the user who registered the foreign transaction for the first time, necessarily
not the user who executed COMMIT.  For example in the above case, FdwXact->userid
will be user_A, not user_B. But itâ€™s not big problem in practice.

Therefore, in fdwxact.c, we identify the foreign transaction by
{server OID, user OID}.

XXX I'm a bit confused, now. So this essentially says TM and FDW has to identify
connections in the same way, and if it opens multiple connections it needs to
regiester each connection as a separate participant? How much is this specific
to postgres_fdw?


Foreign Transactions Status
----------------------------

Every foreign transaction has an FdwXact entry. When preparing a foreign
transaction a FdwXact entry of which status starts from FDWXACT_STATUS_PREPARING
are created with WAL logging. The status changes to FDWXACT_STATUS_PREPARED
after the foreign transaction is prepared. And the status changes to
FDWXACT_STATUS_COMMITTING and FDWXACT_STATUS_ABORTING before committing and
aborting respectively. FdwXact entry is removed with WAL logging after resolved.

FdwXact entries recovered during the recovery are marked as in-doubt if the
corresponding local transaction is not prepared transaction. The initial
status for those entries is FDWXACT_STATUS_PREPARED if they are recovered
from WAL. Because we WAL logs only when preparing the foreign transaction we
cannot know the exact fate of the foreign transaction from the recovery.

The foreign transaction status transition is illustrated by the following
graph describing the FdwXact->status:

 +----------------------------------------------------+
 |                      INVALID                       |
 +----------------------------------------------------+
    |                      |                       |
    |                      v                       |
    |           +---------------------+            |
   (*1)         |      PREPARING      |           (*1)
    |           +---------------------+            |
    |                      |                       |
    v                      v                       v
 +----------------------------------------------------+
 |                      PREPARED                      |
 +----------------------------------------------------+
           |                               |
           v                               v
 +--------------------+          +--------------------+
 |     COMMITTING     |          |      ABORTING      |
 +--------------------+          +--------------------+
           |                               |
           v                               v
 +----------------------------------------------------+
 |                        END                         |
 +----------------------------------------------------+

(*1) Paths for recovered FdwXact entries
