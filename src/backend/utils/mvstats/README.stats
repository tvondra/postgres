Multivariate statististics
==========================

When estimating various quantities (e.g. condition selectivities) the default
approach relies on the assumption of independence. In practice that's often
not true, resulting in estimation errors.

Multivariate stats track different types of dependencies between the columns,
hopefully improving the estimates.


Types of statistics
-------------------

Currently we only have two kinds of multivariate statistics

    (a) soft functional dependencies (README.dependencies)

    (b) MCV lists (README.mcv)

    (c) multivariate histograms (README.histogram)


Compatible clause types
-----------------------

Each type of statistics may be used to estimate some subset of clause types.

    (a) functional dependencies - equality clauses (AND), possibly IS NULL

    (b) MCV list - equality and inequality clauses, IS [NOT] NULL, AND/OR

Currently only simple operator clauses (Var op Const) are supported, but it's
possible to support more complex clause types, e.g. (Var op Var).


Complex clauses
---------------

We also support estimating more complex clauses - essentially AND/OR clauses
with (Var op Const) as leaves, as long as all the referenced attributes are
covered by a single statistics.

For example this condition

    (a=1) AND ((b=2) OR ((c=3) AND (d=4)))

may be estimated using statistics on (a,b,c,d). If we only have statistics on
(b,c,d) we may estimate the second part, and estimate (a=1) using simple stats.

If we only have statistics on (a,b,c) we can't apply it at all at this point,
but it's worth pointing out clauselist_selectivity() works recursively and when
handling the second part (the OR-clause), we'll be able to apply the statistics.

Note: The multi-statistics estimation patch also makes it possible to pass some
clauses as 'conditions' into the deeper parts of the expression tree.


Selectivity estimation
----------------------

When estimating selectivity, we aim to achieve several things:

    (a) maximize the estimate accuracy

    (b) minimize the overhead, especially when no suitable multivariate stats
        exist (so if you are not using multivariate stats, there's no overhead)

Thus clauselist_selectivity() performs several inexpensive checks first, before
even attempting to do the more expensive estimation.

    (1) check if there are multivariate stats on the relation

    (2) check that there are functional dependencies on the table, and that
        there are at least two attributes referenced by compatible clauses
        (equality clauses for func. dependencies)

    (3) perform reduction of equality clauses using func. dependencies

    (4) check that there are multivariate MCV lists on the table, and that
        there are at least two attributes referenced by compatible clauses
        (equalities, inequalities, etc.)

    (5) find the best multivariate statistics (matching the most conditions)
        and use it to compute the estimate

    (6) estimate the remaining clauses (not estimated using multivariate stats)
        using the regular per-column statistics

Whenever we find there are no suitable stats, we skip the expensive steps.


Further (possibly crazy) ideas
------------------------------

Currently the clauses are only estimated using a single statistics, even if
there are multiple candidate statistics - for example assume we have statistics
on (a,b,c) and (b,c,d), and estimate conditions

    (b = 1) AND (c = 2)

Then both statistics may be used, but we only use one of them. Maybe we could
use compute estimates using all candidate stats, and somehow aggregate them
into the final estimate by using average or median.

Some stats may give better estimates than others, but it's very difficult to say
in advance which stats are the best (it depends on the number of buckets, number
of additional columns not referenced in the clauses, type of condition etc.).

But of course, this may result in expensive estimation (CPU-wise).

So we might add a GUC to choose between a simple (single statistics) and thus
multi-statistic estimation, possibly table-level parameter (ALTER TABLE ...).
