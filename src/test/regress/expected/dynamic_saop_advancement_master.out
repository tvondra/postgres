set work_mem='100MB';
set effective_cache_size='24GB';
set random_page_cost=2.0;
set track_io_timing to off;
set enable_seqscan to off;
set client_min_messages=error;
-- set skipscan_skipsupport_enabled=false;
set vacuum_freeze_min_age = 0;
set cursor_tuple_fraction=1.000;
create extension if not exists pageinspect; -- just to have it
-- set statement_timeout='4s';
reset client_min_messages;
-- Set log_btree_verbosity to 1 without depending on having that patch
-- applied (HACK, just sets commit_siblings instead when we don't have that
-- patch available):
select set_config((select coalesce((select name from pg_settings where name = 'log_btree_verbosity'), 'commit_siblings')), '1', false);
 set_config 
------------
 1
(1 row)

-- Establish if this server is master or the patch -- want to skip stress
-- tests if it's the latter
--
-- Reminder: Don't vary the database state between master and patch (just the
-- tests run, which must be read-only)
select (setting = '5432') as testing_patch from pg_settings where name = 'port'
       \gset
-------------------------------
-- Basic single column tests --
-------------------------------
set client_min_messages=error;
drop table if exists skippy_tbl;
reset client_min_messages;
create unlogged table skippy_tbl(
  bar int4
);
create index skippy_idx on skippy_tbl(bar);
insert into skippy_tbl
select
  i
from
  generate_series(1, 500) i;
-- prewarm
select count(*) from skippy_tbl;
 count 
-------
   500
(1 row)

vacuum analyze skippy_tbl;
-------------------------------
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Simple example:
select ctid, bar from skippy_tbl where bar in (2,3,4);
 ctid  | bar 
-------+-----
 (0,2) |   2
 (0,3) |   3
 (0,4) |   4
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (2,3,4);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using skippy_idx on skippy_tbl  (cost=0.27..6.61 rows=3 width=10) (actual rows=3 loops=1)
   Index Cond: (bar = ANY ('{2,3,4}'::integer[]))
   Buffers: shared hit=3
(3 rows)

-- Simple example of a backwards scan:
select ctid, bar from skippy_tbl where bar in (2,3,4) order by bar desc;
 ctid  | bar 
-------+-----
 (0,4) |   4
 (0,3) |   3
 (0,2) |   2
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (2,3,4) order by bar desc;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Scan Backward using skippy_idx on skippy_tbl  (cost=0.27..6.61 rows=3 width=10) (actual rows=3 loops=1)
   Index Cond: (bar = ANY ('{2,3,4}'::integer[]))
   Buffers: shared hit=3
(3 rows)

-- continuescan-on-highkey case should work:
select ctid, bar from skippy_tbl where bar in (365,366);
  ctid   | bar 
---------+-----
 (1,139) | 365
 (1,140) | 366
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (365,366);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using skippy_idx on skippy_tbl  (cost=0.27..6.58 rows=2 width=10) (actual rows=2 loops=1)
   Index Cond: (bar = ANY ('{365,366}'::integer[]))
   Buffers: shared hit=3
(3 rows)

-- pivotsearch (first item on leftmost leaf page's right sibling page) case
-- should also work:
select ctid, bar from skippy_tbl where bar in (367,368);
  ctid   | bar 
---------+-----
 (1,141) | 367
 (1,142) | 368
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (367,368);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using skippy_idx on skippy_tbl  (cost=0.27..6.58 rows=2 width=10) (actual rows=2 loops=1)
   Index Cond: (bar = ANY ('{367,368}'::integer[]))
   Buffers: shared hit=3
(3 rows)

-- Gap of one shouldn't confuse us:
select ctid, bar from skippy_tbl where bar in (2,4);
 ctid  | bar 
-------+-----
 (0,2) |   2
 (0,4) |   4
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (2,4);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using skippy_idx on skippy_tbl  (cost=0.27..6.58 rows=2 width=10) (actual rows=2 loops=1)
   Index Cond: (bar = ANY ('{2,4}'::integer[]))
   Buffers: shared hit=3
(3 rows)

-- Backwards scan gap of one shouldn't confuse us:
select ctid, bar from skippy_tbl where bar in (2,4) order by bar desc;
 ctid  | bar 
-------+-----
 (0,4) |   4
 (0,2) |   2
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (2,4) order by bar desc;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Scan Backward using skippy_idx on skippy_tbl  (cost=0.27..6.58 rows=2 width=10) (actual rows=2 loops=1)
   Index Cond: (bar = ANY ('{2,4}'::integer[]))
   Buffers: shared hit=3
(3 rows)

-- Gap of two shouldn't confuse us:
select ctid, bar from skippy_tbl where bar in (2,5);
 ctid  | bar 
-------+-----
 (0,2) |   2
 (0,5) |   5
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (2,5);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using skippy_idx on skippy_tbl  (cost=0.27..6.58 rows=2 width=10) (actual rows=2 loops=1)
   Index Cond: (bar = ANY ('{2,5}'::integer[]))
   Buffers: shared hit=3
(3 rows)

-- Backwards scan gap of two shouldn't confuse us:
select ctid, bar from skippy_tbl where bar in (2,5) order by bar desc;
 ctid  | bar 
-------+-----
 (0,5) |   5
 (0,2) |   2
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (2,5) order by bar desc;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Scan Backward using skippy_idx on skippy_tbl  (cost=0.27..6.58 rows=2 width=10) (actual rows=2 loops=1)
   Index Cond: (bar = ANY ('{2,5}'::integer[]))
   Buffers: shared hit=3
(3 rows)

-- Adjoining non-pivot tuples split only by leaf page high key should require
-- only one descent of btree, so second page is read by read next page path:
select ctid, bar from skippy_tbl where bar in (366,367);
  ctid   | bar 
---------+-----
 (1,140) | 366
 (1,141) | 367
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (366,367);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using skippy_idx on skippy_tbl  (cost=0.27..6.58 rows=2 width=10) (actual rows=2 loops=1)
   Index Cond: (bar = ANY ('{366,367}'::integer[]))
   Buffers: shared hit=4
(3 rows)

-- Equivalent backwards scan:
select ctid, bar from skippy_tbl where bar in (366,367) order by bar desc;
  ctid   | bar 
---------+-----
 (1,141) | 367
 (1,140) | 366
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (366,367) order by bar desc;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Scan Backward using skippy_idx on skippy_tbl  (cost=0.27..6.58 rows=2 width=10) (actual rows=2 loops=1)
   Index Cond: (bar = ANY ('{366,367}'::integer[]))
   Buffers: shared hit=4
(3 rows)

-- Index-only scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to on;
set enable_indexscan to off;
-- This is the one that sometimes uses a sequential scan (when run as part of
-- the whole pg_regress suite):
select bar from skippy_tbl where bar in (2,3,4);
 bar 
-----
   2
   3
   4
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select bar from skippy_tbl where bar in (2,3,4);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Index Only Scan using skippy_idx on skippy_tbl  (cost=0.27..4.61 rows=3 width=4) (actual rows=3 loops=1)
   Disabled: true
   Index Cond: (bar = ANY ('{2,3,4}'::integer[]))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
select ctid, bar from skippy_tbl where bar in (2,3,4);
 ctid  | bar 
-------+-----
 (0,2) |   2
 (0,3) |   3
 (0,4) |   4
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (2,3,4);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=4.58..6.98 rows=3 width=10) (actual rows=3 loops=1)
   Recheck Cond: (bar = ANY ('{2,3,4}'::integer[]))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..4.58 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: (bar = ANY ('{2,3,4}'::integer[]))
         Buffers: shared hit=2
(7 rows)

-- Same as "simple example", but with duplicates:
insert into skippy_tbl(bar) values (22), (23), (23), (24), (24), (24);
vacuum analyze skippy_tbl;
select ctid, bar from skippy_tbl where bar in (22,23,24) order by bar;
  ctid  | bar 
--------+-----
 (0,22) |  22
 (2,49) |  22
 (2,50) |  23
 (0,23) |  23
 (2,51) |  23
 (2,54) |  24
 (2,52) |  24
 (2,53) |  24
 (0,24) |  24
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (22,23,24) order by bar;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Sort  (cost=7.89..7.91 rows=9 width=10) (actual rows=9 loops=1)
   Sort Key: bar
   Sort Method: quicksort  Memory: 25kB
   Buffers: shared hit=4
   ->  Bitmap Heap Scan on skippy_tbl  (cost=4.62..7.75 rows=9 width=10) (actual rows=9 loops=1)
         Recheck Cond: (bar = ANY ('{22,23,24}'::integer[]))
         Heap Blocks: exact=2
         Buffers: shared hit=4
         ->  Bitmap Index Scan on skippy_idx  (cost=0.00..4.62 rows=9 width=0) (actual rows=9 loops=1)
               Index Cond: (bar = ANY ('{22,23,24}'::integer[]))
               Buffers: shared hit=2
(11 rows)

-- 3 non-pivot tuple matches:
select * from skippy_tbl where bar in (362,365,366);
 bar 
-----
 362
 365
 366
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from skippy_tbl where bar in (362,365,366);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=4.56..6.97 rows=3 width=4) (actual rows=3 loops=1)
   Recheck Cond: (bar = ANY ('{362,365,366}'::integer[]))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..4.56 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: (bar = ANY ('{362,365,366}'::integer[]))
         Buffers: shared hit=2
(7 rows)

-- Test non-SAOP case in passing, to avoid regressions in how we handle
-- more standard "boundary cases":
select * from skippy_tbl where bar = 366;
 bar 
-----
 366
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from skippy_tbl where bar = 366;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=2.28..4.29 rows=1 width=4) (actual rows=1 loops=1)
   Recheck Cond: (bar = 366)
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..2.28 rows=1 width=0) (actual rows=1 loops=1)
         Index Cond: (bar = 366)
         Buffers: shared hit=2
(7 rows)

select * from skippy_tbl where bar = 367;
 bar 
-----
 367
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from skippy_tbl where bar = 367;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=2.28..4.29 rows=1 width=4) (actual rows=1 loops=1)
   Recheck Cond: (bar = 367)
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..2.28 rows=1 width=0) (actual rows=1 loops=1)
         Index Cond: (bar = 367)
         Buffers: shared hit=2
(7 rows)

---------------------------------------------------
-- Large group of duplicates spanning many pages --
---------------------------------------------------
insert into skippy_tbl
select
  555
from
  generate_series(1, 3000) i;
vacuum analyze skippy_tbl;
-- Looks like this now:
--
-- ┌───┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬──────────────────────────────────┐
-- │ i │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │             highkey              │
-- ├───┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼──────────────────────────────────┤
-- │ 1 │     1 │     1 │    372 │      3 │          0 │   373 │     0 │                 0 │      16 │       688 │ (bar)=(367)                      │
-- │ 2 │     2 │     1 │    134 │      2 │          0 │   135 │     0 │                 0 │      16 │     5,448 │ (bar)=(555)                      │
-- │ 3 │     4 │     1 │  1,278 │      6 │          0 │     7 │     0 │                 0 │   1,115 │       312 │ (bar)=(555), (htid)=('(7,202)')  │
-- │ 4 │     5 │     1 │  1,278 │      7 │          0 │     7 │     0 │                 0 │   1,115 │       312 │ (bar)=(555), (htid)=('(13,124)') │
-- │ 5 │     6 │     1 │    444 │      3 │          0 │    39 │     0 │                 0 │      78 │     4,920 │ ∅                                │
-- └───┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴──────────────────────────────────┘
--
---------------------------------------------------
-- Scan blknos 2,4,5,6
--
-- This avoids continuescan termination on block 2, which used to happen due
-- to using the wrong scan key (the first, from 500 constant).
-- It's fixed, so now we switch to next SAOP element rather than
-- terminate _bt_first-wise/_bt_search-wise scan at that point
--
-- This does one less buffer access than master (only 5, not 6).  Master has
-- an extra root page access, which we can avoid.  It's only one less because
-- master does at least avoid visiting the same leaf page a second time in its
-- second _bt_first-wise scan of the index.
select count(*) from skippy_tbl where bar in (500,555);
 count 
-------
  3001
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from skippy_tbl where bar in (500,555);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=94.84..94.85 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=7
   ->  Bitmap Heap Scan on skippy_tbl  (cost=33.83..87.34 rows=3001 width=0) (actual rows=3001 loops=1)
         Recheck Cond: (bar = ANY ('{500,555}'::integer[]))
         Buffers: shared hit=7
         ->  Bitmap Index Scan on skippy_idx  (cost=0.00..33.08 rows=3001 width=0) (actual rows=3001 loops=1)
               Index Cond: (bar = ANY ('{500,555}'::integer[]))
               Buffers: shared hit=5
(8 rows)

-- Same again, almost -- just don't scan blkno 2 this time
--
-- This results in one useful _bt_search call.  We can avoid another useless
-- one by realizing that we already ran out of tuples to output at the end of
-- the fist _bt_search (which doesn't return any 556 rows either, since there
-- is nothing to return).
--
-- This variant of the query requires only 4 buffer accesses. As against 6
-- buffer accesses total in index for master branch.  Here we win by more
-- compared to last time (by 2 buffer accesses) because the master branch
-- wasn't so lucky about not having to visit the same leaf page a second time.
select count(*) from skippy_tbl where bar in (555,556);
 count 
-------
  3000
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from skippy_tbl where bar in (555,556);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=94.84..94.85 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=6
   ->  Bitmap Heap Scan on skippy_tbl  (cost=33.83..87.34 rows=3001 width=0) (actual rows=3000 loops=1)
         Recheck Cond: (bar = ANY ('{555,556}'::integer[]))
         Buffers: shared hit=6
         ->  Bitmap Index Scan on skippy_idx  (cost=0.00..33.08 rows=3001 width=0) (actual rows=3000 loops=1)
               Index Cond: (bar = ANY ('{555,556}'::integer[]))
               Buffers: shared hit=4
(8 rows)

-- The previous test case exercises how _bt_readpage deals with non-matches
-- covering key space > the highest non-pivot tuple in the index and < +inf.
-- Make sure that it continues to do that by checking the maximum value in the
-- index:
select max(bar) from skippy_tbl having max(bar) = 555; -- avoids regressing test coverage (i.e. tests the tests)
 max 
-----
 555
(1 row)

-- We do want to go through the root (3) to descend to the leftmost page (1) and then step to its right
-- sibling page (2):
-- XXX right now we don't do that -- what we actually do is redescend from the
-- root anew instead, just like the master branch -- so it's 4 buffer accesses
-- on the index instead of 3 accesses (we fall short of the obtainable
-- ideal, for now, since we're not yet able to be clever about using info from
-- internal pages -- nor are we willing to gamble even more aggressively).
select ctid, bar from skippy_tbl where bar in (1, 500);
  ctid  | bar 
--------+-----
 (0,1)  |   1
 (2,48) | 500
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, bar from skippy_tbl where bar in (1, 500);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=4.58..7.89 rows=2 width=10) (actual rows=2 loops=1)
   Recheck Cond: (bar = ANY ('{1,500}'::integer[]))
   Heap Blocks: exact=2
   Buffers: shared hit=6
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..4.57 rows=2 width=0) (actual rows=2 loops=1)
         Index Cond: (bar = ANY ('{1,500}'::integer[]))
         Buffers: shared hit=4
(7 rows)

-- Now show a similar case where even now we manage to get the obtainable
-- ideal (same path through the index is actually attained this time around).
-- This is possible here, independent of any speculative behavior and/or
-- cleverness when we descend the tree -- since the high key is 367, which
-- matches qual exactly. (We get only one descent and 3 buffer accesses,
-- versus master's 2 descents and 4 buffer accesses.  We manage to do better
-- than master, despite the fact that even master doesn't revisit the same
-- leaf page twice here -- master's only failing is that it touches the root
-- page a second time.)
select ctid, * from skippy_tbl where bar = any ('{365,367}');
  ctid   | bar 
---------+-----
 (1,139) | 365
 (1,141) | 367
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from skippy_tbl where bar = any ('{365,367}');
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=4.58..7.89 rows=2 width=10) (actual rows=2 loops=1)
   Recheck Cond: (bar = ANY ('{365,367}'::integer[]))
   Heap Blocks: exact=1
   Buffers: shared hit=4
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..4.57 rows=2 width=0) (actual rows=2 loops=1)
         Index Cond: (bar = ANY ('{365,367}'::integer[]))
         Buffers: shared hit=3
(7 rows)

-- However, the patch isn't entirely free of such speculative behavior.
-- Here is a more complicated case that manages to be optimal -- though
-- barely.  Here we take a small gamble, and win.
--
-- This time around we don't have an exact leftmost page high key (367) match.
-- But we still win, since we do have 366 in both qual and in index (must be
-- both):
--
-- XXX UPDATE (December 3): Not anymore.  No longer speculatively visit next
-- page without an exact match for non-truncated columns
select * from skippy_tbl where bar = any ('{365,366,368}');
 bar 
-----
 365
 366
 368
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from skippy_tbl where bar = any ('{365,366,368}');
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=6.86..11.61 rows=3 width=4) (actual rows=3 loops=1)
   Recheck Cond: (bar = ANY ('{365,366,368}'::integer[]))
   Heap Blocks: exact=1
   Buffers: shared hit=5
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..6.86 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: (bar = ANY ('{365,366,368}'::integer[]))
         Buffers: shared hit=4
(7 rows)

-- We were "between the values 366 and 368" at the point that we reached the
-- high key, whose value is 367 -- which is also "between" the same two
-- values.  On that basis alone we decided to move right.  We gambled and won.
-- This was a limited form of gamble that was only chosen because the only
-- value we were missing from page was the high key, 367.  The high key is a
-- little special here.
--
-- Now lets try almost the same case, just with 366 missing.  That has a
-- surprisingly big impact: now we won't gamble at all.  This time when we
-- compare our search-type scan key to the non-pivot 366, we didn't get a
-- match, AND we terminated the scan locally (we accepted continuescan=false).
select * from skippy_tbl where bar = any ('{365,368}');   -- omit non-pivot value '366' this time
 bar 
-----
 365
 368
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from skippy_tbl where bar = any ('{365,368}');   -- 4 buffer accesses again
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=4.58..7.89 rows=2 width=4) (actual rows=2 loops=1)
   Recheck Cond: (bar = ANY ('{365,368}'::integer[]))
   Heap Blocks: exact=1
   Buffers: shared hit=5
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..4.57 rows=2 width=0) (actual rows=2 loops=1)
         Index Cond: (bar = ANY ('{365,368}'::integer[]))
         Buffers: shared hit=4
(7 rows)

-- Now we'll show a gamble that doesn't pay off -- same rationale as earlier
-- gamble case, but this time we're not so lucky.  As a result, this query
-- needs an extra buffer access compared to master/no optimization case:
--
-- (This time we lose because 2147483647 isn't on the next page, despite it
-- seeming like it might.  XXX For now we'll accept this as a bad speculation;
-- a cost of doing business.  Might want to rereview that decision later on.)
--
-- Here we get 5 index buffer hits (one extra):
--
-- XXX UPDATE (December 3): not anymore.  As already noted in last UPDATE from
-- today, we don't move to next page when high key isn't an exact match in
-- respect of non-truncated attributes.  So no extra buffer hit (4 hits only).
select * from skippy_tbl where bar = any ('{366,2147483647}');
 bar 
-----
 366
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from skippy_tbl where bar = any ('{366,2147483647}');
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on skippy_tbl  (cost=4.58..7.89 rows=2 width=4) (actual rows=1 loops=1)
   Recheck Cond: (bar = ANY ('{366,2147483647}'::integer[]))
   Heap Blocks: exact=1
   Buffers: shared hit=5
   ->  Bitmap Index Scan on skippy_idx  (cost=0.00..4.57 rows=2 width=0) (actual rows=1 loops=1)
         Index Cond: (bar = ANY ('{366,2147483647}'::integer[]))
         Buffers: shared hit=4
(7 rows)

-- (August 21) Infinite loop binary-search-array-keys bug test case:
insert into skippy_tbl select 2^31-1;
with a as (
  select
    i
  from
    generate_series(1, 150000) i
)
select count(*) from skippy_tbl
where bar = any(array[(select array_agg(i) from a)]);
 count 
-------
  3506
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
with a as (
  select
    i
  from
    generate_series(1, 150000) i
)
select count(*) from skippy_tbl
where bar = any(array[(select array_agg(i) from a)]);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=1900.11..1900.12 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=9
   InitPlan 1
     ->  Aggregate  (cost=1875.01..1875.02 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..1500.00 rows=150000 width=4) (actual rows=150000 loops=1)
   ->  Bitmap Heap Scan on skippy_tbl  (cost=7.37..24.93 rows=69 width=0) (actual rows=3506 loops=1)
         Recheck Cond: (bar = ANY (ARRAY[(InitPlan 1).col1]))
         Heap Blocks: exact=1
         Buffers: shared hit=9
         ->  Bitmap Index Scan on skippy_idx  (cost=0.00..7.36 rows=69 width=0) (actual rows=3506 loops=1)
               Index Cond: (bar = ANY (ARRAY[(InitPlan 1).col1]))
               Buffers: shared hit=6
(12 rows)

-- Backwards scan (more or less equivalent)
set enable_sort = off;
with a as (
  select
    i
  from
    generate_series(1, 150000) i
)
select * from skippy_tbl
where bar = any(array[(select array_agg(i) from a)]) order by bar desc limit 50 offset 3000;
 bar 
-----
 500
 499
 498
 497
 496
 495
 494
 493
 492
 491
 490
 489
 488
 487
 486
 485
 484
 483
 482
 481
 480
 479
 478
 477
 476
 475
 474
 473
 472
 471
 470
 469
 468
 467
 466
 465
 464
 463
 462
 461
 460
 459
 458
 457
 456
 455
 454
 453
 452
 451
(50 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
with a as (
  select
    i
  from
    generate_series(1, 150000) i
)
select * from skippy_tbl
where bar = any(array[(select array_agg(i) from a)]) order by bar desc limit 50 offset 3000;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1885.07..1885.22 rows=1 width=4) (actual rows=50 loops=1)
   Buffers: shared hit=35
   InitPlan 1
     ->  Aggregate  (cost=1875.01..1875.02 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..1500.00 rows=150000 width=4) (actual rows=150000 loops=1)
   ->  Index Scan Backward using skippy_idx on skippy_tbl  (cost=0.28..10.06 rows=69 width=4) (actual rows=3050 loops=1)
         Disabled: true
         Index Cond: (bar = ANY (ARRAY[(InitPlan 1).col1]))
         Buffers: shared hit=35
(9 rows)

-----------------------------------------------------------------------
-- "More than one so->numArrayKeys" test case (uses 2 SAOPs/columns) --
-----------------------------------------------------------------------
set client_min_messages=error;
drop table if exists multi_test;
reset client_min_messages;
create unlogged table multi_test(
  a int,
  b int
);
create index multi_test_idx on multi_test(a, b);
insert into multi_test
select
  j,
  case when i < 14 then
    0
  else
    1
  end
from
  generate_series(1, 14) i,
  generate_series(1, 400) j
order by
  j,
  i;
vacuum analyze multi_test;
-- Looks like this now:
--
-- ┌───┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬──────────────┐
-- │ i │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │   highkey    │
-- ├───┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼──────────────┤
-- │ 1 │     1 │     1 │    854 │      4 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(62)  │
-- │ 2 │     2 │     1 │    854 │      5 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(123) │
-- │ 3 │     4 │     1 │    854 │      5 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(184) │
-- │ 4 │     5 │     1 │    854 │      5 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(245) │
-- │ 5 │     6 │     1 │    854 │      4 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(306) │
-- │ 6 │     7 │     1 │    854 │      5 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(367) │
-- │ 7 │     8 │     1 │    476 │      3 │          0 │    80 │     0 │                 0 │      49 │     3,908 │ ∅            │
-- └───┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴──────────────┘
--
-----------------------------------------------------------------------
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Simpler case
-- Should only need to scan root page (3) plus a single leaf page (4)
--
-- This means that _bt_checkkeys() continuescan handling mustn't get confused
-- about boundary conditions  in the presence of relatively complicated cases,
-- which this is -- multiple so->numArrayKeys is fairly rare.
select * from multi_test where a in (183) and b in (1,2,3,4,5,6,7,8,9,10,11,12);
  a  | b 
-----+---
 183 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (183) and b in (1,2,3,4,5,6,7,8,9,10,11,12);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.91..8.93 rows=1 width=8) (actual rows=1 loops=1)
   Recheck Cond: ((a = 183) AND (b = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=1 loops=1)
         Index Cond: ((a = 183) AND (b = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12}'::integer[])))
         Buffers: shared hit=2
(7 rows)

-- Harder case
-- Should only need to scan root page (3) plus a single leaf page (4).  This
-- is a bit trickier for _bt_checkkeys()-adjacent logic.
select * from multi_test where a in (123, 182, 183) and b in (1,2);
  a  | b 
-----+---
 123 | 1
 182 | 1
 183 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (123, 182, 183) and b in (1,2);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..11.89 rows=3 width=8) (actual rows=3 loops=1)
   Recheck Cond: ((a = ANY ('{123,182,183}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Blocks: exact=2
   Buffers: shared hit=4
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: ((a = ANY ('{123,182,183}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=2
(7 rows)

-- Hard case
-- Also needs to scan root page (3) plus leaf page 4 (like "Simpler case").
-- But this time we can't avoid going to a second leaf page -- leaf page 5.
-- That's where matches exceeding (184, -inf) are located.
select * from multi_test where a in (182, 183, 184) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 184 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 184) and b in (1,2);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..11.89 rows=3 width=8) (actual rows=3 loops=1)
   Recheck Cond: ((a = ANY ('{182,183,184}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=4
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: ((a = ANY ('{182,183,184}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=3
(7 rows)

-- Hard luck case
-- Here we gamble and lose.  Almost like earlier skippy_tbl test case, but with
-- multiple SAOP columns for additional test coverage.  And, we only get a
-- single _bt_search because we were "almost correct".
--
-- That is, we descend from the root (3) to leaf page 4, which has matches.
-- Then we gamble by moving right on the leaf level, moving to sibling page 5,
-- which has no matches.  However, page 5 _does_ have a high key that makes us
-- want to move right again, to page 6 -- which is where our final match is
-- found!
select * from multi_test where a in (182, 183, 245) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 245 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 245) and b in (1,2); -- 4 buffer hits
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..11.89 rows=3 width=8) (actual rows=3 loops=1)
   Recheck Cond: ((a = ANY ('{182,183,245}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Blocks: exact=2
   Buffers: shared hit=6
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: ((a = ANY ('{182,183,245}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=4
(7 rows)

-- Harder luck case
-- Two _bt_search descents this time (we _bt_first once we
-- reach page 5 because its high key indicates that it's time to quit gambling)
--
-- XXX UPDATE (December 3) Not anymore, no more moving to right page when our
-- high key lacks an exact match for non-truncated columns.
select * from multi_test where a in (182, 183, 306) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 306 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 306) and b in (1,2); -- 4 buffer hits
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..11.89 rows=3 width=8) (actual rows=3 loops=1)
   Recheck Cond: ((a = ANY ('{182,183,306}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Blocks: exact=2
   Buffers: shared hit=6
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: ((a = ANY ('{182,183,306}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=4
(7 rows)

-- Not-SK_BT_REQFWD-but-still-insertion-scankey case
--
-- This is an example of how insertion scankey can have an attribute/value for
-- "b", even though "b" entry in search-type scankey doesn't end up SK_BT_REQFWD:
-- (_bt_array_continuescan actually encounters this directly, too)
select * from multi_test where a in (3,4,5) and b > 0;
 a | b 
---+---
 3 | 1
 4 | 1
 5 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b > 0;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..11.89 rows=3 width=8) (actual rows=3 loops=1)
   Recheck Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
         Buffers: shared hit=2
(7 rows)

-- Variant (for good luck)
select * from multi_test where a in (3,4,5) and b >= 0;
 a | b 
---+---
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 1
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 1
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 1
(42 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b >= 0;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.28..31.90 rows=42 width=8) (actual rows=42 loops=1)
   Recheck Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b >= 0))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.27 rows=42 width=0) (actual rows=42 loops=1)
         Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b >= 0))
         Buffers: shared hit=2
(7 rows)

-- This time we make "a" touch a boundary, in the style of "harder case":
select * from multi_test where a in (123, 182, 183) and b > 0;
  a  | b 
-----+---
 123 | 1
 182 | 1
 183 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (123, 182, 183) and b > 0; -- 2 buffer hits
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..11.89 rows=3 width=8) (actual rows=3 loops=1)
   Recheck Cond: ((a = ANY ('{123,182,183}'::integer[])) AND (b > 0))
   Heap Blocks: exact=2
   Buffers: shared hit=4
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3 loops=1)
         Index Cond: ((a = ANY ('{123,182,183}'::integer[])) AND (b > 0))
         Buffers: shared hit=2
(7 rows)

-- This time we make "a" touch a boundary "inside the high key":
-- XXX UPDATE (February 28): This is 4 index buffer hits due to the
-- restriction on inequalities required in the opposite-to-scan direction
-- only.
--
-- XXX UPDATE (October 16 2024) Behavioral update to
-- required-in-opposite-direction-only scan keys has made this case get only 3
-- buffer hits (this will get 4 buffer hits on Postgres 17, though).
select * from multi_test where a in (123, 182, 183, 184) and b > 0;
  a  | b 
-----+---
 123 | 1
 182 | 1
 183 | 1
 184 | 1
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (123, 182, 183, 184) and b > 0; -- 3 buffer hits
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..13.35 rows=4 width=8) (actual rows=4 loops=1)
   Recheck Cond: ((a = ANY ('{123,182,183,184}'::integer[])) AND (b > 0))
   Heap Blocks: exact=2
   Buffers: shared hit=5
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=4 width=0) (actual rows=4 loops=1)
         Index Cond: ((a = ANY ('{123,182,183,184}'::integer[])) AND (b > 0))
         Buffers: shared hit=3
(7 rows)

-- This time we make "b" search-type scankey required:
--
-- This is an example of the opposite: where an insertion scan key lacks an
-- entry corresponding to a search-type scankey's SK_BT_REQFWD entry.
-- (_bt_array_continuescan actually encounters this directly, too)
select * from multi_test where a in (3,4,5) and b < 0;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b < 0;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.89 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 0))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 0))
         Buffers: shared hit=2
(6 rows)

-- Variant (for good luck)
select * from multi_test where a in (3,4,5) and b < 1;
 a | b 
---+---
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b < 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.24 rows=39 width=8) (actual rows=39 loops=1)
   Recheck Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=39 width=0) (actual rows=39 loops=1)
         Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 1))
         Buffers: shared hit=2
(7 rows)

-- This time we make "a" touch a boundary, in the style of "harder case":
select * from multi_test where a in (123, 182, 183) and b < 3;
  a  | b 
-----+---
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 1
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 1
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 1
(42 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (123, 182, 183) and b < 3; -- 2 buffer hits
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.28..31.90 rows=42 width=8) (actual rows=42 loops=1)
   Recheck Cond: ((a = ANY ('{123,182,183}'::integer[])) AND (b < 3))
   Heap Blocks: exact=2
   Buffers: shared hit=4
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.27 rows=42 width=0) (actual rows=42 loops=1)
         Index Cond: ((a = ANY ('{123,182,183}'::integer[])) AND (b < 3))
         Buffers: shared hit=2
(7 rows)

-- This time we make "a" touch a boundary "inside the high key":
-- XXX UPDATE (February 28): This is only 3 index buffer hits due to not
-- running afoul of the restriction on inequalities required in the
-- opposite-to-scan direction only (this inequality is required in the scan
-- direction, so we're good) .
select * from multi_test where a in (123, 182, 183, 184) and b < 3;
  a  | b 
-----+---
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 0
 123 | 1
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 1
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 0
 183 | 1
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 1
(56 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (123, 182, 183, 184) and b < 3; -- 3 buffer hits
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.43..33.41 rows=56 width=8) (actual rows=56 loops=1)
   Recheck Cond: ((a = ANY ('{123,182,183,184}'::integer[])) AND (b < 3))
   Heap Blocks: exact=2
   Buffers: shared hit=5
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.42 rows=56 width=0) (actual rows=56 loops=1)
         Index Cond: ((a = ANY ('{123,182,183,184}'::integer[])) AND (b < 3))
         Buffers: shared hit=3
(7 rows)

-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Simpler case
-- As above.
select * from multi_test where a in (183) and b in (1,2,3,4,5,6,7,8,9,10,11,12);
  a  | b 
-----+---
 183 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (183) and b in (1,2,3,4,5,6,7,8,9,10,11,12);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..8.89 rows=1 width=8) (actual rows=1 loops=1)
   Index Cond: ((a = 183) AND (b = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12}'::integer[])))
   Buffers: shared hit=3
(3 rows)

-- Now as a backwards scan
select * from multi_test where a in (183) and b in (1,2,3,4,5,6,7,8,9,10,11,12)
order by a desc, b desc;
  a  | b 
-----+---
 183 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (183) and b in (1,2,3,4,5,6,7,8,9,10,11,12)
order by a desc, b desc;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_idx on multi_test  (cost=0.28..8.89 rows=1 width=8) (actual rows=1 loops=1)
   Index Cond: ((a = 183) AND (b = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12}'::integer[])))
   Buffers: shared hit=3
(3 rows)

-- Hard case
-- As above.
select * from multi_test where a in (182, 183, 184) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 184 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 184) and b in (1,2);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..10.66 rows=3 width=8) (actual rows=3 loops=1)
   Index Cond: ((a = ANY ('{182,183,184}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Buffers: shared hit=4
(3 rows)

-- Hard case backwards scan variant (just for coverage):
set enable_sort=off;
select * from multi_test where a in (182, 183, 184) and b in (1,2) order by a desc, b desc;
  a  | b 
-----+---
 184 | 1
 183 | 1
 182 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 184) and b in (1,2) order by a desc, b desc;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_idx on multi_test  (cost=0.28..10.66 rows=3 width=8) (actual rows=3 loops=1)
   Index Cond: ((a = ANY ('{182,183,184}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Buffers: shared hit=5
(3 rows)

set enable_sort=on;
-- Hard luck case
-- As above.
select * from multi_test where a in (182, 183, 245) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 245 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 245) and b in (1,2);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..10.66 rows=3 width=8) (actual rows=3 loops=1)
   Index Cond: ((a = ANY ('{182,183,245}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Buffers: shared hit=6
(3 rows)

-- Harder luck case
-- As above.
select * from multi_test where a in (182, 183, 306) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 306 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 306) and b in (1,2);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..10.66 rows=3 width=8) (actual rows=3 loops=1)
   Index Cond: ((a = ANY ('{182,183,306}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Buffers: shared hit=6
(3 rows)

-- Not-SK_BT_REQFWD-but-still-insertion-scankey case
-- As above.
select * from multi_test where a in (3,4,5) and b > 0;
 a | b 
---+---
 3 | 1
 4 | 1
 5 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b > 0;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..10.66 rows=3 width=8) (actual rows=3 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
   Buffers: shared hit=3
(3 rows)

-- As a backwards scan:
select * from multi_test where a in (3,4,5) and b > 0
order by a desc, b desc;
 a | b 
---+---
 5 | 1
 4 | 1
 3 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b > 0
order by a desc, b desc;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_idx on multi_test  (cost=0.28..10.66 rows=3 width=8) (actual rows=3 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
   Buffers: shared hit=3
(3 rows)

-- Variant (for good luck)
select * from multi_test where a in (3,4,5) and b >= 0;
 a | b 
---+---
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 1
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 1
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 1
(42 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b >= 0;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..28.94 rows=42 width=8) (actual rows=42 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b >= 0))
   Buffers: shared hit=3
(3 rows)

-- As a backwards scan:
select * from multi_test where a in (3,4,5) and b >= 0
order by a desc, b desc;
 a | b 
---+---
 5 | 1
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 4 | 1
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 3 | 1
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
(42 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b >= 0
order by a desc, b desc;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_idx on multi_test  (cost=0.28..28.94 rows=42 width=8) (actual rows=42 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b >= 0))
   Buffers: shared hit=3
(3 rows)

-- This time we make "b" search-type scankey required:
select * from multi_test where a in (3,4,5) and b < 0;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b < 0;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..8.89 rows=1 width=8) (actual rows=0 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 0))
   Buffers: shared hit=2
(3 rows)

-- With <= instead of <:
select * from multi_test where a in (3,4,5) and b <= -1;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b <= -1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..8.89 rows=1 width=8) (actual rows=0 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b <= '-1'::integer))
   Buffers: shared hit=2
(3 rows)

-- As a backwards scan:
select * from multi_test where a in (3,4,5) and b < 0
order by a desc, b desc;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b < 0
order by a desc, b desc;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_idx on multi_test  (cost=0.28..8.89 rows=1 width=8) (actual rows=0 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 0))
   Buffers: shared hit=2
(3 rows)

-- As a backwards scan with <= instead of <:
select * from multi_test where a in (3,4,5) and b <= -1
order by a desc, b desc;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b <= -1
order by a desc, b desc;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_idx on multi_test  (cost=0.28..8.89 rows=1 width=8) (actual rows=0 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b <= '-1'::integer))
   Buffers: shared hit=2
(3 rows)

-- Variant (for good luck)
select * from multi_test where a in (3,4,5) and b < 1;
 a | b 
---+---
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b < 1;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..28.00 rows=39 width=8) (actual rows=39 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 1))
   Buffers: shared hit=3
(3 rows)

-- Variant (for good luck) with <= instead of <
select * from multi_test where a in (3,4,5) and b <= 0;
 a | b 
---+---
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b <= 0;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Index Scan using multi_test_idx on multi_test  (cost=0.28..28.00 rows=39 width=8) (actual rows=39 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b <= 0))
   Buffers: shared hit=3
(3 rows)

-- As a backwards scan:
select * from multi_test where a in (3,4,5) and b < 1
order by a desc, b desc;
 a | b 
---+---
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b < 1
order by a desc, b desc;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_idx on multi_test  (cost=0.28..28.00 rows=39 width=8) (actual rows=39 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 1))
   Buffers: shared hit=3
(3 rows)

-- As a backwards scan with <= instead of <:
select * from multi_test where a in (3,4,5) and b <= 0
order by a desc, b desc;
 a | b 
---+---
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b <= 0
order by a desc, b desc;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_idx on multi_test  (cost=0.28..28.00 rows=39 width=8) (actual rows=39 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b <= 0))
   Buffers: shared hit=3
(3 rows)

-- Index-only scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to on;
set enable_indexscan to off;
-- Simpler case
-- As above.
select * from multi_test where a in (183) and b in (1,2,3,4,5,6,7,8,9,10,11,12);
  a  | b 
-----+---
 183 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (183) and b in (1,2,3,4,5,6,7,8,9,10,11,12);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.89 rows=1 width=8) (actual rows=1 loops=1)
   Disabled: true
   Index Cond: ((a = 183) AND (b = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

-- Hard case
-- As above.
select * from multi_test where a in (182, 183, 184) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 184 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 184) and b in (1,2);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.91 rows=3 width=8) (actual rows=3 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{182,183,184}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=4
(5 rows)

-- Hard luck case
-- As above.
select * from multi_test where a in (182, 183, 245) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 245 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 245) and b in (1,2);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.91 rows=3 width=8) (actual rows=3 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{182,183,245}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=5
(5 rows)

-- Harder luck case
-- As above.
select * from multi_test where a in (182, 183, 306) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 306 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (182, 183, 306) and b in (1,2);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.91 rows=3 width=8) (actual rows=3 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{182,183,306}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=5
(5 rows)

-- Not-SK_BT_REQFWD-but-still-insertion-scankey case
-- As above.
select * from multi_test where a in (3,4,5) and b > 0;
 a | b 
---+---
 3 | 1
 4 | 1
 5 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b > 0;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.91 rows=3 width=8) (actual rows=3 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

-- Variant (for good luck)
select * from multi_test where a in (3,4,5) and b >= 0;
 a | b 
---+---
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 1
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 1
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 1
(42 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b >= 0;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..7.69 rows=42 width=8) (actual rows=42 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b >= 0))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

-- This time we make "b" search-type scankey required:
select * from multi_test where a in (3,4,5) and b < 0;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b < 0;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.89 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 0))
   Heap Fetches: 0
   Buffers: shared hit=2
(5 rows)

-- Variant (for good luck)
select * from multi_test where a in (3,4,5) and b < 1;
 a | b 
---+---
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (3,4,5) and b < 1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..7.63 rows=39 width=8) (actual rows=39 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 1))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

-- (November 5) when _bt_preprocess_array_keys has two arrays against the same
-- column that have no intersecting elements, preprocessing will leave the
-- arrays empty.
--
-- This test makes sure that both scan keys are eliminated (not just the
-- second).
select * from multi_test where a in (180,345) and a in (230, 300);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a in (180,345) and a in (230, 300);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.89 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{180,345}'::integer[])) AND (a = ANY ('{230,300}'::integer[])))
   Heap Fetches: 0
(4 rows)

-- (February 2) Same again, but this time use bigint arrays -- still should be
-- detected as contradictory within _bt_preprocess_array_keys (not later
-- _bt_preprocess_keys start-of-primscan code paths).
--
-- This doesn't run afoul of any of the implementation restrictions inside
-- _bt_preprocess_array_keys because the array elements themselves are of the
-- same type -- that's all that matters there (the mere presence of cross-type
-- operators does _not_ matter, that's orthogonal).
select * from multi_test where a = any('{180,345}'::bigint[]) and a = any('{230,300}'::bigint[]);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a = any('{180,345}'::bigint[]) and a = any('{230,300}'::bigint[]);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.89 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{180,345}'::bigint[])) AND (a = ANY ('{230,300}'::bigint[])))
   Heap Fetches: 0
(4 rows)

-- (February 2) Note, however, that this variant cannot use that same
-- _bt_preprocess_array_keys merging/contradictory keys detection.
-- It must use the slightly less efficient handling in _bt_preprocess_keys
-- (works at the level of individual primitive index scans).
--
-- (March 10) UPDATE: Actually, it can, since we now have _bt_preprocess_keys
-- "operate on whole arrays".  This includes having _bt_preprocess_array_keys
-- merge together arrays of different types when necessary.
select * from multi_test where a = any('{180,345}'::bigint[]) and a = any('{230,300}'::integer[]);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from multi_test where a = any('{180,345}'::bigint[]) and a = any('{230,300}'::integer[]);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..6.89 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{180,345}'::bigint[])) AND (a = ANY ('{230,300}'::integer[])))
   Heap Fetches: 0
(4 rows)

-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- (February 27) This is why the "optimistically go to next leaf page given
-- uncertainty with truncated required scan key attributes" might be worth the
-- complexity:
with a as (
  select i from generate_series(1, 400) i
)
select count(*)
from
  multi_test
where
  a = any (array[( select array_agg(i) from a)])
  and b in (0, 1, 2, 3);
 count 
-------
  5600
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 8 buffer hits, not 14
with a as (
  select i from generate_series(1, 400) i
)
select count(*)
from
  multi_test
where
  a = any (array[( select array_agg(i) from a)])
  and b in (0, 1, 2, 3);
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=42.05..42.06 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=10
   InitPlan 1
     ->  Aggregate  (cost=5.01..5.02 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..4.00 rows=400 width=4) (actual rows=400 loops=1)
   ->  Bitmap Heap Scan on multi_test  (cost=8.17..36.72 rows=129 width=0) (actual rows=5600 loops=1)
         Recheck Cond: ((a = ANY (ARRAY[(InitPlan 1).col1])) AND (b = ANY ('{0,1,2,3}'::integer[])))
         Buffers: shared hit=10
         ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..8.14 rows=129 width=0) (actual rows=5600 loops=1)
               Index Cond: ((a = ANY (ARRAY[(InitPlan 1).col1])) AND (b = ANY ('{0,1,2,3}'::integer[])))
               Buffers: shared hit=8
(11 rows)

-- (June 8 2024) Skip scan equivalent of last test case:
select count(*)
from
  multi_test
where
  b in (0, 1, 2, 3);
 count 
-------
  5600
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 8 buffer hits, not 14
select count(*)
from
  multi_test
where
  b in (0, 1, 2, 3);
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=178.10..178.11 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=10
   ->  Bitmap Heap Scan on multi_test  (cost=61.59..165.02 rows=5229 width=0) (actual rows=5600 loops=1)
         Recheck Cond: (b = ANY ('{0,1,2,3}'::integer[]))
         Buffers: shared hit=10
         ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..60.28 rows=5229 width=0) (actual rows=5600 loops=1)
               Index Cond: (b = ANY ('{0,1,2,3}'::integer[]))
               Buffers: shared hit=8
(8 rows)

-- (February 28) This similar case also gets to jump from leaf page to leaf
-- page (a little less compelling than the last example, but it still works).
-- While it involves an inequality, it's required in the same direction as the
-- scan so we're good:
with a as (
  select i from generate_series(1, 400) i
)
select count(*)
from
  multi_test
where
  a = any (array[( select array_agg(i) from a)])
  and b < 4;
 count 
-------
  5600
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 8 buffer hits, not 14
with a as (
  select i from generate_series(1, 400) i
)
select count(*)
from
  multi_test
where
  a = any (array[( select array_agg(i) from a)])
  and b < 4;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=42.07..42.08 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=10
   InitPlan 1
     ->  Aggregate  (cost=5.01..5.02 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..4.00 rows=400 width=4) (actual rows=400 loops=1)
   ->  Bitmap Heap Scan on multi_test  (cost=8.26..36.71 rows=138 width=0) (actual rows=5600 loops=1)
         Recheck Cond: ((a = ANY (ARRAY[(InitPlan 1).col1])) AND (b < 4))
         Buffers: shared hit=10
         ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..8.23 rows=138 width=0) (actual rows=5600 loops=1)
               Index Cond: ((a = ANY (ARRAY[(InitPlan 1).col1])) AND (b < 4))
               Buffers: shared hit=8
(11 rows)

-- (June 8 2024) Skip scan equivalent of last test case:
select count(*)
from
  multi_test
where
  b < 4;
 count 
-------
  5600
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*)
from
  multi_test
where
  b < 4;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=170.68..170.69 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=10
   ->  Bitmap Heap Scan on multi_test  (cost=61.68..156.68 rows=5600 width=0) (actual rows=5600 loops=1)
         Recheck Cond: (b < 4)
         Buffers: shared hit=10
         ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..60.28 rows=5600 width=0) (actual rows=5600 loops=1)
               Index Cond: (b < 4)
               Buffers: shared hit=8
(8 rows)

-- (February 28) This similar case doesn't get to jump from leaf page to leaf
-- page, even though it's almost the same query as the last one (but I can
-- live with this one).  It's unsupported because it involves an inequality
-- marked required in the opposite direction only (how is _bt_check_compare
-- supposed to even notice this when we arrive on the next page having
-- speculated?):
--
-- XXX UPDATE (October 16 2024) Behavioral update to
-- required-in-opposite-direction-only scan keys has made this case behave
-- similarly to the last one -- now both get 8 buffer hits (this will get 14
-- buffer hits on Postgres 17, though).
with a as (
  select i from generate_series(1, 400) i
)
select count(*)
from
  multi_test
where
  a = any (array[( select array_agg(i) from a)])
  and b >= 0;
 count 
-------
  5600
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 8 buffer hits, not 14
with a as (
  select i from generate_series(1, 400) i
)
select count(*)
from
  multi_test
where
  a = any (array[( select array_agg(i) from a)])
  and b >= 0;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=42.07..42.08 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=10
   InitPlan 1
     ->  Aggregate  (cost=5.01..5.02 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..4.00 rows=400 width=4) (actual rows=400 loops=1)
   ->  Bitmap Heap Scan on multi_test  (cost=8.26..36.71 rows=138 width=0) (actual rows=5600 loops=1)
         Recheck Cond: ((a = ANY (ARRAY[(InitPlan 1).col1])) AND (b >= 0))
         Buffers: shared hit=10
         ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..8.23 rows=138 width=0) (actual rows=5600 loops=1)
               Index Cond: ((a = ANY (ARRAY[(InitPlan 1).col1])) AND (b >= 0))
               Buffers: shared hit=8
(11 rows)

-- (June 8 2024) Skip scan equivalent of last test case:
select count(*)
from
  multi_test
where
  b >= 0;
 count 
-------
  5600
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*)
from
  multi_test
where
  b >= 0;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=170.68..170.69 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=10
   ->  Bitmap Heap Scan on multi_test  (cost=61.68..156.68 rows=5600 width=0) (actual rows=5600 loops=1)
         Recheck Cond: (b >= 0)
         Buffers: shared hit=10
         ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..60.28 rows=5600 width=0) (actual rows=5600 loops=1)
               Index Cond: (b >= 0)
               Buffers: shared hit=8
(8 rows)

-- (March 1) This test determines if we're capable of proving that IS NULL
-- combined with IN() makes for a contradictory qual, which I assumed worked,
-- until realizing today that it never actually did.
--
-- In my defense, this is rather difficult to actually prove.  The planner
-- "helpfully" determines that the qual is contradictory ahead of time,
-- denying nbtree the opportunity to figure it out on its own, and make the
-- entire index scan a no-op.  Here I've had to trick the planner into
-- thinking that that reduction is invalid (it's probably actually still valid
-- with this formulation as written, but it's still good enough to fool the
-- planner and get a usable test case so whatever).
prepare is_null_confusion as
select a, b
from
  multi_test
where
  a = any($1) and a is null;
execute is_null_confusion ('{1,2,3}');
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
execute is_null_confusion ('{1,2,3}');
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.89 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,2,3}'::integer[])) AND (a IS NULL))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,2,3}'::integer[])) AND (a IS NULL))
(4 rows)

deallocate is_null_confusion;
-- Same again, but with IS NOT NULL + NULL array
prepare is_not_null_confusion as
select a, b
from
  multi_test
where
  a = any($1) and a is not null;
execute is_not_null_confusion (NULL);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
execute is_not_null_confusion (NULL);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=2.29..4.30 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY (NULL::integer[])) AND (a IS NOT NULL))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..2.29 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY (NULL::integer[])) AND (a IS NOT NULL))
(4 rows)

deallocate is_not_null_confusion;
-- Same again, but with a NULL array alone
prepare null_array_confusion as
select a, b
from
  multi_test
where
  a = any($1);
execute null_array_confusion (NULL);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
execute null_array_confusion (NULL);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=2.29..4.30 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: (a = ANY (NULL::integer[]))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..2.29 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: (a = ANY (NULL::integer[]))
(4 rows)

deallocate null_array_confusion;
prepare null_array_elements_coverage as
select a, b
from
  multi_test
where
  a = any($1);
-- _bt_preprocess_array_keys deals eliminates NULL array elements up front:
execute null_array_elements_coverage ('{1, NULL, 2}');
 a | b 
---+---
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 1
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 0
 2 | 1
(28 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 buffer hits
execute null_array_elements_coverage ('{1, NULL, 2}');
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.06..28.17 rows=28 width=8) (actual rows=28 loops=1)
   Recheck Cond: (a = ANY ('{1,NULL,2}'::integer[]))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.05 rows=28 width=0) (actual rows=28 loops=1)
         Index Cond: (a = ANY ('{1,NULL,2}'::integer[]))
         Buffers: shared hit=2
(7 rows)

execute null_array_elements_coverage ('{NULL,NULL,NULL, NULL, NULL}');
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
execute null_array_elements_coverage ('{NULL,NULL,NULL, NULL, NULL}');
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.87..8.89 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: (a = ANY ('{NULL,NULL,NULL,NULL,NULL}'::integer[]))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.87 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: (a = ANY ('{NULL,NULL,NULL,NULL,NULL}'::integer[]))
(4 rows)

deallocate null_array_elements_coverage;
-- (March 9)
--
-- Lots of redundant and contradictory quals involving arrays mixed with
-- simple equality strategy scan keys
-- Simple contradictory
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a = 181;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a = 181;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a = 181))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a = 181))
(4 rows)

-- Simple contradictory, but flip order
select *
from multi_test
where
  a = 181
  and a in (1, 99, 182, 183, 184);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a = 181
  and a in (1, 99, 182, 183, 184);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a = 181))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a = 181))
(4 rows)

-- Simple redundant
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a = 182;
  a  | b 
-----+---
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '182' (redundant qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a = 182;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a = 182))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=14 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a = 182))
         Buffers: shared hit=2
(7 rows)

-- Simple redundant, but flip order
select *
from multi_test
where
  a = 182
  and a in (1, 99, 182, 183, 184);
  a  | b 
-----+---
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '182' (redundant qual)
select *
from multi_test
where
  a = 182
  and a in (1, 99, 182, 183, 184);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a = 182))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=14 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a = 182))
         Buffers: shared hit=2
(7 rows)

---------------------------------
-- '>' operator/strategy tests --
---------------------------------
-- Simple > contradictory
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a > 184;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a > 184;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.32 rows=38 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a > 184))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a > 184))
(4 rows)

-- Simple > contradictory, but flip order
select *
from multi_test
where
  a > 184
  and a in (1, 99, 182, 183, 184);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a > 184
  and a in (1, 99, 182, 183, 184);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.32 rows=38 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a > 184) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=0 loops=1)
         Index Cond: ((a > 184) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
(4 rows)

-- Simple > redundant
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a > 183;
  a  | b 
-----+---
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '184' (redundant qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a > 183;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.32 rows=38 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a > 183))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=14 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a > 183))
         Buffers: shared hit=2
(7 rows)

-- Simple > redundant, but flip order
select *
from multi_test
where
  a > 183
  and a in (1, 99, 182, 183, 184);
  a  | b 
-----+---
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '184' (redundant qual)
select *
from multi_test
where
  a > 183
  and a in (1, 99, 182, 183, 184);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.32 rows=38 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a > 183) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=14 loops=1)
         Index Cond: ((a > 183) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
         Buffers: shared hit=2
(7 rows)

----------------------------------
-- '>=' operator/strategy tests --
----------------------------------
-- Simple >= contradictory
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a >= 185;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a >= 185;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.32 rows=38 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a >= 185))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a >= 185))
(4 rows)

-- Simple >= contradictory, but flip order
select *
from multi_test
where
  a >= 185
  and a in (1, 99, 182, 183, 184);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a >= 185
  and a in (1, 99, 182, 183, 184);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.32 rows=38 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a >= 185) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=0 loops=1)
         Index Cond: ((a >= 185) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
(4 rows)

-- Simple >= redundant
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a >= 184;
  a  | b 
-----+---
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '184' (redundant qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a >= 184;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.32 rows=38 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a >= 184))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=14 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a >= 184))
         Buffers: shared hit=2
(7 rows)

-- Simple >= redundant, but flip order
select *
from multi_test
where
  a >= 184
  and a in (1, 99, 182, 183, 184);
  a  | b 
-----+---
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '184' (redundant qual)
select *
from multi_test
where
  a >= 184
  and a in (1, 99, 182, 183, 184);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.25..31.32 rows=38 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a >= 184) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=14 loops=1)
         Index Cond: ((a >= 184) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
         Buffers: shared hit=2
(7 rows)

---------------------------------
-- '<' operator/strategy tests --
---------------------------------
-- Simple < contradictory
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a < 1;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a < 1;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a < 1))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a < 1))
 Planning:
   Buffers: shared hit=3
(6 rows)

-- Simple < contradictory, but flip order
select *
from multi_test
where
  a < 1
  and a in (1, 99, 182, 183, 184);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a < 1
  and a in (1, 99, 182, 183, 184);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a < 1) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a < 1) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
 Planning:
   Buffers: shared hit=3
(6 rows)

-- Simple < redundant
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a < 2;
 a | b 
---+---
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '1' (redundant qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a < 2;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a < 2))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=14 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a < 2))
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- Simple < redundant, but flip order
select *
from multi_test
where
  a < 2
  and a in (1, 99, 182, 183, 184);
 a | b 
---+---
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '1' (redundant qual)
select *
from multi_test
where
  a < 2
  and a in (1, 99, 182, 183, 184);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a < 2) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=14 loops=1)
         Index Cond: ((a < 2) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

----------------------------------
-- '<=' operator/strategy tests --
----------------------------------
-- Simple <= contradictory
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a <= 0;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a <= 0;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a <= 0))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a <= 0))
 Planning:
   Buffers: shared hit=3
(6 rows)

-- Simple <= contradictory, but flip order
select *
from multi_test
where
  a <= 0
  and a in (1, 99, 182, 183, 184);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a <= 0
  and a in (1, 99, 182, 183, 184);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a <= 0) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a <= 0) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
 Planning:
   Buffers: shared hit=3
(6 rows)

-- Simple <= redundant
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a <= 1;
 a | b 
---+---
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '1' (redundant qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a <= 1;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a <= 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=14 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a <= 1))
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- Simple <= redundant, but flip order
select *
from multi_test
where
  a <= 1
  and a in (1, 99, 182, 183, 184);
 a | b 
---+---
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 0
 1 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- only 2 buffer hits for '1' (redundant qual)
select *
from multi_test
where
  a <= 1
  and a in (1, 99, 182, 183, 184);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=14 loops=1)
   Recheck Cond: ((a <= 1) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=14 loops=1)
         Index Cond: ((a <= 1) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- (March 11) This was a bug that you didn't catch right away when you added
-- code to exclude array entries using another scankey on same att with >
-- strategy (basically an off-by-one thing)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a > 1000;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select *
from multi_test
where
  a in (1, 99, 182, 183, 184)
  and a > 1000;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=6.88..8.90 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a > 1000))
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a > 1000))
 Planning:
   Buffers: shared hit=3
(6 rows)

-- (March 11) This was another bug that you didn't catch right away,
-- discovered shortly after the one exercised by today's previous test case
select *
from multi_test
where
  a in (1, 99, 182, 184)
  and a < 188;
  a  | b 
-----+---
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 0
   1 | 1
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 0
  99 | 1
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 0
 182 | 1
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 1
(56 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from multi_test
where
  a in (1, 99, 182, 184)
  and a < 188;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test  (cost=7.12..28.31 rows=26 width=8) (actual rows=56 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,184}'::integer[])) AND (a < 188))
   Heap Blocks: exact=3
   Buffers: shared hit=10
   ->  Bitmap Index Scan on multi_test_idx  (cost=0.00..7.12 rows=26 width=0) (actual rows=56 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,184}'::integer[])) AND (a < 188))
         Buffers: shared hit=7
(7 rows)

-----------------------------------------------
-- Skip scan parity for backwards scan tests --
-----------------------------------------------
--
-- (Jan 29 2025) Make sure that backwards scan and forward scan full index
-- scans have reasonably (if not exactly) comparable performance
-- characteristics in cases where skip scan is applied but cannot ever really
-- help
--
-- Index-only scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to on;
set enable_indexscan to off;
-- Forward scan:
select *
from multi_test
where b = 1
order by a, b;
  a  | b 
-----+---
   1 | 1
   2 | 1
   3 | 1
   4 | 1
   5 | 1
   6 | 1
   7 | 1
   8 | 1
   9 | 1
  10 | 1
  11 | 1
  12 | 1
  13 | 1
  14 | 1
  15 | 1
  16 | 1
  17 | 1
  18 | 1
  19 | 1
  20 | 1
  21 | 1
  22 | 1
  23 | 1
  24 | 1
  25 | 1
  26 | 1
  27 | 1
  28 | 1
  29 | 1
  30 | 1
  31 | 1
  32 | 1
  33 | 1
  34 | 1
  35 | 1
  36 | 1
  37 | 1
  38 | 1
  39 | 1
  40 | 1
  41 | 1
  42 | 1
  43 | 1
  44 | 1
  45 | 1
  46 | 1
  47 | 1
  48 | 1
  49 | 1
  50 | 1
  51 | 1
  52 | 1
  53 | 1
  54 | 1
  55 | 1
  56 | 1
  57 | 1
  58 | 1
  59 | 1
  60 | 1
  61 | 1
  62 | 1
  63 | 1
  64 | 1
  65 | 1
  66 | 1
  67 | 1
  68 | 1
  69 | 1
  70 | 1
  71 | 1
  72 | 1
  73 | 1
  74 | 1
  75 | 1
  76 | 1
  77 | 1
  78 | 1
  79 | 1
  80 | 1
  81 | 1
  82 | 1
  83 | 1
  84 | 1
  85 | 1
  86 | 1
  87 | 1
  88 | 1
  89 | 1
  90 | 1
  91 | 1
  92 | 1
  93 | 1
  94 | 1
  95 | 1
  96 | 1
  97 | 1
  98 | 1
  99 | 1
 100 | 1
 101 | 1
 102 | 1
 103 | 1
 104 | 1
 105 | 1
 106 | 1
 107 | 1
 108 | 1
 109 | 1
 110 | 1
 111 | 1
 112 | 1
 113 | 1
 114 | 1
 115 | 1
 116 | 1
 117 | 1
 118 | 1
 119 | 1
 120 | 1
 121 | 1
 122 | 1
 123 | 1
 124 | 1
 125 | 1
 126 | 1
 127 | 1
 128 | 1
 129 | 1
 130 | 1
 131 | 1
 132 | 1
 133 | 1
 134 | 1
 135 | 1
 136 | 1
 137 | 1
 138 | 1
 139 | 1
 140 | 1
 141 | 1
 142 | 1
 143 | 1
 144 | 1
 145 | 1
 146 | 1
 147 | 1
 148 | 1
 149 | 1
 150 | 1
 151 | 1
 152 | 1
 153 | 1
 154 | 1
 155 | 1
 156 | 1
 157 | 1
 158 | 1
 159 | 1
 160 | 1
 161 | 1
 162 | 1
 163 | 1
 164 | 1
 165 | 1
 166 | 1
 167 | 1
 168 | 1
 169 | 1
 170 | 1
 171 | 1
 172 | 1
 173 | 1
 174 | 1
 175 | 1
 176 | 1
 177 | 1
 178 | 1
 179 | 1
 180 | 1
 181 | 1
 182 | 1
 183 | 1
 184 | 1
 185 | 1
 186 | 1
 187 | 1
 188 | 1
 189 | 1
 190 | 1
 191 | 1
 192 | 1
 193 | 1
 194 | 1
 195 | 1
 196 | 1
 197 | 1
 198 | 1
 199 | 1
 200 | 1
 201 | 1
 202 | 1
 203 | 1
 204 | 1
 205 | 1
 206 | 1
 207 | 1
 208 | 1
 209 | 1
 210 | 1
 211 | 1
 212 | 1
 213 | 1
 214 | 1
 215 | 1
 216 | 1
 217 | 1
 218 | 1
 219 | 1
 220 | 1
 221 | 1
 222 | 1
 223 | 1
 224 | 1
 225 | 1
 226 | 1
 227 | 1
 228 | 1
 229 | 1
 230 | 1
 231 | 1
 232 | 1
 233 | 1
 234 | 1
 235 | 1
 236 | 1
 237 | 1
 238 | 1
 239 | 1
 240 | 1
 241 | 1
 242 | 1
 243 | 1
 244 | 1
 245 | 1
 246 | 1
 247 | 1
 248 | 1
 249 | 1
 250 | 1
 251 | 1
 252 | 1
 253 | 1
 254 | 1
 255 | 1
 256 | 1
 257 | 1
 258 | 1
 259 | 1
 260 | 1
 261 | 1
 262 | 1
 263 | 1
 264 | 1
 265 | 1
 266 | 1
 267 | 1
 268 | 1
 269 | 1
 270 | 1
 271 | 1
 272 | 1
 273 | 1
 274 | 1
 275 | 1
 276 | 1
 277 | 1
 278 | 1
 279 | 1
 280 | 1
 281 | 1
 282 | 1
 283 | 1
 284 | 1
 285 | 1
 286 | 1
 287 | 1
 288 | 1
 289 | 1
 290 | 1
 291 | 1
 292 | 1
 293 | 1
 294 | 1
 295 | 1
 296 | 1
 297 | 1
 298 | 1
 299 | 1
 300 | 1
 301 | 1
 302 | 1
 303 | 1
 304 | 1
 305 | 1
 306 | 1
 307 | 1
 308 | 1
 309 | 1
 310 | 1
 311 | 1
 312 | 1
 313 | 1
 314 | 1
 315 | 1
 316 | 1
 317 | 1
 318 | 1
 319 | 1
 320 | 1
 321 | 1
 322 | 1
 323 | 1
 324 | 1
 325 | 1
 326 | 1
 327 | 1
 328 | 1
 329 | 1
 330 | 1
 331 | 1
 332 | 1
 333 | 1
 334 | 1
 335 | 1
 336 | 1
 337 | 1
 338 | 1
 339 | 1
 340 | 1
 341 | 1
 342 | 1
 343 | 1
 344 | 1
 345 | 1
 346 | 1
 347 | 1
 348 | 1
 349 | 1
 350 | 1
 351 | 1
 352 | 1
 353 | 1
 354 | 1
 355 | 1
 356 | 1
 357 | 1
 358 | 1
 359 | 1
 360 | 1
 361 | 1
 362 | 1
 363 | 1
 364 | 1
 365 | 1
 366 | 1
 367 | 1
 368 | 1
 369 | 1
 370 | 1
 371 | 1
 372 | 1
 373 | 1
 374 | 1
 375 | 1
 376 | 1
 377 | 1
 378 | 1
 379 | 1
 380 | 1
 381 | 1
 382 | 1
 383 | 1
 384 | 1
 385 | 1
 386 | 1
 387 | 1
 388 | 1
 389 | 1
 390 | 1
 391 | 1
 392 | 1
 393 | 1
 394 | 1
 395 | 1
 396 | 1
 397 | 1
 398 | 1
 399 | 1
 400 | 1
(400 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from multi_test
where b = 1
order by a, b;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..64.28 rows=400 width=8) (actual rows=400 loops=1)
   Disabled: true
   Index Cond: (b = 1)
   Heap Fetches: 0
   Buffers: shared hit=9
(5 rows)

select *
from multi_test
where b < 0
order by a, b;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from multi_test
where b < 0
order by a, b;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_idx on multi_test  (cost=0.28..60.29 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: (b < 0)
   Heap Fetches: 0
   Buffers: shared hit=8
(5 rows)

-- Backward scan, should match forward scan "buffers" (more or less):
select *
from multi_test
where b = 1
order by a desc, b desc;
  a  | b 
-----+---
 400 | 1
 399 | 1
 398 | 1
 397 | 1
 396 | 1
 395 | 1
 394 | 1
 393 | 1
 392 | 1
 391 | 1
 390 | 1
 389 | 1
 388 | 1
 387 | 1
 386 | 1
 385 | 1
 384 | 1
 383 | 1
 382 | 1
 381 | 1
 380 | 1
 379 | 1
 378 | 1
 377 | 1
 376 | 1
 375 | 1
 374 | 1
 373 | 1
 372 | 1
 371 | 1
 370 | 1
 369 | 1
 368 | 1
 367 | 1
 366 | 1
 365 | 1
 364 | 1
 363 | 1
 362 | 1
 361 | 1
 360 | 1
 359 | 1
 358 | 1
 357 | 1
 356 | 1
 355 | 1
 354 | 1
 353 | 1
 352 | 1
 351 | 1
 350 | 1
 349 | 1
 348 | 1
 347 | 1
 346 | 1
 345 | 1
 344 | 1
 343 | 1
 342 | 1
 341 | 1
 340 | 1
 339 | 1
 338 | 1
 337 | 1
 336 | 1
 335 | 1
 334 | 1
 333 | 1
 332 | 1
 331 | 1
 330 | 1
 329 | 1
 328 | 1
 327 | 1
 326 | 1
 325 | 1
 324 | 1
 323 | 1
 322 | 1
 321 | 1
 320 | 1
 319 | 1
 318 | 1
 317 | 1
 316 | 1
 315 | 1
 314 | 1
 313 | 1
 312 | 1
 311 | 1
 310 | 1
 309 | 1
 308 | 1
 307 | 1
 306 | 1
 305 | 1
 304 | 1
 303 | 1
 302 | 1
 301 | 1
 300 | 1
 299 | 1
 298 | 1
 297 | 1
 296 | 1
 295 | 1
 294 | 1
 293 | 1
 292 | 1
 291 | 1
 290 | 1
 289 | 1
 288 | 1
 287 | 1
 286 | 1
 285 | 1
 284 | 1
 283 | 1
 282 | 1
 281 | 1
 280 | 1
 279 | 1
 278 | 1
 277 | 1
 276 | 1
 275 | 1
 274 | 1
 273 | 1
 272 | 1
 271 | 1
 270 | 1
 269 | 1
 268 | 1
 267 | 1
 266 | 1
 265 | 1
 264 | 1
 263 | 1
 262 | 1
 261 | 1
 260 | 1
 259 | 1
 258 | 1
 257 | 1
 256 | 1
 255 | 1
 254 | 1
 253 | 1
 252 | 1
 251 | 1
 250 | 1
 249 | 1
 248 | 1
 247 | 1
 246 | 1
 245 | 1
 244 | 1
 243 | 1
 242 | 1
 241 | 1
 240 | 1
 239 | 1
 238 | 1
 237 | 1
 236 | 1
 235 | 1
 234 | 1
 233 | 1
 232 | 1
 231 | 1
 230 | 1
 229 | 1
 228 | 1
 227 | 1
 226 | 1
 225 | 1
 224 | 1
 223 | 1
 222 | 1
 221 | 1
 220 | 1
 219 | 1
 218 | 1
 217 | 1
 216 | 1
 215 | 1
 214 | 1
 213 | 1
 212 | 1
 211 | 1
 210 | 1
 209 | 1
 208 | 1
 207 | 1
 206 | 1
 205 | 1
 204 | 1
 203 | 1
 202 | 1
 201 | 1
 200 | 1
 199 | 1
 198 | 1
 197 | 1
 196 | 1
 195 | 1
 194 | 1
 193 | 1
 192 | 1
 191 | 1
 190 | 1
 189 | 1
 188 | 1
 187 | 1
 186 | 1
 185 | 1
 184 | 1
 183 | 1
 182 | 1
 181 | 1
 180 | 1
 179 | 1
 178 | 1
 177 | 1
 176 | 1
 175 | 1
 174 | 1
 173 | 1
 172 | 1
 171 | 1
 170 | 1
 169 | 1
 168 | 1
 167 | 1
 166 | 1
 165 | 1
 164 | 1
 163 | 1
 162 | 1
 161 | 1
 160 | 1
 159 | 1
 158 | 1
 157 | 1
 156 | 1
 155 | 1
 154 | 1
 153 | 1
 152 | 1
 151 | 1
 150 | 1
 149 | 1
 148 | 1
 147 | 1
 146 | 1
 145 | 1
 144 | 1
 143 | 1
 142 | 1
 141 | 1
 140 | 1
 139 | 1
 138 | 1
 137 | 1
 136 | 1
 135 | 1
 134 | 1
 133 | 1
 132 | 1
 131 | 1
 130 | 1
 129 | 1
 128 | 1
 127 | 1
 126 | 1
 125 | 1
 124 | 1
 123 | 1
 122 | 1
 121 | 1
 120 | 1
 119 | 1
 118 | 1
 117 | 1
 116 | 1
 115 | 1
 114 | 1
 113 | 1
 112 | 1
 111 | 1
 110 | 1
 109 | 1
 108 | 1
 107 | 1
 106 | 1
 105 | 1
 104 | 1
 103 | 1
 102 | 1
 101 | 1
 100 | 1
  99 | 1
  98 | 1
  97 | 1
  96 | 1
  95 | 1
  94 | 1
  93 | 1
  92 | 1
  91 | 1
  90 | 1
  89 | 1
  88 | 1
  87 | 1
  86 | 1
  85 | 1
  84 | 1
  83 | 1
  82 | 1
  81 | 1
  80 | 1
  79 | 1
  78 | 1
  77 | 1
  76 | 1
  75 | 1
  74 | 1
  73 | 1
  72 | 1
  71 | 1
  70 | 1
  69 | 1
  68 | 1
  67 | 1
  66 | 1
  65 | 1
  64 | 1
  63 | 1
  62 | 1
  61 | 1
  60 | 1
  59 | 1
  58 | 1
  57 | 1
  56 | 1
  55 | 1
  54 | 1
  53 | 1
  52 | 1
  51 | 1
  50 | 1
  49 | 1
  48 | 1
  47 | 1
  46 | 1
  45 | 1
  44 | 1
  43 | 1
  42 | 1
  41 | 1
  40 | 1
  39 | 1
  38 | 1
  37 | 1
  36 | 1
  35 | 1
  34 | 1
  33 | 1
  32 | 1
  31 | 1
  30 | 1
  29 | 1
  28 | 1
  27 | 1
  26 | 1
  25 | 1
  24 | 1
  23 | 1
  22 | 1
  21 | 1
  20 | 1
  19 | 1
  18 | 1
  17 | 1
  16 | 1
  15 | 1
  14 | 1
  13 | 1
  12 | 1
  11 | 1
  10 | 1
   9 | 1
   8 | 1
   7 | 1
   6 | 1
   5 | 1
   4 | 1
   3 | 1
   2 | 1
   1 | 1
(400 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from multi_test
where b = 1
order by a desc, b desc;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using multi_test_idx on multi_test  (cost=0.28..64.28 rows=400 width=8) (actual rows=400 loops=1)
   Disabled: true
   Index Cond: (b = 1)
   Heap Fetches: 0
   Buffers: shared hit=9
(5 rows)

select *
from multi_test
where b < 0
order by a desc, b desc;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from multi_test
where b < 0
order by a desc, b desc;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using multi_test_idx on multi_test  (cost=0.28..60.29 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: (b < 0)
   Heap Fetches: 0
   Buffers: shared hit=8
(5 rows)

-------------------------------------------------------------------------------
-- tenk1 test cases involving queries where the optimization is inapplicable --
-------------------------------------------------------------------------------
set client_min_messages=error;
drop table if exists tenk1_dyn_saop;
reset client_min_messages;
\getenv abs_srcdir PG_ABS_SRCDIR
CREATE UNLOGGED TABLE tenk1_dyn_saop (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
ALTER TABLE tenk1_dyn_saop SET (autovacuum_enabled=off);
\set filename :abs_srcdir '/data/tenk.data'
COPY tenk1_dyn_saop FROM :'filename';
CREATE INDEX tenk1_dyn_saop_thous_tenthous ON tenk1_dyn_saop (thousand, tenthous);
VACUUM ANALYZE tenk1_dyn_saop;
-------------------------------------------------------------------------------
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
prepare regress_tenk1_inequality as
SELECT thousand, tenthous FROM tenk1_dyn_saop
 WHERE thousand < 2 AND tenthous IN (1001,3000)
 ORDER BY thousand;
execute regress_tenk1_inequality;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute regress_tenk1_inequality;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=4.52..4.53 rows=1 width=8) (actual rows=2 loops=1)
   Sort Key: thousand
   Sort Method: quicksort  Memory: 25kB
   Buffers: shared hit=4
   ->  Bitmap Heap Scan on tenk1_dyn_saop  (cost=2.50..4.51 rows=1 width=8) (actual rows=2 loops=1)
         Recheck Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
         Heap Blocks: exact=2
         Buffers: shared hit=4
         ->  Bitmap Index Scan on tenk1_dyn_saop_thous_tenthous  (cost=0.00..2.50 rows=1 width=0) (actual rows=2 loops=1)
               Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
               Buffers: shared hit=2
(11 rows)

deallocate regress_tenk1_inequality;
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
prepare regress_tenk1_inequality as
SELECT thousand, tenthous FROM tenk1_dyn_saop
 WHERE thousand < 2 AND tenthous IN (1001,3000)
 ORDER BY thousand;
execute regress_tenk1_inequality;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute regress_tenk1_inequality;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Index Scan using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=0.29..4.50 rows=1 width=8) (actual rows=2 loops=1)
   Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
   Buffers: shared hit=4
(3 rows)

deallocate regress_tenk1_inequality;
-- Index-only scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to on;
set enable_indexscan to off;
prepare regress_tenk1_inequality as
SELECT thousand, tenthous FROM tenk1_dyn_saop
 WHERE thousand < 2 AND tenthous IN (1001,3000)
 ORDER BY thousand;
execute regress_tenk1_inequality;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute regress_tenk1_inequality;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=0.29..2.50 rows=1 width=8) (actual rows=2 loops=1)
   Disabled: true
   Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

deallocate regress_tenk1_inequality;
-- Now my own backwards scan variant, index-only scan:
prepare regress_tenk1_inequality_backwards as
SELECT thousand, tenthous FROM tenk1_dyn_saop
 WHERE thousand < 2 AND tenthous IN (1001,3000)
 ORDER BY thousand desc, tenthous desc;
execute regress_tenk1_inequality_backwards;
 thousand | tenthous 
----------+----------
        1 |     1001
        0 |     3000
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute regress_tenk1_inequality_backwards;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=0.29..2.50 rows=1 width=8) (actual rows=2 loops=1)
   Disabled: true
   Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

deallocate regress_tenk1_inequality_backwards;
------------------------------------------------------
-- Confusion about wraparound for high order column --
------------------------------------------------------
-- (September 13) This test case demonstrates the need to wraparound the
-- most significant column (which is "thousand" here) so that the scan will
-- terminate on the leftmost leaf page, without needlessly accessing further
-- leaf pages to the right.
--
-- This is surprisingly subtle, and seems like it's the only test case that'll
-- catch this.  Note that what I describe is independent of the issue covered
-- by the next test case (nonarray_equality_strategy_orderproc_required_both_stages)
-- which was all about not doing the required comparisons in both functions.
-- This is about __not__ resetting cur_elem to zero for the "thousand" array once
-- the scan gets past the last "thousand = 1" tuple.
--
-- (October 28) We want to not only get the expected number of buffer hits; we
-- also want to terminate the scan within even incrementally advancing the
-- array keys.  More concretely, it should look like this (and does, at the
-- time of writing):
--
-- (November 10): See also, must_wraparound_high_order_column_equality_nomatch
--
-- _bt_advance_array_keys, tuple: (thousand, tenthous)=(2, 2), 0x7ff88b087ea0   <-- first (2, *) tuple
--   numberOfKeys: 2
--  - sk_attno: 1, cur_elem 1/1, val: 1 [NULLS LAST, ASC]
--  - sk_attno: 2, cur_elem 9001/20500, val: 9001 [NULLS LAST, ASC]
--  + sk_attno: 1, cur_elem 1/1, val: 1 [NULLS LAST, ASC]              <--- No changes here
--  + sk_attno: 2, cur_elem 9001/20500, val: 9001 [NULLS LAST, ASC]    <--- Nor here
--  _bt_advance_array_keys: returns false
-- _bt_readpage final: (thousand, tenthous)=(2, 2), 0x7ff88b087ea0, from non-pivot offnum 22 TID (93,20) ended page and scan
-- _bt_readpage stats: currPos.firstItem: 0, currPos.lastItem: 19, nmatching: 20 ✅
-- _bt_first: returning offnum 2 TID (344,23)
-- _bt_readnextpage: ScanDirectionIsForward() case ran out of pages to the right
-- _bt_readnextpage: BTScanPosInvalidate() called for currPos
-- _bt_steppage: _bt_readnextpage() returns false so we do too
-- btendscan
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
prepare must_wraparound_high_order_column as
with a as (
  select i from generate_series(0, 10500) i
)
select thousand, tenthous
from
  tenk1_dyn_saop
where thousand in (0, 1) and
tenthous = any (array[(select array_agg(i) from a)]);
execute must_wraparound_high_order_column;
 thousand | tenthous 
----------+----------
        0 |     8000
        1 |     3001
        1 |     2001
        1 |     8001
        1 |     1001
        1 |     6001
        1 |        1
        0 |     5000
        0 |     9000
        0 |     6000
        1 |     5001
        1 |     9001
        0 |     2000
        1 |     7001
        0 |     1000
        0 |     4000
        1 |     4001
        0 |     3000
        0 |     7000
        0 |        0
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute must_wraparound_high_order_column;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1_dyn_saop  (cost=152.23..154.25 rows=1 width=8) (actual rows=20 loops=1)
   Recheck Cond: ((thousand = ANY ('{0,1}'::integer[])) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Heap Blocks: exact=20
   Buffers: shared hit=22
   InitPlan 1
     ->  Aggregate  (cost=131.27..131.28 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..105.01 rows=10501 width=4) (actual rows=10501 loops=1)
   ->  Bitmap Index Scan on tenk1_dyn_saop_thous_tenthous  (cost=0.00..20.95 rows=1 width=0) (actual rows=20 loops=1)
         Index Cond: ((thousand = ANY ('{0,1}'::integer[])) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
         Buffers: shared hit=2
(10 rows)

deallocate must_wraparound_high_order_column;
-- Same again, but backwards scan for good luck
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
prepare must_wraparound_high_order_column_desc as
with a as (
  select i from generate_series(0, 10500) i
)
select thousand, tenthous
from
  tenk1_dyn_saop
where thousand in (0, 1) and
tenthous = any (array[(select array_agg(i) from a)])
order by thousand desc, tenthous desc;
execute must_wraparound_high_order_column_desc;
 thousand | tenthous 
----------+----------
        1 |     9001
        1 |     8001
        1 |     7001
        1 |     6001
        1 |     5001
        1 |     4001
        1 |     3001
        1 |     2001
        1 |     1001
        1 |        1
        0 |     9000
        0 |     8000
        0 |     7000
        0 |     6000
        0 |     5000
        0 |     4000
        0 |     3000
        0 |     2000
        0 |     1000
        0 |        0
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute must_wraparound_high_order_column_desc;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=131.56..154.24 rows=1 width=8) (actual rows=20 loops=1)
   Index Cond: ((thousand = ANY ('{0,1}'::integer[])) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Buffers: shared hit=22
   InitPlan 1
     ->  Aggregate  (cost=131.27..131.28 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..105.01 rows=10501 width=4) (actual rows=10501 loops=1)
(6 rows)

deallocate must_wraparound_high_order_column_desc;
-- (September 12) This test case decisively proves that we need to use
-- non-array required BTEqualStrategyNumber scan keys, both in the
-- precheck-current-keys function, and the function that actually advances the
-- array keys using tuple values.
--
-- For a while the test would fail (we'd do useless extra leaf page visits)
-- because I lacked the required infrastructure in at least one of these two
-- functions.  This had surprisingly little (no?) coverage before then.  This
-- test case makes it really obvious.
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
prepare nonarray_equality_strategy_orderproc_required_both_stages as
with a as (
  select i from generate_series(-1, 10000) i
)
select
  thousand,
  tenthous
from
  tenk1_dyn_saop
where thousand = 1 and tenthous = any (array[(select array_agg(i) from a)]);
execute nonarray_equality_strategy_orderproc_required_both_stages;
 thousand | tenthous 
----------+----------
        1 |     3001
        1 |     2001
        1 |     8001
        1 |     1001
        1 |     6001
        1 |        1
        1 |     5001
        1 |     9001
        1 |     7001
        1 |     4001
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute nonarray_equality_strategy_orderproc_required_both_stages;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1_dyn_saop  (cost=145.99..148.02 rows=1 width=8) (actual rows=10 loops=1)
   Recheck Cond: ((thousand = 1) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Heap Blocks: exact=10
   Buffers: shared hit=12
   InitPlan 1
     ->  Aggregate  (cost=125.03..125.04 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..100.02 rows=10002 width=4) (actual rows=10002 loops=1)
   ->  Bitmap Index Scan on tenk1_dyn_saop_thous_tenthous  (cost=0.00..20.95 rows=1 width=0) (actual rows=10 loops=1)
         Index Cond: ((thousand = 1) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
         Buffers: shared hit=2
(10 rows)

deallocate nonarray_equality_strategy_orderproc_required_both_stages;
-- (June 8 2024) Skip scan equivalent of last test case:
prepare skip_nonarray_equality_strategy as
with a as (
  select i from generate_series(-1, 10000) i
)
select
  thousand,
  tenthous
from
  tenk1_dyn_saop
where thousand <= 1 and tenthous = any (array[(select array_agg(i) from a)]);
execute skip_nonarray_equality_strategy;
 thousand | tenthous 
----------+----------
        0 |     8000
        1 |     3001
        1 |     2001
        1 |     8001
        1 |     1001
        1 |     6001
        1 |        1
        0 |     5000
        0 |     9000
        0 |     6000
        1 |     5001
        1 |     9001
        0 |     2000
        1 |     7001
        0 |     1000
        0 |     4000
        1 |     4001
        0 |     3000
        0 |     7000
        0 |        0
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute skip_nonarray_equality_strategy;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1_dyn_saop  (cost=127.64..129.66 rows=1 width=8) (actual rows=20 loops=1)
   Recheck Cond: ((thousand <= 1) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Heap Blocks: exact=20
   Buffers: shared hit=22
   InitPlan 1
     ->  Aggregate  (cost=125.03..125.04 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..100.02 rows=10002 width=4) (actual rows=10002 loops=1)
   ->  Bitmap Index Scan on tenk1_dyn_saop_thous_tenthous  (cost=0.00..2.60 rows=1 width=0) (actual rows=20 loops=1)
         Index Cond: ((thousand <= 1) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
         Buffers: shared hit=2
(10 rows)

deallocate skip_nonarray_equality_strategy;
-- Same again, but this time use a plain index scan for good luck:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
prepare nonarray_equality_strategy_orderproc_required_both_stages as
with a as (
  select i from generate_series(-1, 10000) i
)
select
  thousand,
  tenthous
from
  tenk1_dyn_saop
where thousand = 1 and tenthous = any (array[(select array_agg(i) from a)]);
execute nonarray_equality_strategy_orderproc_required_both_stages;
 thousand | tenthous 
----------+----------
        1 |        1
        1 |     1001
        1 |     2001
        1 |     3001
        1 |     4001
        1 |     5001
        1 |     6001
        1 |     7001
        1 |     8001
        1 |     9001
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute nonarray_equality_strategy_orderproc_required_both_stages;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Index Scan using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=125.32..148.00 rows=1 width=8) (actual rows=10 loops=1)
   Index Cond: ((thousand = 1) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Buffers: shared hit=12
   InitPlan 1
     ->  Aggregate  (cost=125.03..125.04 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..100.02 rows=10002 width=4) (actual rows=10002 loops=1)
(6 rows)

deallocate nonarray_equality_strategy_orderproc_required_both_stages;
-- Same again, but this time use a backwards scan for good luck:
prepare nonarray_equality_strategy_orderproc_required_both_stages_desc as
with a as (
  select i from generate_series(-1, 10000) i
)
select
  thousand,
  tenthous
from
  tenk1_dyn_saop
where thousand = 1 and tenthous = any (array[(select array_agg(i) from a)])
order by thousand desc, tenthous desc;
execute nonarray_equality_strategy_orderproc_required_both_stages_desc;
 thousand | tenthous 
----------+----------
        1 |     9001
        1 |     8001
        1 |     7001
        1 |     6001
        1 |     5001
        1 |     4001
        1 |     3001
        1 |     2001
        1 |     1001
        1 |        1
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute nonarray_equality_strategy_orderproc_required_both_stages_desc;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=125.32..148.00 rows=1 width=8) (actual rows=10 loops=1)
   Index Cond: ((thousand = 1) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Buffers: shared hit=12
   InitPlan 1
     ->  Aggregate  (cost=125.03..125.04 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..100.02 rows=10002 width=4) (actual rows=10002 loops=1)
(6 rows)

-- (June 8 2024) Skip scan equivalent of last test case:
prepare skip_nonarray_equality_strategy_orderproc_desc as
with a as (
  select i from generate_series(-1, 10000) i
)
select
  thousand,
  tenthous
from
  tenk1_dyn_saop
where thousand <= 1 and tenthous = any (array[(select array_agg(i) from a)])
order by thousand desc, tenthous desc;
execute skip_nonarray_equality_strategy_orderproc_desc;
 thousand | tenthous 
----------+----------
        1 |     9001
        1 |     8001
        1 |     7001
        1 |     6001
        1 |     5001
        1 |     4001
        1 |     3001
        1 |     2001
        1 |     1001
        1 |        1
        0 |     9000
        0 |     8000
        0 |     7000
        0 |     6000
        0 |     5000
        0 |     4000
        0 |     3000
        0 |     2000
        0 |     1000
        0 |        0
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute skip_nonarray_equality_strategy_orderproc_desc;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=125.32..129.64 rows=1 width=8) (actual rows=20 loops=1)
   Index Cond: ((thousand <= 1) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Buffers: shared hit=22
   InitPlan 1
     ->  Aggregate  (cost=125.03..125.04 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..100.02 rows=10002 width=4) (actual rows=10002 loops=1)
(6 rows)

-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- (September 19) But what about inequalities?
-- This is almost the same query as the last one, except we use < as a
-- replacement for =.  We should get the same number of buffer hits.
prepare nonarray_inequality as
with a as (
  select i from generate_series(-1, 10000) i
)
select
  thousand,
  tenthous
from
  tenk1_dyn_saop
where thousand < 2 and tenthous = any (array[(select array_agg(i) from a)]);
execute nonarray_inequality;
 thousand | tenthous 
----------+----------
        0 |     8000
        1 |     3001
        1 |     2001
        1 |     8001
        1 |     1001
        1 |     6001
        1 |        1
        0 |     5000
        0 |     9000
        0 |     6000
        1 |     5001
        1 |     9001
        0 |     2000
        1 |     7001
        0 |     1000
        0 |     4000
        1 |     4001
        0 |     3000
        0 |     7000
        0 |        0
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 buffer hits, just like original = query
execute nonarray_inequality;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1_dyn_saop  (cost=127.54..129.56 rows=1 width=8) (actual rows=20 loops=1)
   Recheck Cond: ((thousand < 2) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Heap Blocks: exact=20
   Buffers: shared hit=22
   InitPlan 1
     ->  Aggregate  (cost=125.03..125.04 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..100.02 rows=10002 width=4) (actual rows=10002 loops=1)
   ->  Bitmap Index Scan on tenk1_dyn_saop_thous_tenthous  (cost=0.00..2.50 rows=1 width=0) (actual rows=20 loops=1)
         Index Cond: ((thousand < 2) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
         Buffers: shared hit=2
(10 rows)

deallocate nonarray_inequality;
-- Same again, but this time a backwards scan for good luck:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
prepare nonarray_inequality_desc as
with a as (
  select i from generate_series(-1, 10000) i
)
select
  thousand,
  tenthous
from
  tenk1_dyn_saop
where thousand < 2 and tenthous = any (array[(select array_agg(i) from a)])
order by thousand desc, tenthous desc;
execute nonarray_inequality_desc;
 thousand | tenthous 
----------+----------
        1 |     9001
        1 |     8001
        1 |     7001
        1 |     6001
        1 |     5001
        1 |     4001
        1 |     3001
        1 |     2001
        1 |     1001
        1 |        1
        0 |     9000
        0 |     8000
        0 |     7000
        0 |     6000
        0 |     5000
        0 |     4000
        0 |     3000
        0 |     2000
        0 |     1000
        0 |        0
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 buffer hits, just like original = query
execute nonarray_inequality_desc;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=125.32..129.54 rows=1 width=8) (actual rows=20 loops=1)
   Index Cond: ((thousand < 2) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Buffers: shared hit=22
   InitPlan 1
     ->  Aggregate  (cost=125.03..125.04 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..100.02 rows=10002 width=4) (actual rows=10002 loops=1)
(6 rows)

deallocate nonarray_inequality_desc;
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- (November 10) This is like must_wraparound_high_order_column, except that
-- it has a new stressor for the implementation: the tenthous values the we'll
-- attempt to match are non-matches -- they're all too high to get any
-- matches.
prepare must_wraparound_high_order_column_equality_nomatch as
with a as (
  select i from generate_series(10000, 10500) i
)
select
  thousand,
  tenthous
from tenk1_dyn_saop
where thousand in (0, 1) and tenthous = any (array[(select array_agg(i) from a)]);
execute must_wraparound_high_order_column_equality_nomatch;
 thousand | tenthous 
----------+----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute must_wraparound_high_order_column_equality_nomatch;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1_dyn_saop  (cost=27.23..29.25 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((thousand = ANY ('{0,1}'::integer[])) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Buffers: shared hit=2
   InitPlan 1
     ->  Aggregate  (cost=6.27..6.28 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..5.01 rows=501 width=4) (actual rows=501 loops=1)
   ->  Bitmap Index Scan on tenk1_dyn_saop_thous_tenthous  (cost=0.00..20.95 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((thousand = ANY ('{0,1}'::integer[])) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
         Buffers: shared hit=2
(9 rows)

deallocate must_wraparound_high_order_column_equality_nomatch;
-- (November 10) This is like
-- must_wraparound_high_order_column_equality_nomatch, except that it uses an
-- inequality that's "equivalent" to its first array -- which renders the
-- second array on tenthous non-required.  We expect identical access patterns
-- for both test cases (at least at the level of whole pages scanned).
--
-- This caused the postcondition assertion within _bt_advance_array_keys to
-- fail thusly:
--
-- TRAP: failed Assert("_bt_tuple_before_array_skeys(scan, pstate, tuple) == (!all_required_eqtype_sk_equal && !arrays_exhausted)")
--
-- At the time of writing, the "fallback on incremental advancement" path has
-- a design that doesn't properly account for non-required arrays.
prepare must_wraparound_high_order_column_inequality_nomatch as
with a as (
  select i from generate_series(10000, 10500) i
)
select
  thousand,
  tenthous
from tenk1_dyn_saop
where thousand < 2 and tenthous = any (array[( select array_agg(i) from a)]);
execute must_wraparound_high_order_column_inequality_nomatch;
 thousand | tenthous 
----------+----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute must_wraparound_high_order_column_inequality_nomatch;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1_dyn_saop  (cost=8.77..10.80 rows=1 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((thousand < 2) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
   Buffers: shared hit=2
   InitPlan 1
     ->  Aggregate  (cost=6.27..6.28 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..5.01 rows=501 width=4) (actual rows=501 loops=1)
   ->  Bitmap Index Scan on tenk1_dyn_saop_thous_tenthous  (cost=0.00..2.50 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((thousand < 2) AND (tenthous = ANY (ARRAY[(InitPlan 1).col1])))
         Buffers: shared hit=2
(9 rows)

deallocate must_wraparound_high_order_column_inequality_nomatch;
-- Microbenchmarks
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Low cardinality
CREATE INDEX tenk1_dyn_saop_idx_lowcard ON tenk1_dyn_saop (two, four, twenty, hundred);
-- Limit 10:
select ctid, * from tenk1_dyn_saop
where
  two in (0, 1)
  and four in (0, 1, 2)
  and twenty in (0, 1, 3)
  and hundred in (0, 1, 5)
order by
  two,
  four,
  twenty,
  hundred
limit 10;
  ctid   | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
 (0,1)   |    8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
 (9,14)  |    8600 |     274 |   0 |    0 |   0 |      0 |       0 |      600 |         600 |      3600 |     8600 |   0 |    1 | USAAAA   | OKAAAA   | OOOOxx
 (12,14) |     600 |     361 |   0 |    0 |   0 |      0 |       0 |      600 |         600 |       600 |      600 |   0 |    1 | CXAAAA   | XNAAAA   | HHHHxx
 (12,17) |    6300 |     364 |   0 |    0 |   0 |      0 |       0 |      300 |         300 |      1300 |     6300 |   0 |    1 | IIAAAA   | AOAAAA   | AAAAxx
 (13,11) |    7800 |     387 |   0 |    0 |   0 |      0 |       0 |      800 |        1800 |      2800 |     7800 |   0 |    1 | AOAAAA   | XOAAAA   | VVVVxx
 (14,16) |    8000 |     421 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |      3000 |     8000 |   0 |    1 | SVAAAA   | FQAAAA   | HHHHxx
 (25,23) |    8400 |     747 |   0 |    0 |   0 |      0 |       0 |      400 |         400 |      3400 |     8400 |   0 |    1 | CLAAAA   | TCBAAA   | VVVVxx
 (27,6)  |    5500 |     788 |   0 |    0 |   0 |      0 |       0 |      500 |        1500 |       500 |     5500 |   0 |    1 | ODAAAA   | IEBAAA   | AAAAxx
 (31,20) |    6400 |     918 |   0 |    0 |   0 |      0 |       0 |      400 |         400 |      1400 |     6400 |   0 |    1 | EMAAAA   | IJBAAA   | OOOOxx
 (35,28) |    7200 |    1042 |   0 |    0 |   0 |      0 |       0 |      200 |        1200 |      2200 |     7200 |   0 |    1 | YQAAAA   | COBAAA   | OOOOxx
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from tenk1_dyn_saop
where
  two in (0, 1)
  and four in (0, 1, 2)
  and twenty in (0, 1, 3)
  and hundred in (0, 1, 5)
order by
  two,
  four,
  twenty,
  hundred
limit 10;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..19.85 rows=10 width=250) (actual rows=10 loops=1)
   Buffers: shared hit=11
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..66.81 rows=34 width=250) (actual rows=10 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four = ANY ('{0,1,2}'::integer[])) AND (twenty = ANY ('{0,1,3}'::integer[])) AND (hundred = ANY ('{0,1,5}'::integer[])))
         Buffers: shared hit=11
(5 rows)

---------------------------------
-- non-SK_BT_REQFWD test cases --
---------------------------------
-- Index-only scan:
VACUUM (freeze,analyze) tenk1_dyn_saop;
set enable_indexonlyscan to on;
-- Four is omitted here:
prepare four_omitted as
select
  count(*),
  two,
  twenty
from
  tenk1_dyn_saop
where
  two = 0
  and twenty in (9, 10)
group by
  two,
  twenty;
execute four_omitted;
 count | two | twenty 
-------+-----+--------
   500 |   0 |     10
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute four_omitted;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=69.78..69.98 rows=20 width=16) (actual rows=1 loops=1)
   Group Key: twenty
   Batches: 1  Memory Usage: 24kB
   Buffers: shared hit=7
   ->  Index Only Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..67.28 rows=500 width=8) (actual rows=500 loops=1)
         Index Cond: ((two = 0) AND (twenty = ANY ('{9,10}'::integer[])))
         Heap Fetches: 0
         Buffers: shared hit=7
(8 rows)

deallocate four_omitted;
-- tenk1_idx_extra_column_in_middle puzzle #1
--
-- Tests non-SK_BT_REQFWD array scan keys.  There is a "gap" in the columns
-- represented here.
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
create index tenk1_idx_extra_column_in_middle on tenk1_dyn_saop(two,four,twenty);
select
  count(*)
from
  tenk1_dyn_saop
where
  two in (0, 1) -- i.e., every possible "two" value
  and twenty in (0, 1);
 count 
-------
  1000
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  count(*)
from
  tenk1_dyn_saop
where
  two in (0, 1) -- i.e., every possible "two" value
  and twenty in (0, 1);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=724.06..724.07 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=546
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..721.56 rows=1000 width=0) (actual rows=1000 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (twenty = ANY ('{0,1}'::integer[])))
         Buffers: shared hit=546
(5 rows)

-- tenk1_idx_extra_column_in_middle puzzle #1.1
--
-- "four is not null" isn't like "four is null" in that it renders lower order
-- columns non-SK_BT_REQFWD.
select
  count(*)
from
  tenk1_dyn_saop
where
  two in (0, 1) -- i.e., every possible "two" value
  and four is not null -- no value in "four" is ever a NULL
  and twenty in (0, 1);
 count 
-------
  1000
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  count(*)
from
  tenk1_dyn_saop
where
  two in (0, 1) -- i.e., every possible "two" value
  and four is not null -- no value in "four" is ever a NULL
  and twenty in (0, 1);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=749.06..749.07 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=546
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..746.56 rows=1000 width=0) (actual rows=1000 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four IS NOT NULL) AND (twenty = ANY ('{0,1}'::integer[])))
         Buffers: shared hit=546
(5 rows)

-- tenk1_idx_extra_column_in_middle puzzle #1.2
--
-- What's at issue here is whether or not ">= any (array[1, 2])" should count as
-- an equality constraint
--
-- ">= any (array[1, 2])" is an SAOP that it executed by getting an extreme
-- element once, during preprocessing.  This mustn't be confused for the SAOPs
-- we care about.  It also renders lower order columns non-SK_BT_REQFWD, which
-- we must look out for for the usual reasons.
select
  count(*)
from
  tenk1_dyn_saop
where
  two in (0, 1) -- i.e., every possible "two" value
  and four >= any (array[1, 2]) -- ScalarArrayOpExr inequality
  and twenty in (0, 1);
 count 
-------
   500
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  count(*)
from
  tenk1_dyn_saop
where
  two in (0, 1) -- i.e., every possible "two" value
  and four >= any (array[1, 2]) -- ScalarArrayOpExr inequality
  and twenty in (0, 1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=731.89..731.90 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=271
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..729.70 rows=875 width=0) (actual rows=500 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four >= ANY ('{1,2}'::integer[])) AND (twenty = ANY ('{0,1}'::integer[])))
         Buffers: shared hit=271
(5 rows)

-- tenk1_idx_extra_column_in_middle puzzle #2
--
-- (August 29) This variant of puzzle #1 was interesting back in July.  I'm
-- keeping it now out of paranoia.
select
  count(*)
from
  tenk1_dyn_saop
where
  two in (0, 1) -- i.e., every possible "two" value
  and twenty in (0, 1, 2);
 count 
-------
  1500
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  count(*)
from
  tenk1_dyn_saop
where
  two in (0, 1) -- i.e., every possible "two" value
  and twenty in (0, 1, 2);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=732.78..732.79 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=815
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..729.03 rows=1500 width=0) (actual rows=1500 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (twenty = ANY ('{0,1,2}'::integer[])))
         Buffers: shared hit=815
(5 rows)

-- tenk1_idx_extra_column_in_middle puzzle #3
--
-- (August 29) This variant of puzzle #1 was interesting back in July.  I'm
-- keeping it now out of paranoia.
create index tenk1_dyn_saop_idx_many_columns on tenk1_dyn_saop (two,four,twenty,unique1,hundred);
select ctid, *
from
  tenk1_dyn_saop
where
  two in (3, 5)
  and twenty in (0, 1, 3)
  and hundred in (0, 1, 5)
order by
  two,
  four,
  twenty
limit 15;
 ctid | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
------+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 buffer accesses (4 on master)
select ctid, *
from
  tenk1_dyn_saop
where
  two in (3, 5)
  and twenty in (0, 1, 3)
  and hundred in (0, 1, 5)
order by
  two,
  four,
  twenty
limit 15;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..6.31 rows=1 width=250) (actual rows=0 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..6.31 rows=1 width=250) (actual rows=0 loops=1)
         Index Cond: ((two = ANY ('{3,5}'::integer[])) AND (twenty = ANY ('{0,1,3}'::integer[])))
         Filter: (hundred = ANY ('{0,1,5}'::integer[]))
         Buffers: shared hit=2
(6 rows)

-- RhodiumToad test query from https://www.postgresql.org/message-id/flat/87egxzbn01.fsf%40news-spur.riddles.org.uk
--
-- RhodiumToad test #1
--
-- First let's see how it does with the existing tenk1_dyn_saop_thous_tenthous
-- index.
--
-- Patch doesn't do all that much better than master here (126 buffer hits vs
-- 144), and yet if you give the master branch a choice between
-- tenk1_dyn_saop_thous_tenthous and the rhodium_toad index, it'll prefer to
-- use the latter one -- which actually works out to be about 3x more
-- expensive, buffer-hits-wise.
select * from tenk1_dyn_saop
where
  thousand in (19, 29, 39, 49, 57, 66, 77, 8, 90, 12, 22, 32)
  and (ten >= 5) and (ten > 5 or unique1 > 5000)
order by ten, unique1 limit 1;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
      66 |    6723 |   0 |    2 |   6 |      6 |      66 |       66 |          66 |        66 |       66 | 132 |  133 | OCAAAA   | PYJAAA   | VVVVxx
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from tenk1_dyn_saop
where
  thousand in (19, 29, 39, 49, 57, 66, 77, 8, 90, 12, 22, 32)
  and (ten >= 5) and (ten > 5 or unique1 > 5000)
order by ten, unique1 limit 1;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=230.05..230.05 rows=1 width=244) (actual rows=1 loops=1)
   Buffers: shared hit=126
   ->  Sort  (cost=230.05..230.16 rows=42 width=244) (actual rows=1 loops=1)
         Sort Key: ten, unique1
         Sort Method: top-N heapsort  Memory: 25kB
         Buffers: shared hit=126
         ->  Index Scan using tenk1_dyn_saop_thous_tenthous on tenk1_dyn_saop  (cost=0.29..229.84 rows=42 width=244) (actual rows=80 loops=1)
               Index Cond: (thousand = ANY ('{19,29,39,49,57,66,77,8,90,12,22,32}'::integer[]))
               Filter: ((ten >= 5) AND ((ten > 5) OR (unique1 > 5000)))
               Rows Removed by Filter: 40
               Buffers: shared hit=126
(11 rows)

-- RhodiumToad test #2
--
-- Same query, but now we have the rhodium_toad index available, which makes
-- things significantly less efficient for master (1009 buffers hit), and
-- significantly more efficient for patch (7 buffers hit):
drop index tenk1_dyn_saop_thous_tenthous; -- have to force patch here
create index rhodium_toad on tenk1_dyn_saop(ten, unique1, thousand);
select * from tenk1_dyn_saop
where
  thousand in (19, 29, 39, 49, 57, 66, 77, 8, 90, 12, 22, 32)
  and (ten >= 5) and (ten > 5 or unique1 > 5000)
order by ten, unique1 limit 1;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
      66 |    6723 |   0 |    2 |   6 |      6 |      66 |       66 |          66 |        66 |       66 | 132 |  133 | OCAAAA   | PYJAAA   | VVVVxx
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from tenk1_dyn_saop
where
  thousand in (19, 29, 39, 49, 57, 66, 77, 8, 90, 12, 22, 32)
  and (ten >= 5) and (ten > 5 or unique1 > 5000)
order by ten, unique1 limit 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..5.15 rows=1 width=244) (actual rows=1 loops=1)
   Buffers: shared hit=7
   ->  Index Scan using rhodium_toad on tenk1_dyn_saop  (cost=0.29..204.57 rows=42 width=244) (actual rows=1 loops=1)
         Index Cond: ((ten >= 5) AND (thousand = ANY ('{19,29,39,49,57,66,77,8,90,12,22,32}'::integer[])))
         Filter: ((ten > 5) OR (unique1 > 5000))
         Buffers: shared hit=7
(6 rows)

-- Nice demo of importance of work in context of ORDER BY ... LIMIT
-- Only 13 buffer hits on patch...but 1337 buffer hits on master!
select ctid, two, four, twenty from tenk1_dyn_saop
where
  two in (0, 1) and four in (1, 2) and twenty in (1, 2)
order by two, four, twenty limit 20;
  ctid   | two | four | twenty 
---------+-----+------+--------
 (0,13)  |   0 |    2 |      2
 (0,25)  |   0 |    2 |      2
 (1,7)   |   0 |    2 |      2
 (1,25)  |   0 |    2 |      2
 (3,20)  |   0 |    2 |      2
 (4,7)   |   0 |    2 |      2
 (4,10)  |   0 |    2 |      2
 (4,27)  |   0 |    2 |      2
 (4,29)  |   0 |    2 |      2
 (6,14)  |   0 |    2 |      2
 (8,7)   |   0 |    2 |      2
 (10,8)  |   0 |    2 |      2
 (10,9)  |   0 |    2 |      2
 (11,25) |   0 |    2 |      2
 (12,8)  |   0 |    2 |      2
 (12,15) |   0 |    2 |      2
 (12,21) |   0 |    2 |      2
 (13,5)  |   0 |    2 |      2
 (14,7)  |   0 |    2 |      2
 (14,9)  |   0 |    2 |      2
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, two, four, twenty from tenk1_dyn_saop
where
  two in (0, 1) and four in (1, 2) and twenty in (1, 2)
order by two, four, twenty limit 20;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..21.03 rows=20 width=18) (actual rows=20 loops=1)
   Buffers: shared hit=13
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..518.89 rows=500 width=18) (actual rows=20 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four = ANY ('{1,2}'::integer[])) AND (twenty = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=13
(5 rows)

-- (March 12)
--
-- This case looks like it has lots of arrays (one on each of the four index
-- columns), but preprocessing manages to completely avoid ever needing a call
-- to _bt_advance_array_keys at runtime -- there are no array scan keys left
-- to advance once preprocessing completes.
--
-- So looks like this:
/*
so->numArrayKeys is 4 after initial array preprocessing
_bt_preprocess_keys:  inkeys[0]: [ strategy: = , flags: [SK_SEARCHARRAY], attno: 1 func OID: 65 ]
_bt_preprocess_keys:  inkeys[1]: [ strategy: InvalidStrategy, flags: [SK_SEARCHARRAY], attno: 1 func OID: 65 ]
_bt_preprocess_keys:  inkeys[2]: [ strategy: = , flags: [SK_SEARCHARRAY], attno: 2 func OID: 65 ]
_bt_preprocess_keys:  inkeys[3]: [ strategy: InvalidStrategy, flags: [SK_SEARCHARRAY], attno: 2 func OID: 65 ]
_bt_preprocess_keys:  inkeys[4]: [ strategy: = , flags: [SK_SEARCHARRAY], attno: 3 func OID: 65 ]
_bt_preprocess_keys:  inkeys[5]: [ strategy: > , flags: [], attno: 3 func OID: 147 ]
_bt_preprocess_keys:  inkeys[6]: [ strategy: = , flags: [SK_SEARCHARRAY], attno: 4 func OID: 65 ]
_bt_preprocess_keys:  inkeys[7]: [ strategy: < , flags: [], attno: 4 func OID: 66 ]
   _bt_binsrch_array_skey: searching for item 12, low_elem 0, high_elem 12, num_elems: 13
                           found item 12 at elem offset 11
   _bt_binsrch_array_skey: searching for item 94, low_elem 0, high_elem 3, num_elems: 4
                           found item 94 at elem offset 1
_bt_preprocess_keys: outkeys[0]: [ strategy: = , flags: [SK_BT_REQFWD, SK_BT_REQBKWD], attno: 1 func OID: 65 ]  <-- no trace of the SK_SEARCHARRAY markings here
_bt_preprocess_keys: outkeys[1]: [ strategy: = , flags: [SK_BT_REQFWD, SK_BT_REQBKWD], attno: 2 func OID: 65 ]  <-////
_bt_preprocess_keys: outkeys[2]: [ strategy: = , flags: [SK_BT_REQFWD, SK_BT_REQBKWD], attno: 3 func OID: 65 ]  <-///
_bt_preprocess_keys: outkeys[3]: [ strategy: = , flags: [SK_BT_REQFWD, SK_BT_REQBKWD], attno: 4 func OID: 65 ]  <-//
_bt_preprocess_keys: scan->numberOfKeys is 8, so->numberOfKeys on output is 4, so->numArrayKeys on output is 0  <-/
*/
select ctid, two, four, twenty, hundred
from tenk1_dyn_saop
where
  two in (0, 1) and two in (1, 3)
  and
  four in (0, 1) and four in (1,2)
  and
  twenty in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12,13) and twenty > 12
  and
  hundred in (93, 94, 95, 96) and hundred < 94
order by two, four, twenty;
   ctid   | two | four | twenty | hundred 
----------+-----+------+--------+---------
 (7,1)    |   1 |    1 |     13 |      93
 (10,19)  |   1 |    1 |     13 |      93
 (13,24)  |   1 |    1 |     13 |      93
 (20,8)   |   1 |    1 |     13 |      93
 (22,7)   |   1 |    1 |     13 |      93
 (26,6)   |   1 |    1 |     13 |      93
 (30,27)  |   1 |    1 |     13 |      93
 (31,6)   |   1 |    1 |     13 |      93
 (32,14)  |   1 |    1 |     13 |      93
 (33,23)  |   1 |    1 |     13 |      93
 (36,3)   |   1 |    1 |     13 |      93
 (39,11)  |   1 |    1 |     13 |      93
 (41,6)   |   1 |    1 |     13 |      93
 (43,24)  |   1 |    1 |     13 |      93
 (48,15)  |   1 |    1 |     13 |      93
 (52,2)   |   1 |    1 |     13 |      93
 (55,9)   |   1 |    1 |     13 |      93
 (62,13)  |   1 |    1 |     13 |      93
 (67,24)  |   1 |    1 |     13 |      93
 (68,7)   |   1 |    1 |     13 |      93
 (69,4)   |   1 |    1 |     13 |      93
 (85,7)   |   1 |    1 |     13 |      93
 (87,13)  |   1 |    1 |     13 |      93
 (90,28)  |   1 |    1 |     13 |      93
 (91,18)  |   1 |    1 |     13 |      93
 (91,27)  |   1 |    1 |     13 |      93
 (95,16)  |   1 |    1 |     13 |      93
 (98,25)  |   1 |    1 |     13 |      93
 (102,6)  |   1 |    1 |     13 |      93
 (113,1)  |   1 |    1 |     13 |      93
 (114,5)  |   1 |    1 |     13 |      93
 (116,19) |   1 |    1 |     13 |      93
 (116,22) |   1 |    1 |     13 |      93
 (120,10) |   1 |    1 |     13 |      93
 (121,23) |   1 |    1 |     13 |      93
 (122,14) |   1 |    1 |     13 |      93
 (128,4)  |   1 |    1 |     13 |      93
 (129,18) |   1 |    1 |     13 |      93
 (138,25) |   1 |    1 |     13 |      93
 (138,29) |   1 |    1 |     13 |      93
 (143,8)  |   1 |    1 |     13 |      93
 (146,5)  |   1 |    1 |     13 |      93
 (151,14) |   1 |    1 |     13 |      93
 (161,19) |   1 |    1 |     13 |      93
 (161,29) |   1 |    1 |     13 |      93
 (164,27) |   1 |    1 |     13 |      93
 (166,9)  |   1 |    1 |     13 |      93
 (173,26) |   1 |    1 |     13 |      93
 (174,12) |   1 |    1 |     13 |      93
 (174,26) |   1 |    1 |     13 |      93
 (179,8)  |   1 |    1 |     13 |      93
 (179,15) |   1 |    1 |     13 |      93
 (187,10) |   1 |    1 |     13 |      93
 (187,21) |   1 |    1 |     13 |      93
 (194,9)  |   1 |    1 |     13 |      93
 (196,5)  |   1 |    1 |     13 |      93
 (198,29) |   1 |    1 |     13 |      93
 (199,5)  |   1 |    1 |     13 |      93
 (204,13) |   1 |    1 |     13 |      93
 (208,1)  |   1 |    1 |     13 |      93
 (208,29) |   1 |    1 |     13 |      93
 (214,29) |   1 |    1 |     13 |      93
 (216,20) |   1 |    1 |     13 |      93
 (219,29) |   1 |    1 |     13 |      93
 (221,4)  |   1 |    1 |     13 |      93
 (226,18) |   1 |    1 |     13 |      93
 (228,22) |   1 |    1 |     13 |      93
 (243,12) |   1 |    1 |     13 |      93
 (246,19) |   1 |    1 |     13 |      93
 (246,22) |   1 |    1 |     13 |      93
 (247,14) |   1 |    1 |     13 |      93
 (248,5)  |   1 |    1 |     13 |      93
 (250,3)  |   1 |    1 |     13 |      93
 (250,4)  |   1 |    1 |     13 |      93
 (250,10) |   1 |    1 |     13 |      93
 (252,18) |   1 |    1 |     13 |      93
 (258,17) |   1 |    1 |     13 |      93
 (258,24) |   1 |    1 |     13 |      93
 (259,2)  |   1 |    1 |     13 |      93
 (260,10) |   1 |    1 |     13 |      93
 (260,26) |   1 |    1 |     13 |      93
 (267,23) |   1 |    1 |     13 |      93
 (270,15) |   1 |    1 |     13 |      93
 (289,14) |   1 |    1 |     13 |      93
 (296,1)  |   1 |    1 |     13 |      93
 (299,25) |   1 |    1 |     13 |      93
 (309,19) |   1 |    1 |     13 |      93
 (310,6)  |   1 |    1 |     13 |      93
 (313,23) |   1 |    1 |     13 |      93
 (314,26) |   1 |    1 |     13 |      93
 (317,6)  |   1 |    1 |     13 |      93
 (317,17) |   1 |    1 |     13 |      93
 (319,22) |   1 |    1 |     13 |      93
 (319,29) |   1 |    1 |     13 |      93
 (326,12) |   1 |    1 |     13 |      93
 (329,3)  |   1 |    1 |     13 |      93
 (337,12) |   1 |    1 |     13 |      93
 (338,21) |   1 |    1 |     13 |      93
 (344,16) |   1 |    1 |     13 |      93
 (344,18) |   1 |    1 |     13 |      93
(100 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, two, four, twenty, hundred
from tenk1_dyn_saop
where
  two in (0, 1) and two in (1, 3)
  and
  four in (0, 1) and four in (1,2)
  and
  twenty in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12,13) and twenty > 12
  and
  hundred in (93, 94, 95, 96) and hundred < 94
order by two, four, twenty;
                                                                                                                                                        QUERY PLAN                                                                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..28.64 rows=11 width=22) (actual rows=100 loops=1)
   Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (two = ANY ('{1,3}'::integer[])) AND (four = ANY ('{0,1}'::integer[])) AND (four = ANY ('{1,2}'::integer[])) AND (twenty = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12,13}'::integer[])) AND (twenty > 12) AND (hundred = ANY ('{93,94,95,96}'::integer[])) AND (hundred < 94))
   Buffers: shared hit=86
(3 rows)

VACUUM ANALYZE tenk1_dyn_saop;
set enable_indexonlyscan to on;
set enable_sort to off;
-------------------------------------------------------------
-- Pathological case with a huge number of array constants --
-------------------------------------------------------------
-- This stresses "binary search for array keys" logic, verifying that we never
-- do very much work under a buffer lock.  Needed in mid to late August.
prepare binsearch_stress_forward as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_backwards as
with a as (
  select i from generate_series(-1, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two desc, four desc, twenty desc;
-- Forward and backwards variants both tested:
execute binsearch_stress_forward;
 count | two | four | twenty 
-------+-----+------+--------
   500 |   0 |    0 |      0
   500 |   0 |    0 |      4
   500 |   0 |    0 |      8
   500 |   0 |    0 |     12
   500 |   0 |    0 |     16
   500 |   0 |    2 |      2
   500 |   0 |    2 |      6
   500 |   0 |    2 |     10
   500 |   0 |    2 |     14
   500 |   0 |    2 |     18
   500 |   1 |    1 |      1
   500 |   1 |    1 |      5
   500 |   1 |    1 |      9
   500 |   1 |    1 |     13
   500 |   1 |    1 |     17
   500 |   1 |    3 |      3
   500 |   1 |    3 |      7
   500 |   1 |    3 |     11
   500 |   1 |    3 |     15
   500 |   1 |    3 |     19
(20 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_forward;
execute binsearch_stress_backwards;
 count | two | four | twenty 
-------+-----+------+--------
   500 |   1 |    3 |     19
   500 |   1 |    3 |     15
   500 |   1 |    3 |     11
   500 |   1 |    3 |      7
   500 |   1 |    3 |      3
   500 |   1 |    1 |     17
   500 |   1 |    1 |     13
   500 |   1 |    1 |      9
   500 |   1 |    1 |      5
   500 |   1 |    1 |      1
   500 |   0 |    2 |     18
   500 |   0 |    2 |     14
   500 |   0 |    2 |     10
   500 |   0 |    2 |      6
   500 |   0 |    2 |      2
   500 |   0 |    0 |     16
   500 |   0 |    0 |     12
   500 |   0 |    0 |      8
   500 |   0 |    0 |      4
   500 |   0 |    0 |      0
(20 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Ditto
-- execute binsearch_stress_backwards;
-- (February 20) Stress test with large arrays and contradictory quals
-- This doesn't make the query have only one call to _bt_preprocess_keys, but
-- it does reduce the number to 5000 (since that's the number of distinct
-- "two" values, and "two" is the most significant column here):
prepare binsearch_stress_contradictory_two_equal as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
  from
  tenk1_dyn_saop
  where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)]) and
-- Avoid redundancy detection in planner and in _bt_preprocess_array_keys by using
-- cross-type contradictory qual:
  two = 500000::int8 and two = 600000::int4
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_two_inequal_first as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
  and two >= 5 and two = 4
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_two_inequal_second as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two >= 5 and two = 4 and
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_two_inequal_third as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two >= 5 and
  two = any (array[(select array_agg(i) from a)]) and
  two = 4 and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_two_inequal_fourth as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = 4 and
  two = any (array[(select array_agg(i) from a)]) and
  two >= 5 and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
-- This doesn't make the query have only one call to _bt_preprocess_keys, and
-- since "twenty" is the lowest order column it isn't very effective at all:
prepare binsearch_stress_contradictory_twenty_equal as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)]) and
-- Avoid redundancy detection in planner and in _bt_preprocess_array_keys by using
-- cross-type contradictory qual:
  twenty = 500000::int8 and twenty = 600000::int4
group by
  two, four, twenty
order by
  two, four, twenty;
-- This is essentially the same issue, except that it works perfectly (only
-- one call to _bt_preprocess_keys for whole top-level query) due to the fact
-- that the contradictory qual doesn't involve an array at all:
prepare binsearch_stress_contradictory_unique1_equal as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)]) and
-- Avoid redundancy detection in planner and in _bt_preprocess_array_keys by using
-- cross-type contradictory qual:
  unique1 = 500000::int8 and unique1 = 600000::int4
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_twenty_inequal_first as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
  and twenty >= 5 and twenty = 4
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_twenty_inequal_second as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  twenty >= 5 and twenty = 4 and
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_twenty_inequal_third as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty >= 5 and
  twenty = any (array[(select array_agg(i) from a)]) and
  twenty = 4
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_twenty_inequal_fourth as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = 4 and
  twenty = any (array[(select array_agg(i) from a)]) and
  twenty >= 5
group by
  two, four, twenty
order by
  two, four, twenty;
prepare binsearch_stress_contradictory_twenty_inequal_fifth as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)]) and
  twenty > 5000
group by
  two, four, twenty
order by
  two, four, twenty;
-- (XXX UPDATE June 18 2024) Disable these flappy tests, which haven't caught
-- a bug during skip scan project
--
-- execute binsearch_stress_contradictory_two_equal;
-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
-- execute binsearch_stress_contradictory_two_equal;
execute binsearch_stress_contradictory_two_inequal_first;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_contradictory_two_inequal_first;
execute binsearch_stress_contradictory_two_inequal_second;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_contradictory_two_inequal_second;
execute binsearch_stress_contradictory_two_inequal_third;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)    <-- Ditto
-- execute binsearch_stress_contradictory_two_inequal_third;
execute binsearch_stress_contradictory_two_inequal_fourth;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)    <-- Ditto
-- execute binsearch_stress_contradictory_two_inequal_fourth;
-- Don't execute problematic tests on lower-order "twenty" column, at least
-- for now (this takes far too long, times out):
--
-- (February 29) UPDATE:  Now we do these tests, too
--
-- (XXX UPDATE June 18 2024) Disable these flappy tests, which haven't caught
-- a bug during skip scan project
--
-- execute binsearch_stress_contradictory_twenty_equal;
-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
-- execute binsearch_stress_contradictory_twenty_equal;
-- Note, however, that this very similar variant of the problematic query
-- works just fine, all because the contradictory qual thing doesn't happen
-- to involve an array this time (though it does involve a very low-order
-- column, this time unique1 instead of "twenty"):
--
-- (XXX UPDATE June 18 2024) Disable these flappy tests, which haven't caught
-- a bug during skip scan project
-- execute binsearch_stress_contradictory_unique1_equal;
-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
-- execute binsearch_stress_contradictory_unique1_equal;
-- (February 29) UPDATE:  Now we start running these tests, too
execute binsearch_stress_contradictory_twenty_inequal_first;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_contradictory_twenty_inequal_first;
execute binsearch_stress_contradictory_twenty_inequal_second;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Ditto
-- execute binsearch_stress_contradictory_twenty_inequal_second;
execute binsearch_stress_contradictory_twenty_inequal_third;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Ditto
-- execute binsearch_stress_contradictory_twenty_inequal_third;
execute binsearch_stress_contradictory_twenty_inequal_fourth;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Ditto
-- execute binsearch_stress_contradictory_twenty_inequal_fourth;
execute binsearch_stress_contradictory_twenty_inequal_fifth;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Ditto
-- execute binsearch_stress_contradictory_twenty_inequal_fifth;
deallocate binsearch_stress_contradictory_two_equal;
deallocate binsearch_stress_contradictory_two_inequal_first;
deallocate binsearch_stress_contradictory_two_inequal_second;
deallocate binsearch_stress_contradictory_two_inequal_third;
deallocate binsearch_stress_contradictory_two_inequal_fourth;
deallocate binsearch_stress_contradictory_twenty_equal;
deallocate binsearch_stress_contradictory_twenty_inequal_first;
deallocate binsearch_stress_contradictory_twenty_inequal_second;
deallocate binsearch_stress_contradictory_twenty_inequal_third;
deallocate binsearch_stress_contradictory_twenty_inequal_fourth;
-- Same again, but with extra values at the end of the key space to stress the
-- implementation:
insert into tenk1_dyn_saop select unique1, unique2, 4999, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4 from tenk1_dyn_saop limit 1 offset 0;
insert into tenk1_dyn_saop select unique1, unique2, 5000, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4 from tenk1_dyn_saop limit 1 offset 1;
insert into tenk1_dyn_saop select unique1, unique2, 5001, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4 from tenk1_dyn_saop limit 1 offset 2;
insert into tenk1_dyn_saop select unique1, unique2,   -5, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4 from tenk1_dyn_saop limit 1 offset 3;
-- Forward and backwards variants both tested:
execute binsearch_stress_forward;
 count | two  | four | twenty 
-------+------+------+--------
   500 |    0 |    0 |      0
   500 |    0 |    0 |      4
   500 |    0 |    0 |      8
   500 |    0 |    0 |     12
   500 |    0 |    0 |     16
   500 |    0 |    2 |      2
   500 |    0 |    2 |      6
   500 |    0 |    2 |     10
   500 |    0 |    2 |     14
   500 |    0 |    2 |     18
   500 |    1 |    1 |      1
   500 |    1 |    1 |      5
   500 |    1 |    1 |      9
   500 |    1 |    1 |     13
   500 |    1 |    1 |     17
   500 |    1 |    3 |      3
   500 |    1 |    3 |      7
   500 |    1 |    3 |     11
   500 |    1 |    3 |     15
   500 |    1 |    3 |     19
     1 | 4999 |    0 |      0
     1 | 5000 |    3 |     11
(22 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_forward;
execute binsearch_stress_backwards;
 count | two  | four | twenty 
-------+------+------+--------
     1 | 5000 |    3 |     11
     1 | 4999 |    0 |      0
   500 |    1 |    3 |     19
   500 |    1 |    3 |     15
   500 |    1 |    3 |     11
   500 |    1 |    3 |      7
   500 |    1 |    3 |      3
   500 |    1 |    1 |     17
   500 |    1 |    1 |     13
   500 |    1 |    1 |      9
   500 |    1 |    1 |      5
   500 |    1 |    1 |      1
   500 |    0 |    2 |     18
   500 |    0 |    2 |     14
   500 |    0 |    2 |     10
   500 |    0 |    2 |      6
   500 |    0 |    2 |      2
   500 |    0 |    0 |     16
   500 |    0 |    0 |     12
   500 |    0 |    0 |      8
   500 |    0 |    0 |      4
   500 |    0 |    0 |      0
(22 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Ditto
-- execute binsearch_stress_backwards;
deallocate binsearch_stress_forward;
deallocate binsearch_stress_backwards;
-- Minor variant (500 rather than 5000) can independently break:
prepare binsearch_stress_variant as
with a as (
  select i from generate_series(0, 500) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
execute binsearch_stress_variant;
 count | two | four | twenty 
-------+-----+------+--------
   500 |   0 |    0 |      0
   500 |   0 |    0 |      4
   500 |   0 |    0 |      8
   500 |   0 |    0 |     12
   500 |   0 |    0 |     16
   500 |   0 |    2 |      2
   500 |   0 |    2 |      6
   500 |   0 |    2 |     10
   500 |   0 |    2 |     14
   500 |   0 |    2 |     18
   500 |   1 |    1 |      1
   500 |   1 |    1 |      5
   500 |   1 |    1 |      9
   500 |   1 |    1 |     13
   500 |   1 |    1 |     17
   500 |   1 |    3 |      3
   500 |   1 |    3 |      7
   500 |   1 |    3 |     11
   500 |   1 |    3 |     15
   500 |   1 |    3 |     19
(20 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_variant;
deallocate binsearch_stress_variant;
-- Minor variant (500 rather than 5000) with a backwards scan, just for good luck:
prepare binsearch_stress_variant_backwards as
with a as (
  select i from generate_series(0, 500) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two desc, four desc, twenty desc;
execute binsearch_stress_variant_backwards;
 count | two | four | twenty 
-------+-----+------+--------
   500 |   1 |    3 |     19
   500 |   1 |    3 |     15
   500 |   1 |    3 |     11
   500 |   1 |    3 |      7
   500 |   1 |    3 |      3
   500 |   1 |    1 |     17
   500 |   1 |    1 |     13
   500 |   1 |    1 |      9
   500 |   1 |    1 |      5
   500 |   1 |    1 |      1
   500 |   0 |    2 |     18
   500 |   0 |    2 |     14
   500 |   0 |    2 |     10
   500 |   0 |    2 |      6
   500 |   0 |    2 |      2
   500 |   0 |    0 |     16
   500 |   0 |    0 |     12
   500 |   0 |    0 |      8
   500 |   0 |    0 |      4
   500 |   0 |    0 |      0
(20 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_variant_backwards;
deallocate binsearch_stress_variant_backwards;
-- Another variant (4999 rather than 5000) can independently break:
prepare binsearch_stress_other_variant as
with a as (
  select i from generate_series(0, 4999) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
execute binsearch_stress_other_variant;
 count | two  | four | twenty 
-------+------+------+--------
   500 |    0 |    0 |      0
   500 |    0 |    0 |      4
   500 |    0 |    0 |      8
   500 |    0 |    0 |     12
   500 |    0 |    0 |     16
   500 |    0 |    2 |      2
   500 |    0 |    2 |      6
   500 |    0 |    2 |     10
   500 |    0 |    2 |     14
   500 |    0 |    2 |     18
   500 |    1 |    1 |      1
   500 |    1 |    1 |      5
   500 |    1 |    1 |      9
   500 |    1 |    1 |     13
   500 |    1 |    1 |     17
   500 |    1 |    3 |      3
   500 |    1 |    3 |      7
   500 |    1 |    3 |     11
   500 |    1 |    3 |     15
   500 |    1 |    3 |     19
     1 | 4999 |    0 |      0
(21 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_other_variant;
deallocate binsearch_stress_other_variant;
-- Yet another variant (4666 rather than 5000 -- no high matches returned) might be able to independently
-- break, so be careful and include coverage for that case too:
prepare binsearch_stress_yav as
with a as (
  select i from generate_series(0, 4666) i
)
select
  count(*), two, four, twenty
from
  tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
execute binsearch_stress_yav;
 count | two | four | twenty 
-------+-----+------+--------
   500 |   0 |    0 |      0
   500 |   0 |    0 |      4
   500 |   0 |    0 |      8
   500 |   0 |    0 |     12
   500 |   0 |    0 |     16
   500 |   0 |    2 |      2
   500 |   0 |    2 |      6
   500 |   0 |    2 |     10
   500 |   0 |    2 |     14
   500 |   0 |    2 |     18
   500 |   1 |    1 |      1
   500 |   1 |    1 |      5
   500 |   1 |    1 |      9
   500 |   1 |    1 |     13
   500 |   1 |    1 |     17
   500 |   1 |    3 |      3
   500 |   1 |    3 |      7
   500 |   1 |    3 |     11
   500 |   1 |    3 |     15
   500 |   1 |    3 |     19
(20 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- <-- Sept 28 2024, disable for test stability
-- execute binsearch_stress_yav;
deallocate binsearch_stress_yav;
-----------------------------
-- Empty index stress test --
-----------------------------
-- (September 12) This test shows the importance of avoiding becoming confused
-- when we fail to reach _bt_readpage due to not having any pages in the index
-- (but having some array keys)
set client_min_messages=error;
drop table if exists empty_tenk1_dyn_saop;
reset client_min_messages;
create unlogged table empty_tenk1_dyn_saop
(
  like tenk1_dyn_saop including indexes
);
prepare empty_table_stress_test as
with a as (
  select i from generate_series(0, 5000) i
)
select
  count(*), two, four, twenty
from
  empty_tenk1_dyn_saop
where
  two = any (array[(select array_agg(i) from a)]) and
  four = any (array[(select array_agg(i) from a)]) and
  twenty = any (array[(select array_agg(i) from a)])
group by
  two, four, twenty
order by
  two, four, twenty;
execute empty_table_stress_test;
 count | two | four | twenty 
-------+-----+------+--------
(0 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
-- execute empty_table_stress_test;
-- Here it's important not to charge too much for a ludicrously high number of
-- descents of the index that exceeds what is possible with the patch:
--
-- July 21: Same example as the one shown to Tomas on-list today.
--
-- Index-only scan to make this realistic/compelling:
VACUUM (freeze,analyze) tenk1_dyn_saop;
set enable_indexonlyscan to on;
prepare tomas_demo as
select count(*), two, four, twenty from tenk1_dyn_saop
where
  two in (0, 1)
  and four in (1, 2, 3, 4)
  and twenty in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
group by
  two,
  four,
  twenty
order by
  two,
  four,
  twenty;
execute tomas_demo;
 count | two | four | twenty 
-------+-----+------+--------
   500 |   0 |    2 |      2
   500 |   0 |    2 |      6
   500 |   0 |    2 |     10
   500 |   0 |    2 |     14
   500 |   1 |    1 |      1
   500 |   1 |    1 |      5
   500 |   1 |    1 |      9
   500 |   1 |    1 |     13
   500 |   1 |    3 |      3
   500 |   1 |    3 |      7
   500 |   1 |    3 |     11
   500 |   1 |    3 |     15
(12 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 10 buffer hits
execute tomas_demo;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..200.72 rows=480 width=20) (actual rows=12 loops=1)
   Group Key: two, four, twenty
   Buffers: shared hit=10
   ->  Index Only Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..139.68 rows=5624 width=12) (actual rows=6000 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four = ANY ('{1,2,3,4}'::integer[])) AND (twenty = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}'::integer[])))
         Heap Fetches: 0
         Buffers: shared hit=10
(7 rows)

-- (August 26)
-- Same query, but we must force the use of tenk1_dyn_saop_idx_lowcard, which
-- failed in an independently interesting way alongside the prior query during
-- work on binary search for next key:
drop index tenk1_dyn_saop_idx_many_columns;
drop index tenk1_idx_extra_column_in_middle;
-- Same query with other index:
execute tomas_demo;
 count | two | four | twenty 
-------+-----+------+--------
   500 |   0 |    2 |      2
   500 |   0 |    2 |      6
   500 |   0 |    2 |     10
   500 |   0 |    2 |     14
   500 |   1 |    1 |      1
   500 |   1 |    1 |      5
   500 |   1 |    1 |      9
   500 |   1 |    1 |     13
   500 |   1 |    3 |      3
   500 |   1 |    3 |      7
   500 |   1 |    3 |     11
   500 |   1 |    3 |     15
(12 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 9 buffer hits
execute tomas_demo;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..200.72 rows=480 width=20) (actual rows=12 loops=1)
   Group Key: two, four, twenty
   Buffers: shared hit=9
   ->  Index Only Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..139.68 rows=5624 width=12) (actual rows=6000 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four = ANY ('{1,2,3,4}'::integer[])) AND (twenty = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}'::integer[])))
         Heap Fetches: 0
         Buffers: shared hit=9
(7 rows)

deallocate tomas_demo;
-- (August 26)
-- Recreate temporarily dropped tenk1_idx_extra_column_in_middle index from
-- before:
create index tenk1_idx_extra_column_in_middle on tenk1_dyn_saop(two,four,twenty);
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Same trick should work with leading attribute a non-SAOP:
select ctid, thousand from tenk1_dyn_saop
where
  two = 0 and four in (1, 2) and twenty in (1, 2)
order by two, four, twenty limit 20;
  ctid   | thousand 
---------+----------
 (0,13)  |      222
 (0,25)  |      442
 (1,7)   |      162
 (1,25)  |      322
 (3,20)  |      742
 (4,7)   |      202
 (4,10)  |      902
 (4,27)  |      642
 (4,29)  |      682
 (6,14)  |      302
 (8,7)   |      302
 (10,8)  |      702
 (10,9)  |      362
 (11,25) |      442
 (12,8)  |      622
 (12,15) |      122
 (12,21) |      642
 (13,5)  |       42
 (14,7)  |      502
 (14,9)  |      182
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, thousand from tenk1_dyn_saop
where
  two = 0 and four in (1, 2) and twenty in (1, 2)
order by two, four, twenty limit 20;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..26.72 rows=20 width=22) (actual rows=20 loops=1)
   Buffers: shared hit=13
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..330.74 rows=250 width=22) (actual rows=20 loops=1)
         Index Cond: ((two = 0) AND (four = ANY ('{1,2}'::integer[])) AND (twenty = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=13
(5 rows)

-- Same trick should work with middle attribute a non-SAOP:
select ctid, thousand from tenk1_dyn_saop
where
  two in (0, 1) and four = 1 and twenty in (1, 2)
order by two, four, twenty limit 20;
  ctid   | thousand 
---------+----------
 (0,8)   |      701
 (0,9)   |      321
 (0,19)  |      621
 (1,12)  |      921
 (1,26)  |      321
 (2,17)  |      741
 (3,3)   |      501
 (3,8)   |      401
 (4,19)  |      481
 (6,16)  |      901
 (8,16)  |      601
 (9,21)  |      821
 (9,23)  |      581
 (9,29)  |       81
 (10,15) |       81
 (10,20) |      201
 (11,2)  |      941
 (11,9)  |      541
 (12,4)  |      901
 (13,10) |       61
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, thousand from tenk1_dyn_saop
where
  two in (0, 1) and four = 1 and twenty in (1, 2)
order by two, four, twenty limit 20;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..26.72 rows=20 width=22) (actual rows=20 loops=1)
   Buffers: shared hit=16
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..330.74 rows=250 width=22) (actual rows=20 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four = 1) AND (twenty = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=16
(5 rows)

-- Even an inequality on two should work, since we can get through non-matches
-- from the index quickly.
--
-- Even with a leading inequality ("two !=0"), the patch does almost 10x fewer
-- buffer accesses than the master branch will.
select ctid, thousand from tenk1_dyn_saop
where
  two != 0 and four in (1, 2) and twenty in (1, 2)
order by two, four, twenty limit 20;
  ctid   | thousand 
---------+----------
 (0,8)   |      701
 (0,9)   |      321
 (0,19)  |      621
 (1,12)  |      921
 (1,26)  |      321
 (2,17)  |      741
 (3,3)   |      501
 (3,8)   |      401
 (4,19)  |      481
 (6,16)  |      901
 (8,16)  |      601
 (9,21)  |      821
 (9,23)  |      581
 (9,29)  |       81
 (10,15) |       81
 (10,20) |      201
 (11,2)  |      941
 (11,9)  |      541
 (12,4)  |      901
 (13,10) |       61
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, thousand from tenk1_dyn_saop
where
  two != 0 and four in (1, 2) and twenty in (1, 2)
order by two, four, twenty limit 20;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..50.43 rows=20 width=22) (actual rows=20 loops=1)
   Buffers: shared hit=287
   ->  Index Scan using tenk1_idx_extra_column_in_middle on tenk1_dyn_saop  (cost=0.29..627.08 rows=250 width=22) (actual rows=20 loops=1)
         Index Cond: ((four = ANY ('{1,2}'::integer[])) AND (twenty = ANY ('{1,2}'::integer[])))
         Filter: (two <> 0)
         Rows Removed by Filter: 500
         Buffers: shared hit=287
(7 rows)

-- Same trick should work with interlaced SOAPs and non-SAOPS:
drop index tenk1_idx_extra_column_in_middle;
-- First variant:
select ctid, two, four, twenty, hundred
  from tenk1_dyn_saop
where
  two in (0, 1) and four = 1 and twenty in (0, 1) and hundred = 1
order by two, four, twenty, hundred limit 20;
  ctid   | two | four | twenty | hundred 
---------+-----+------+--------+---------
 (0,8)   |   1 |    1 |      1 |       1
 (3,3)   |   1 |    1 |      1 |       1
 (3,8)   |   1 |    1 |      1 |       1
 (6,16)  |   1 |    1 |      1 |       1
 (8,16)  |   1 |    1 |      1 |       1
 (10,20) |   1 |    1 |      1 |       1
 (12,4)  |   1 |    1 |      1 |       1
 (13,18) |   1 |    1 |      1 |       1
 (14,14) |   1 |    1 |      1 |       1
 (18,13) |   1 |    1 |      1 |       1
 (25,14) |   1 |    1 |      1 |       1
 (31,17) |   1 |    1 |      1 |       1
 (32,24) |   1 |    1 |      1 |       1
 (32,28) |   1 |    1 |      1 |       1
 (37,19) |   1 |    1 |      1 |       1
 (38,27) |   1 |    1 |      1 |       1
 (42,9)  |   1 |    1 |      1 |       1
 (50,16) |   1 |    1 |      1 |       1
 (50,19) |   1 |    1 |      1 |       1
 (52,7)  |   1 |    1 |      1 |       1
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, two, four, twenty, hundred
  from tenk1_dyn_saop
where
  two in (0, 1) and four = 1 and twenty in (0, 1) and hundred = 1
order by two, four, twenty, hundred limit 20;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..14.65 rows=3 width=22) (actual rows=20 loops=1)
   Buffers: shared hit=21
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..14.65 rows=3 width=22) (actual rows=20 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four = 1) AND (twenty = ANY ('{0,1}'::integer[])) AND (hundred = 1))
         Buffers: shared hit=21
(5 rows)

-- Second variant:
select ctid, two, four, twenty, hundred
  from tenk1_dyn_saop
where
  two = 1 and four in (1, 2) and twenty = 1 and hundred in (0, 1)
order by two, four, twenty, hundred limit 20;
  ctid   | two | four | twenty | hundred 
---------+-----+------+--------+---------
 (0,8)   |   1 |    1 |      1 |       1
 (3,3)   |   1 |    1 |      1 |       1
 (3,8)   |   1 |    1 |      1 |       1
 (6,16)  |   1 |    1 |      1 |       1
 (8,16)  |   1 |    1 |      1 |       1
 (10,20) |   1 |    1 |      1 |       1
 (12,4)  |   1 |    1 |      1 |       1
 (13,18) |   1 |    1 |      1 |       1
 (14,14) |   1 |    1 |      1 |       1
 (18,13) |   1 |    1 |      1 |       1
 (25,14) |   1 |    1 |      1 |       1
 (31,17) |   1 |    1 |      1 |       1
 (32,24) |   1 |    1 |      1 |       1
 (32,28) |   1 |    1 |      1 |       1
 (37,19) |   1 |    1 |      1 |       1
 (38,27) |   1 |    1 |      1 |       1
 (42,9)  |   1 |    1 |      1 |       1
 (50,16) |   1 |    1 |      1 |       1
 (50,19) |   1 |    1 |      1 |       1
 (52,7)  |   1 |    1 |      1 |       1
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, two, four, twenty, hundred
  from tenk1_dyn_saop
where
  two = 1 and four in (1, 2) and twenty = 1 and hundred in (0, 1)
order by two, four, twenty, hundred limit 20;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..14.65 rows=3 width=22) (actual rows=20 loops=1)
   Buffers: shared hit=19
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..14.65 rows=3 width=22) (actual rows=20 loops=1)
         Index Cond: ((two = 1) AND (four = ANY ('{1,2}'::integer[])) AND (twenty = 1) AND (hundred = ANY ('{0,1}'::integer[])))
         Buffers: shared hit=19
(5 rows)

-- (November 8)
--
-- Provides backwards scan "We're still setting the keys to values >= the
-- tuple here -- it just needs to work for the tuple as a whole." case
-- coverage.
--
-- This hits "hundred" column with tuple "(two, four, twenty, hundred)=(0, 0, 16, 96)".
-- This tuple is the first tuple seen by the first _bt_readpage call (its
-- offnum actually came from _bt_first's _bt_binsrch call).
--
-- Seems like this needs to make sure that we reset the cur_elem for "hundred"
-- to the first element for the current scan direction.  So this transition is
-- important:
--
-- - sk_attno: 1, cur_elem 0/0, val: 0 [NULLS LAST, ASC]
-- - sk_attno: 2, cur_elem 1/1, val: 1 [NULLS LAST, ASC]
-- - sk_attno: 3, cur_elem 0/0, val: 15 [NULLS LAST, ASC]
-- - sk_attno: 4, cur_elem 1/1, val: 1000 [NULLS LAST, ASC]
--
-- + sk_attno: 1, cur_elem 0/0, val: 0 [NULLS LAST, ASC]
-- + sk_attno: 2, cur_elem 0/1, val: 0 [NULLS LAST, ASC]    <-- advances (from 1 to 0), so we're "matching the tuple" now
-- + sk_attno: 3, cur_elem 0/0, val: 15 [NULLS LAST, ASC]   <-- now we're "ahead of the tuple", since its value for this is 16
--                                                              (though cannot advance array because it has only one element)
-- + sk_attno: 4, cur_elem 1/1, val: 1000 [NULLS LAST, ASC] <-- this one had better remain at the first element for scan direction
--                                                              (and not spuriously "advance" to 96 value from tuple/array, for example)
--
-- Not completely clear whether or not the handling for this case is strictly
-- necessary.  After all, sk_attno 4/"hundred" doesn't actually need to
-- change at all here.  Still seems practically mandatory to have this
-- handling, since it is likely almost impossible to prove this either way.
-- (Besides, we definitely need similar logic for forwards scans already, and having symmetry is no bad thing).
--
-- (February 4) UPDATE: Actually, next test case (written today) decisively
-- proves that proper symmetric handling of this case during backward scans is
-- strictly necessary (as suspected all along).
select *
from tenk1_dyn_saop
where
  two = any ('{0}') and four = any ('{0, 1}') and twenty = any ('{15}') and hundred = any ('{96,1000}')
order by
  two desc, four desc, twenty desc, hundred desc;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from tenk1_dyn_saop
where
  two = any ('{0}') and four = any ('{0, 1}') and twenty = any ('{15}') and hundred = any ('{96,1000}')
order by
  two desc, four desc, twenty desc, hundred desc;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..11.21 rows=1 width=244) (actual rows=0 loops=1)
   Index Cond: ((two = ANY ('{0}'::integer[])) AND (four = ANY ('{0,1}'::integer[])) AND (twenty = ANY ('{15}'::integer[])) AND (hundred = ANY ('{96,1000}'::integer[])))
   Buffers: shared hit=4
(3 rows)

-- (March 2) Probably useless variant of the last test case of
-- February 4:
select *
from tenk1_dyn_saop
where
  two = any ('{0}') and four = any ('{0, 1}') and twenty = any ('{15}') and hundred = any ('{-1, 95}')
order by
  two desc, four desc, twenty desc, hundred desc;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from tenk1_dyn_saop
where
  two = any ('{0}') and four = any ('{0, 1}') and twenty = any ('{15}') and hundred = any ('{-1, 95}')
order by
  two desc, four desc, twenty desc, hundred desc;
                                                                               QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..11.21 rows=1 width=244) (actual rows=0 loops=1)
   Index Cond: ((two = ANY ('{0}'::integer[])) AND (four = ANY ('{0,1}'::integer[])) AND (twenty = ANY ('{15}'::integer[])) AND (hundred = ANY ('{-1,95}'::integer[])))
   Buffers: shared hit=4
(3 rows)

-- (February 4) Proper symmetric handling of "array advancement must not get
-- far ahead" in the backward scans case is strictly necessary, as evidenced
-- by this test case:
insert into tenk1_dyn_saop (two, four, twenty, hundred) select 0, 0, 7, 97;
select *
from tenk1_dyn_saop
where
  two = any ('{0}') and four = any ('{0, 1}') and twenty = any ('{7,6,1}') and hundred = any ('{76,96,85,97,78}')
order by
  two desc, four desc, twenty desc, hundred desc;
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
         |         |   0 |    0 |     |      7 |      97 |          |             |           |          |     |      |          |          | 
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from tenk1_dyn_saop
where
  two = any ('{0}') and four = any ('{0, 1}') and twenty = any ('{7,6,1}') and hundred = any ('{76,96,85,97,78}')
order by
  two desc, four desc, twenty desc, hundred desc;
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..42.40 rows=19 width=244) (actual rows=1 loops=1)
   Index Cond: ((two = ANY ('{0}'::integer[])) AND (four = ANY ('{0,1}'::integer[])) AND (twenty = ANY ('{7,6,1}'::integer[])) AND (hundred = ANY ('{76,96,85,97,78}'::integer[])))
   Buffers: shared hit=5
(3 rows)

-- (September 14)
--
-- Here we see contradictory scan keys on the column "two" during the start of
-- the first would-be primitive index scan where two = 1, but not any earlier
-- primitive scans.
prepare qual_on_two_not_okay_later_on as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two in (0, 1) and four in (1, 2, 3)
  and two < 1
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22)
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute qual_on_two_not_okay_later_on;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   0 |    2 |      2 |      22
   100 |   0 |    2 |     14 |      14
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_two_not_okay_later_on;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..292.41 rows=188 width=24) (actual rows=2 loops=1)
   Group Key: two, four, twenty, hundred
   Buffers: shared hit=175
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..287.95 rows=206 width=16) (actual rows=200 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (two < 1) AND (four = ANY ('{1,2,3}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
         Buffers: shared hit=175
(6 rows)

deallocate qual_on_two_not_okay_later_on;
-- (October 30)
-- Proof that we need to be careful around truncated high key
-- attributes.  They must have their cur_elem set to 0 directly.
--
-- Here the truncated high key "(two, four, twenty, hundred)=(1, 1, 5)" is at
-- issue.  We must not advance the "hundred" scan key's cur_elem past 45
-- prematurely, because we'll miss matches on:
-- "(two, four, twenty, hundred)=(1, 1, 5, 45)".
--
-- Here is what the buggy version looked like (note that this involves two
-- attributes needing to advance at the same time, on "twenty" and "hundred"):
--
-- _bt_advance_array_keys, pivot tuple: (two, four, twenty, hundred)=(1, 1, 5), 0x7f268631e508
--  numberOfKeys: 4
--  - sk_attno: 1, cur_elem 1/1, val: 1 [NULLS LAST, ASC]
--  - sk_attno: 3, cur_elem 0/2, val: 1 [NULLS LAST, ASC]
--  - sk_attno: 4, cur_elem 2/2, val: 88 [NULLS LAST, ASC]
--  + sk_attno: 1, cur_elem 1/1, val: 1 [NULLS LAST, ASC]
--  + sk_attno: 3, cur_elem 2/2, val: 5 [NULLS LAST, ASC]      <--- correct
--  + sk_attno: 4, cur_elem 2/2, val: 88 [NULLS LAST, ASC]     <--- buggy
-- _bt_advance_array_keys: returns true
--
-- And here is the correct version:
--
-- _bt_advance_array_keys, pivot tuple: (two, four, twenty, hundred)=(1, 1, 5), 0x7fa6612ca508
--  numberOfKeys: 4
--  - sk_attno: 1, cur_elem 1/1, val: 1 [NULLS LAST, ASC]
--  - sk_attno: 3, cur_elem 0/2, val: 1 [NULLS LAST, ASC]
--  - sk_attno: 4, cur_elem 2/2, val: 88 [NULLS LAST, ASC]
--  + sk_attno: 1, cur_elem 1/1, val: 1 [NULLS LAST, ASC]
--  + sk_attno: 3, cur_elem 2/2, val: 5 [NULLS LAST, ASC]      <--- correct, as before
--  + sk_attno: 4, cur_elem 0/2, val: 1 [NULLS LAST, ASC]      <--- correct this time around
-- _bt_advance_array_keys: returns true
--
prepare high_key_first_elem_confusion as
select count(*), two, four, twenty, hundred
from tenk1_dyn_saop
where two in (0, 1) and four = 1 and twenty in (1, 2, 5) and hundred in (1, 45, 88)
group by two, four, twenty, hundred
order by two, four, twenty, hundred;
execute high_key_first_elem_confusion;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      5 |      45
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute high_key_first_elem_confusion;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..28.74 rows=11 width=24) (actual rows=2 loops=1)
   Group Key: two, twenty, hundred
   Buffers: shared hit=177
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..28.52 rows=11 width=16) (actual rows=200 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (four = 1) AND (twenty = ANY ('{1,2,5}'::integer[])) AND (hundred = ANY ('{1,45,88}'::integer[])))
         Buffers: shared hit=177
(6 rows)

deallocate high_key_first_elem_confusion;
-- (September 14) Similar to above, but it's earlier value of two, not later
-- ones
prepare qual_on_two_not_okay_earlier_on as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two in (0, 1) and four in (1, 2, 3)
  and two > 0
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22)
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute qual_on_two_not_okay_earlier_on;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      41
   100 |   1 |    3 |     11 |      51
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_two_not_okay_earlier_on;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..292.41 rows=188 width=24) (actual rows=3 loops=1)
   Group Key: two, four, twenty, hundred
   Buffers: shared hit=270
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..287.95 rows=206 width=16) (actual rows=300 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (two > 0) AND (four = ANY ('{1,2,3}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
         Buffers: shared hit=270
(6 rows)

deallocate qual_on_two_not_okay_earlier_on;
-- (January 27) Similar to above, but switch the order of the "two" quals for
-- extra test coverage in _bt_preprocess_keys:
prepare qual_on_two_not_okay_earlier_on_switchqual as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two > 0 and
  two in (0, 1) and four in (1, 2, 3)
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22)
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute qual_on_two_not_okay_earlier_on_switchqual;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      41
   100 |   1 |    3 |     11 |      51
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_two_not_okay_earlier_on_switchqual;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..292.41 rows=188 width=24) (actual rows=3 loops=1)
   Group Key: two, four, twenty, hundred
   Buffers: shared hit=270
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..287.95 rows=206 width=16) (actual rows=300 loops=1)
         Index Cond: ((two > 0) AND (two = ANY ('{0,1}'::integer[])) AND (four = ANY ('{1,2,3}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
         Buffers: shared hit=270
(6 rows)

deallocate qual_on_two_not_okay_earlier_on_switchqual;
-- (January 27) Similar to above, but switch the order of the "two" quals for
-- extra test coverage in _bt_preprocess_keys, with different details:
prepare qual_on_two_not_okay_earlier_on_switchqual_again as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two in (0, 1) and four in (1, 2, 3)
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22)
  and two > 0
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute qual_on_two_not_okay_earlier_on_switchqual_again;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      41
   100 |   1 |    3 |     11 |      51
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_two_not_okay_earlier_on_switchqual_again;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..292.41 rows=188 width=24) (actual rows=3 loops=1)
   Group Key: two, four, twenty, hundred
   Buffers: shared hit=270
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..287.95 rows=206 width=16) (actual rows=300 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (two > 0) AND (four = ANY ('{1,2,3}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
         Buffers: shared hit=270
(6 rows)

deallocate qual_on_two_not_okay_earlier_on_switchqual_again;
-- (January 27) Similar to above, but with = instead of > for "two" qual:
prepare qual_on_two_not_okay_earlier_on_switchqual_equal as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two in (0, 1) and four in (1, 2, 3)
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22)
  and two = 1
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute qual_on_two_not_okay_earlier_on_switchqual_equal;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      41
   100 |   1 |    3 |     11 |      51
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_two_not_okay_earlier_on_switchqual_equal;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..291.89 rows=188 width=24) (actual rows=3 loops=1)
   Group Key: four, twenty, hundred
   Buffers: shared hit=270
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..287.95 rows=206 width=16) (actual rows=300 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (two = 1) AND (four = ANY ('{1,2,3}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
         Buffers: shared hit=270
(6 rows)

deallocate qual_on_two_not_okay_earlier_on_switchqual_equal;
-- (September 14) Similar to above, but it's an equality this time
prepare qual_on_two_not_okay_earlier_on_equality as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two in (0, 1) and four in (1, 2, 3)
  and two = 1
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22)
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute qual_on_two_not_okay_earlier_on_equality;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      41
   100 |   1 |    3 |     11 |      51
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_two_not_okay_earlier_on_equality;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..291.89 rows=188 width=24) (actual rows=3 loops=1)
   Group Key: four, twenty, hundred
   Buffers: shared hit=270
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..287.95 rows=206 width=16) (actual rows=300 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (two = 1) AND (four = ANY ('{1,2,3}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
         Buffers: shared hit=270
(6 rows)

deallocate qual_on_two_not_okay_earlier_on_equality;
-- (September 14) Similar to above, but it's multiple SAOP equalities this time
prepare qual_on_two_multiple_saops as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two in (0, 1) and two in (1, 2)
  and four in (1, 2, 3)
group by two, four, twenty, hundred
order by two, four, twenty, hundred;
execute qual_on_two_multiple_saops;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      21
   100 |   1 |    1 |      1 |      41
   100 |   1 |    1 |      1 |      61
   100 |   1 |    1 |      1 |      81
   100 |   1 |    1 |      5 |       5
   100 |   1 |    1 |      5 |      25
   100 |   1 |    1 |      5 |      45
   100 |   1 |    1 |      5 |      65
   100 |   1 |    1 |      5 |      85
   100 |   1 |    1 |      9 |       9
   100 |   1 |    1 |      9 |      29
   100 |   1 |    1 |      9 |      49
   100 |   1 |    1 |      9 |      69
   100 |   1 |    1 |      9 |      89
   100 |   1 |    1 |     13 |      13
   100 |   1 |    1 |     13 |      33
   100 |   1 |    1 |     13 |      53
   100 |   1 |    1 |     13 |      73
   100 |   1 |    1 |     13 |      93
   100 |   1 |    1 |     17 |      17
   100 |   1 |    1 |     17 |      37
   100 |   1 |    1 |     17 |      57
   100 |   1 |    1 |     17 |      77
   100 |   1 |    1 |     17 |      97
   100 |   1 |    3 |      3 |       3
   100 |   1 |    3 |      3 |      23
   100 |   1 |    3 |      3 |      43
   100 |   1 |    3 |      3 |      63
   100 |   1 |    3 |      3 |      83
   100 |   1 |    3 |      7 |       7
   100 |   1 |    3 |      7 |      27
   100 |   1 |    3 |      7 |      47
   100 |   1 |    3 |      7 |      67
   100 |   1 |    3 |      7 |      87
   100 |   1 |    3 |     11 |      11
   100 |   1 |    3 |     11 |      31
   100 |   1 |    3 |     11 |      51
   100 |   1 |    3 |     11 |      71
   100 |   1 |    3 |     11 |      91
   100 |   1 |    3 |     15 |      15
   100 |   1 |    3 |     15 |      35
   100 |   1 |    3 |     15 |      55
   100 |   1 |    3 |     15 |      75
   100 |   1 |    3 |     15 |      95
   100 |   1 |    3 |     19 |      19
   100 |   1 |    3 |     19 |      39
   100 |   1 |    3 |     19 |      59
   100 |   1 |    3 |     19 |      79
   100 |   1 |    3 |     19 |      99
(50 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_two_multiple_saops;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..763.05 rows=991 width=24) (actual rows=50 loops=1)
   Group Key: two, four, twenty, hundred
   Buffers: shared hit=4374
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..706.28 rows=3749 width=16) (actual rows=5000 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (two = ANY ('{1,2}'::integer[])) AND (four = ANY ('{1,2,3}'::integer[])))
         Buffers: shared hit=4374
(6 rows)

deallocate qual_on_two_multiple_saops;
-- (October 18) Similar to above, but tries to break lack of support for the
-- full set of _bt_preprocess_keys() push-ups in stripped down version of
-- function:
prepare qual_on_two_skew as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two in (0, 1) and four in (1, 2, 3)
  and two in(-1,0)
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22)
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
-- (October 27) UPDATE: we are supposed to get (and do get) 175 buffer hits for this -- not 178
-- buffer hits.
--
-- At one point we got the following superfluous 4 page/buffer accesses at the
-- end of the scan, due to not recognizing that contradictory quals make "two = 1":
--
-- _bt_readpage: 🍀  7 with 12 offsets/tuples (leftsib 6, rightsib 8) ➡️
--  _bt_readpage first: (two, four, twenty, hundred)=(1, 1, 5, 5), 0x7faf243e1d80, from non-pivot offnum 2 TID (0,28) started page
--  _bt_readpage final: (two, four, twenty, hundred)=(1, 1, 13, 33), 0x7faf243e0508, continuescan high key check did not end scan so must continue to right sibling in next _bt_readpage call, if any
--  _bt_readpage stats: currPos.firstItem: 0, currPos.lastItem: -1, nmatching: 0 ❌
-- _bt_readnextpage: ScanDirectionIsForward() case reads right sibling blk 7
-- _bt_readpage: 🍀  8 with 12 offsets/tuples (leftsib 7, rightsib 9) ➡️
--  _bt_readpage first: (two, four, twenty, hundred)=(1, 1, 13, 33), 0x7faf243dfd80, from non-pivot offnum 2 TID (2,5) started page
--  _bt_readpage final: (two, four, twenty, hundred)=(1, 3, 3, 43), 0x7faf243de508, continuescan high key check did not end scan so must continue to right sibling in next _bt_readpage call, if any
--  _bt_readpage stats: currPos.firstItem: 0, currPos.lastItem: -1, nmatching: 0 ❌
-- _bt_readnextpage: ScanDirectionIsForward() case reads right sibling blk 8
-- _bt_readpage: 🍀  9 with 12 offsets/tuples (leftsib 8, rightsib 10) ➡️
--  _bt_readpage first: (two, four, twenty, hundred)=(1, 3, 3, 43), 0x7faf243ddd80, from non-pivot offnum 2 TID (0,10) started page
--  _bt_readpage final: (two, four, twenty, hundred)=(1, 3, 11, 71), 0x7faf243dc508, continuescan high key check did not end scan so must continue to right sibling in next _bt_readpage call, if any
--  _bt_readpage stats: currPos.firstItem: 0, currPos.lastItem: -1, nmatching: 0 ❌
-- _bt_readnextpage: ScanDirectionIsForward() case reads right sibling blk 9
-- _bt_readpage: 🍀  10 with 15 offsets/tuples (leftsib 9, rightsib 0) ➡️
--  _bt_readpage first: (two, four, twenty, hundred)=(1, 3, 11, 71), 0x7faf243b9d80, from non-pivot offnum 1 TID (0,15) started page
--  _bt_readpage final: (two, four, twenty, hundred)=(4999, 0, 0, 0), 0x7faf243b8298, from non-pivot offnum 13 TID (344,25) ended page and scan
--  _bt_readpage stats: currPos.firstItem: 0, currPos.lastItem: -1, nmatching: 0 ❌
-- _bt_readnextpage: ScanDirectionIsForward() case reads right sibling blk 10
--
-- Ultimate fix for this (which made us not do this unnecessary page visits) was to
-- teach _bt_preprocess_array_keys() to merge together arrays related to the
-- same attribute (in this example it's 2 arrays on the attribute named "two"),
-- plus some tweaks to the main _bt_advance_array_keys logic.
execute qual_on_two_skew;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   0 |    2 |      2 |      22
   100 |   0 |    2 |     14 |      14
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 175 buffer hits (not 178)
execute qual_on_two_skew;
                                                                                                                             QUERY PLAN                                                                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..292.41 rows=188 width=24) (actual rows=2 loops=1)
   Group Key: two, four, twenty, hundred
   Buffers: shared hit=175
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..287.95 rows=206 width=16) (actual rows=200 loops=1)
         Index Cond: ((two = ANY ('{0,1}'::integer[])) AND (two = ANY ('{-1,0}'::integer[])) AND (four = ANY ('{1,2,3}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
         Buffers: shared hit=175
(6 rows)

deallocate qual_on_two_skew;
-- (October 26) Similar to above, but lower order (though still SK_BT_REQFWD) scankey "four" this
-- time around:
prepare qual_on_four_skew as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two = 0 and
  -- This is effectively "four in (1,2)" once _bt_preprocess_keys is applied
  -- correctly:
  four in (-1, 0, 1, 2) and
  four in (1, 2, 3, 4, 5)
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute qual_on_four_skew;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   0 |    2 |      2 |       2
   100 |   0 |    2 |      2 |      22
   100 |   0 |    2 |      2 |      42
   100 |   0 |    2 |      2 |      62
   100 |   0 |    2 |      2 |      82
   100 |   0 |    2 |      6 |       6
   100 |   0 |    2 |      6 |      26
   100 |   0 |    2 |      6 |      46
   100 |   0 |    2 |      6 |      66
   100 |   0 |    2 |      6 |      86
   100 |   0 |    2 |     10 |      10
   100 |   0 |    2 |     10 |      30
   100 |   0 |    2 |     10 |      50
   100 |   0 |    2 |     10 |      70
   100 |   0 |    2 |     10 |      90
   100 |   0 |    2 |     14 |      14
   100 |   0 |    2 |     14 |      34
   100 |   0 |    2 |     14 |      54
   100 |   0 |    2 |     14 |      74
   100 |   0 |    2 |     14 |      94
   100 |   0 |    2 |     18 |      18
   100 |   0 |    2 |     18 |      38
   100 |   0 |    2 |     18 |      58
   100 |   0 |    2 |     18 |      78
   100 |   0 |    2 |     18 |      98
(25 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_four_skew;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..714.17 rows=964 width=24) (actual rows=25 loops=1)
   Group Key: four, twenty, hundred
   Buffers: shared hit=2162
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..676.41 rows=2812 width=16) (actual rows=2500 loops=1)
         Index Cond: ((two = 0) AND (four = ANY ('{-1,0,1,2}'::integer[])) AND (four = ANY ('{1,2,3,4,5}'::integer[])))
         Buffers: shared hit=2162
(6 rows)

deallocate qual_on_four_skew;
-- (October 19) Similar to above, but involves non-required scankeys only.
-- This test led to an assertion failure in new _bt_advance_array_keys
-- function.
prepare qual_on_four_nonrequired_skew as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  four in (1, 2, 3)
  and four in (-1, 1, 2, 4)
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22)
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute qual_on_four_nonrequired_skew;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   0 |    2 |      2 |      22
   100 |   0 |    2 |     14 |      14
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      41
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_four_nonrequired_skew;
                                                                                                             QUERY PLAN                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..451.97 rows=188 width=24) (actual rows=4 loops=1)
   Group Key: two, four, twenty, hundred
   Buffers: shared hit=349
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..447.52 rows=206 width=16) (actual rows=400 loops=1)
         Index Cond: ((four = ANY ('{1,2,3}'::integer[])) AND (four = ANY ('{-1,1,2,4}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
         Buffers: shared hit=349
(6 rows)

deallocate qual_on_four_nonrequired_skew;
-- (November 29 2024) Query that uniquely detected skip scan "skipskip"
-- optimization's behavioral change (actually, this is just a refined version
-- of the previous qual_on_four_nonrequired_skew test case, which randomly
-- detected the issue in an overly-coarse manner)
--
-- UPDATE: ultimate conclusion about the issue raised by this test case was
-- that I should make _bt_readpage call _bt_start_array_keys before its
-- finaltup call to _bt_checkkeys.  The underlying issue was confusion
-- stemming from treating the SAOP arrays as non-required in the skipskip
-- context, even though they were generally considered required (and were
-- marked required).
prepare skipskip_skipping_differs as
select two, four, twenty, hundred
from tenk1_dyn_saop
where four = 1 and twenty in (-100000, 5, 13) and hundred in (25, 10000000);
execute skipskip_skipping_differs;
 two | four | twenty | hundred 
-----+------+--------+---------
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
   1 |    1 |      5 |      25
(100 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute skipskip_skipping_differs;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..151.06 rows=2 width=16) (actual rows=100 loops=1)
   Index Cond: ((four = 1) AND (twenty = ANY ('{-100000,5,13}'::integer[])) AND (hundred = ANY ('{25,10000000}'::integer[])))
   Buffers: shared hit=93
(3 rows)

deallocate skipskip_skipping_differs;
-- (November 29 2024) Query that is capable of detecting issues similar to
-- skipskip_skipping_differs, that it won't necessarily detect itself
prepare skipskip_skipping_also_differs as
select two, four, twenty, hundred
from tenk1_dyn_saop
where four = 1 and twenty in (1, 5, 13) and hundred in (1, 14, 34);
execute skipskip_skipping_also_differs;
 two | four | twenty | hundred 
-----+------+--------+---------
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
   1 |    1 |      1 |       1
(100 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute skipskip_skipping_also_differs;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..166.54 rows=11 width=16) (actual rows=100 loops=1)
   Index Cond: ((four = 1) AND (twenty = ANY ('{1,5,13}'::integer[])) AND (hundred = ANY ('{1,14,34}'::integer[])))
   Buffers: shared hit=96
(3 rows)

deallocate skipskip_skipping_also_differs;
-- (February 1) This made a recently written assertion fail when the
-- _bt_check_compare retry for a call to _bt_advance_array_keys that was
-- !sktrigrequired returned false:
--
-- TRAP: failed Assert("sktrigrequired"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 1973, PID: 6849
-- 0   postgres                            0x0000000104c7bf9c ExceptionalCondition + 236
-- 1   postgres                            0x000000010452bb60 _bt_advance_array_keys + 4432
-- 2   postgres                            0x0000000104529cec _bt_checkkeys + 724
-- 3   postgres                            0x000000010451cb4c _bt_readpage + 1616
--
-- (Fix was to move this assertion down slightly, into the
-- "if (!pstate->continuescan)" block)
prepare nonrequired_array_nonrequired_inequality_confusion as
select count(*), two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  four in (1, 2, 3)
  and four in (-1, 1, 2, 4)
  and twenty in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)
  and hundred < 50
group by
  two, four, twenty, hundred
order by
  two, four, twenty, hundred;
execute nonrequired_array_nonrequired_inequality_confusion;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   0 |    2 |      2 |       2
   100 |   0 |    2 |      2 |      22
   100 |   0 |    2 |      2 |      42
   100 |   0 |    2 |      6 |       6
   100 |   0 |    2 |      6 |      26
   100 |   0 |    2 |      6 |      46
   100 |   0 |    2 |     10 |      10
   100 |   0 |    2 |     10 |      30
   100 |   0 |    2 |     14 |      14
   100 |   0 |    2 |     14 |      34
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      21
   100 |   1 |    1 |      1 |      41
   100 |   1 |    1 |      5 |       5
   100 |   1 |    1 |      5 |      25
   100 |   1 |    1 |      5 |      45
   100 |   1 |    1 |      9 |       9
   100 |   1 |    1 |      9 |      29
   100 |   1 |    1 |      9 |      49
   100 |   1 |    1 |     13 |      13
   100 |   1 |    1 |     13 |      33
   100 |   1 |    1 |     17 |      17
   100 |   1 |    1 |     17 |      37
(23 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute nonrequired_array_nonrequired_inequality_confusion;
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..814.35 rows=824 width=24) (actual rows=23 loops=1)
   Group Key: two, four, twenty, hundred
   Buffers: shared hit=1993
   ->  Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=0.29..786.19 rows=1594 width=16) (actual rows=2300 loops=1)
         Index Cond: ((four = ANY ('{1,2,3}'::integer[])) AND (four = ANY ('{-1,1,2,4}'::integer[])) AND (twenty = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}'::integer[])) AND (hundred < 50))
         Buffers: shared hit=1993
(6 rows)

deallocate nonrequired_array_nonrequired_inequality_confusion;
-- (October 27) We expect to be able to detect = as contradictory, provided the
-- redundancy doesn't involve SK_SEARCHARRAY scan keys -- even when there is a
-- SK_SEARCHARRAY scan key nearby.
--
-- (March 10) UPDATE: Actually, we now expect parity with master in all cases,
-- under new regime where _bt_preprocess_keys "operates on arrays directly".
prepare qual_on_two_nonarray_contradictory as
select two, four, twenty, hundred
from
  tenk1_dyn_saop
where
  two in (-1, 0, 1) and four in (1, 2, 3)
  and two in(0, 1, 2)
  and two = (select -1+0.0 offset 0) and two = (select count(*) from pg_operator limit 1)
  and twenty in (1, 2, 5, 7, 8, 11, 12, 13, 14, 17)
  and hundred in (1, 3, 4, 9, 14, 51, 90, 88, 41, 39, 22);
execute qual_on_two_nonarray_contradictory;
 two | four | twenty | hundred 
-----+------+--------+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute qual_on_two_nonarray_contradictory;
                                                                                                                                           QUERY PLAN                                                                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using tenk1_dyn_saop_idx_lowcard on tenk1_dyn_saop  (cost=24.29..143.82 rows=1 width=16) (actual rows=0 loops=1)
   Index Cond: ((two = ANY ('{-1,0,1}'::integer[])) AND (two = ANY ('{0,1,2}'::integer[])) AND (two = (InitPlan 2).col1) AND (four = ANY ('{1,2,3}'::integer[])) AND (twenty = ANY ('{1,2,5,7,8,11,12,13,14,17}'::integer[])) AND (hundred = ANY ('{1,3,4,9,14,51,90,88,41,39,22}'::integer[])))
   Filter: ((two)::numeric = (InitPlan 1).col1)
   Buffers: shared hit=14
   InitPlan 1
     ->  Result  (cost=0.00..0.01 rows=1 width=32) (never executed)
   InitPlan 2
     ->  Limit  (cost=23.99..24.00 rows=1 width=8) (actual rows=1 loops=1)
           Buffers: shared hit=14
           ->  Aggregate  (cost=23.99..24.00 rows=1 width=8) (actual rows=1 loops=1)
                 Buffers: shared hit=14
                 ->  Seq Scan on pg_operator  (cost=0.00..21.99 rows=799 width=0) (actual rows=799 loops=1)
                       Disabled: true
                       Buffers: shared hit=14
(14 rows)

deallocate qual_on_two_nonarray_contradictory;
-----------------------------------------
-- functional_dependencies test cases  --
-----------------------------------------
set client_min_messages=error;
drop table if exists functional_dependencies;
reset client_min_messages;
CREATE UNLOGGED TABLE functional_dependencies (
    filler1 TEXT,
    filler2 NUMERIC,
    a INT,
    b TEXT,
    filler3 DATE,
    c INT,
    d TEXT
);
CREATE INDEX fdeps_abc_idx ON functional_dependencies (a, b, c);
-- prewarm
select count(*) from functional_dependencies;
 count 
-------
     0
(1 row)

vacuum analyze functional_dependencies;
INSERT INTO functional_dependencies (a, b, c, filler1)
     SELECT mod(i,100), mod(i,50), mod(i,25), i FROM generate_series(1,5000) s(i);
-----------------------------------------
-- Test case from regression tests that failed with binary-search-saop-array
-- work, even when all other tests in this file passed:
SELECT count(*) FROM functional_dependencies WHERE a IN (1, 51) AND b IN ('1', '2');
 count 
-------
   100
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
SELECT count(*) FROM functional_dependencies WHERE a IN (1, 51) AND b IN ('1', '2');
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=8.88..8.88 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=66
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..8.87 rows=1 width=0) (actual rows=100 loops=1)
         Index Cond: ((a = ANY ('{1,51}'::integer[])) AND (b = ANY ('{1,2}'::text[])))
         Buffers: shared hit=66
(5 rows)

select count(*) from functional_dependencies
where
  a in (1, 2, 26, 27, 51, 52, 76, 77)
  and b in ('1', '2', '26', '27')
  and c in (1, 2);
 count 
-------
   400
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from functional_dependencies
where
  a in (1, 2, 26, 27, 51, 52, 76, 77)
  and b in ('1', '2', '26', '27')
  and c in (1, 2);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=8.88..8.89 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=256
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..8.88 rows=1 width=0) (actual rows=400 loops=1)
         Index Cond: ((a = ANY ('{1,2,26,27,51,52,76,77}'::integer[])) AND (b = ANY ('{1,2,26,27}'::text[])) AND (c = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=256
(5 rows)

-- Test case for missing key column in predicate -- simple
prepare functional_dependencies_norequired_one as
select count(*), a, b, c
from
  functional_dependencies
where a = 25 and c in (0, 1, 2, 3)
group by a, b, c;
execute functional_dependencies_norequired_one;
 count | a  | b  | c 
-------+----+----+---
    50 | 25 | 25 | 0
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_one;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..4.38 rows=1 width=48) (actual rows=1 loops=1)
   Group Key: b, c
   Buffers: shared hit=33
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..4.36 rows=1 width=40) (actual rows=50 loops=1)
         Index Cond: ((a = 25) AND (c = ANY ('{0,1,2,3}'::integer[])))
         Buffers: shared hit=33
(6 rows)

deallocate functional_dependencies_norequired_one;
-- Test case for missing key column in predicate -- must skip 14 and match on
-- 15 here, slightly trickier
prepare functional_dependencies_norequired_two as
select count(*), a, b, c
from
  functional_dependencies
where a = 65 and c in (14, 15)
group by a, b, c;
execute functional_dependencies_norequired_two;
 count | a  | b  | c  
-------+----+----+----
    50 | 65 | 15 | 15
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_two;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..4.38 rows=1 width=48) (actual rows=1 loops=1)
   Group Key: b, c
   Buffers: shared hit=33
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..4.36 rows=1 width=40) (actual rows=50 loops=1)
         Index Cond: ((a = 65) AND (c = ANY ('{14,15}'::integer[])))
         Buffers: shared hit=33
(6 rows)

deallocate functional_dependencies_norequired_two;
-- Skip to different parts of index for each of 44, 94:
prepare functional_dependencies_norequired_three as
select count(*), a, b, c
from
  functional_dependencies
  where a in (44,94) and c in (18,19,20)
  group by a, b, c;
execute functional_dependencies_norequired_three;
 count | a  | b  | c  
-------+----+----+----
    50 | 44 | 44 | 19
    50 | 94 | 44 | 19
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_three;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..6.72 rows=1 width=48) (actual rows=2 loops=1)
   Group Key: a, b, c
   Buffers: shared hit=66
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..6.70 rows=1 width=40) (actual rows=100 loops=1)
         Index Cond: ((a = ANY ('{44,94}'::integer[])) AND (c = ANY ('{18,19,20}'::integer[])))
         Buffers: shared hit=66
(6 rows)

deallocate functional_dependencies_norequired_three;
prepare functional_dependencies_norequired_four as
select count(*), a, b, c
from
  functional_dependencies
where
  a = any (array[1, 51])
  and b = '1'
group by a, b, c;
execute functional_dependencies_norequired_four;
 count | a  | b | c 
-------+----+---+---
    50 |  1 | 1 | 1
    50 | 51 | 1 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_four;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..6.60 rows=1 width=48) (actual rows=2 loops=1)
   Group Key: a, c
   Buffers: shared hit=66
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..6.58 rows=1 width=40) (actual rows=100 loops=1)
         Index Cond: ((a = ANY ('{1,51}'::integer[])) AND (b = '1'::text))
         Buffers: shared hit=66
(6 rows)

deallocate functional_dependencies_norequired_four;
prepare functional_dependencies_norequired_five as
select count(*), a, b, c
from
  functional_dependencies
where
  a = any (array[1, 26, 51, 76])
  and b = any (array['1', '26'])
  and c = 1
group by a, b, c;
execute functional_dependencies_norequired_five;
 count | a  | b  | c 
-------+----+----+---
    50 |  1 | 1  | 1
    50 | 26 | 26 | 1
    50 | 51 | 1  | 1
    50 | 76 | 26 | 1
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_five;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..8.90 rows=1 width=48) (actual rows=4 loops=1)
   Group Key: a, b
   Buffers: shared hit=132
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..8.88 rows=1 width=40) (actual rows=200 loops=1)
         Index Cond: ((a = ANY ('{1,26,51,76}'::integer[])) AND (b = ANY ('{1,26}'::text[])) AND (c = 1))
         Buffers: shared hit=132
(6 rows)

deallocate functional_dependencies_norequired_five;
prepare functional_dependencies_norequired_six as
select count(*), a, b, c
from
  functional_dependencies
where
  a in (1, 2, 51, 52) and b = '1'
group by a, b, c;
execute functional_dependencies_norequired_six;
 count | a  | b | c 
-------+----+---+---
    50 |  1 | 1 | 1
    50 | 51 | 1 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_six;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..8.89 rows=1 width=48) (actual rows=2 loops=1)
   Group Key: a, c
   Buffers: shared hit=66
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..8.87 rows=1 width=40) (actual rows=100 loops=1)
         Index Cond: ((a = ANY ('{1,2,51,52}'::integer[])) AND (b = '1'::text))
         Buffers: shared hit=66
(6 rows)

deallocate functional_dependencies_norequired_six;
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Now do backwards scan equivalents of all functional_dependencies tests:
select a, b, c from functional_dependencies
where
  a in (1, 2, 26, 27, 51, 52, 76, 77)
  and b in ('1', '2', '26', '27')
  and c in (1, 2)
order by a desc, b desc, c desc limit 52;
 a  | b  | c 
----+----+---
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 77 | 27 | 2
 76 | 26 | 1
 76 | 26 | 1
(52 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b, c from functional_dependencies
where
  a in (1, 2, 26, 27, 51, 52, 76, 77)
  and b in ('1', '2', '26', '27')
  and c in (1, 2)
order by a desc, b desc, c desc limit 52;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.28..8.88 rows=1 width=40) (actual rows=52 loops=1)
   Buffers: shared hit=34
   ->  Index Scan Backward using fdeps_abc_idx on functional_dependencies  (cost=0.28..8.88 rows=1 width=40) (actual rows=52 loops=1)
         Index Cond: ((a = ANY ('{1,2,26,27,51,52,76,77}'::integer[])) AND (b = ANY ('{1,2,26,27}'::text[])) AND (c = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=34
(5 rows)

-- Test case for missing key column in predicate -- simple
prepare functional_dependencies_norequired_one_desc as
select count(*), a, b, c
from
  functional_dependencies
where a = 25 and c in (0, 1, 2, 3)
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_one_desc;
 count | a  | b  | c 
-------+----+----+---
    50 | 25 | 25 | 0
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_one_desc;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..4.38 rows=1 width=48) (actual rows=1 loops=1)
   Group Key: b, c
   Buffers: shared hit=33
   ->  Index Scan Backward using fdeps_abc_idx on functional_dependencies  (cost=0.28..4.36 rows=1 width=40) (actual rows=50 loops=1)
         Index Cond: ((a = 25) AND (c = ANY ('{0,1,2,3}'::integer[])))
         Buffers: shared hit=33
(6 rows)

deallocate functional_dependencies_norequired_one_desc;
-- Test case for missing key column in predicate -- must skip 14 and match on
-- 15 here, slightly trickier
prepare functional_dependencies_norequired_two_desc as
select count(*), a, b, c
from
  functional_dependencies
where a = 65 and c in (14, 15)
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_two_desc;
 count | a  | b  | c  
-------+----+----+----
    50 | 65 | 15 | 15
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_two_desc;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..4.38 rows=1 width=48) (actual rows=1 loops=1)
   Group Key: b, c
   Buffers: shared hit=34
   ->  Index Scan Backward using fdeps_abc_idx on functional_dependencies  (cost=0.28..4.36 rows=1 width=40) (actual rows=50 loops=1)
         Index Cond: ((a = 65) AND (c = ANY ('{14,15}'::integer[])))
         Buffers: shared hit=34
(6 rows)

deallocate functional_dependencies_norequired_two_desc;
-- Skip to different parts of index for each of 44, 94:
prepare functional_dependencies_norequired_three_desc as
select count(*), a, b, c
from
  functional_dependencies
  where a in (44,94) and c in (18,19,20)
  group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_three_desc;
 count | a  | b  | c  
-------+----+----+----
    50 | 94 | 44 | 19
    50 | 44 | 44 | 19
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_three_desc;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..6.72 rows=1 width=48) (actual rows=2 loops=1)
   Group Key: a, b, c
   Buffers: shared hit=67
   ->  Index Scan Backward using fdeps_abc_idx on functional_dependencies  (cost=0.28..6.70 rows=1 width=40) (actual rows=100 loops=1)
         Index Cond: ((a = ANY ('{44,94}'::integer[])) AND (c = ANY ('{18,19,20}'::integer[])))
         Buffers: shared hit=67
(6 rows)

deallocate functional_dependencies_norequired_three_desc;
prepare functional_dependencies_norequired_four_desc as
select count(*), a, b, c
from
  functional_dependencies
where
  a = any (array[1, 51])
  and b = '1'
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_four_desc;
 count | a  | b | c 
-------+----+---+---
    50 | 51 | 1 | 1
    50 |  1 | 1 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_four_desc;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..6.60 rows=1 width=48) (actual rows=2 loops=1)
   Group Key: a, c
   Buffers: shared hit=66
   ->  Index Scan Backward using fdeps_abc_idx on functional_dependencies  (cost=0.28..6.58 rows=1 width=40) (actual rows=100 loops=1)
         Index Cond: ((a = ANY ('{1,51}'::integer[])) AND (b = '1'::text))
         Buffers: shared hit=66
(6 rows)

deallocate functional_dependencies_norequired_four_desc;
prepare functional_dependencies_norequired_five_desc as
select count(*), a, b, c
from
  functional_dependencies
where
  a = any (array[1, 26, 51, 76])
  and b = any (array['1', '26'])
  and c = 1
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_five_desc;
 count | a  | b  | c 
-------+----+----+---
    50 | 76 | 26 | 1
    50 | 51 | 1  | 1
    50 | 26 | 26 | 1
    50 |  1 | 1  | 1
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_five_desc;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..8.90 rows=1 width=48) (actual rows=4 loops=1)
   Group Key: a, b
   Buffers: shared hit=131
   ->  Index Scan Backward using fdeps_abc_idx on functional_dependencies  (cost=0.28..8.88 rows=1 width=40) (actual rows=200 loops=1)
         Index Cond: ((a = ANY ('{1,26,51,76}'::integer[])) AND (b = ANY ('{1,26}'::text[])) AND (c = 1))
         Buffers: shared hit=131
(6 rows)

deallocate functional_dependencies_norequired_five_desc;
prepare functional_dependencies_norequired_six_desc as
select count(*), a, b, c
from
  functional_dependencies
where
  a in (1, 2, 51, 52) and b = '1'
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_six_desc;
 count | a  | b | c 
-------+----+---+---
    50 | 51 | 1 | 1
    50 |  1 | 1 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_six_desc;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..8.89 rows=1 width=48) (actual rows=2 loops=1)
   Group Key: a, c
   Buffers: shared hit=66
   ->  Index Scan Backward using fdeps_abc_idx on functional_dependencies  (cost=0.28..8.87 rows=1 width=40) (actual rows=100 loops=1)
         Index Cond: ((a = ANY ('{1,2,51,52}'::integer[])) AND (b = '1'::text))
         Buffers: shared hit=66
(6 rows)

deallocate functional_dependencies_norequired_six_desc;
-- (February 22)
--
-- Assertion failure due to non-required scan key not starting from the first
-- array element (for current scan direction) after _bt_preprocess_keys was
-- done:
prepare functional_dependencies_norequired_no_first_elem as
select count(*), a, b, c
from
  functional_dependencies
where
  a in (1,2) and c in (1,2,3) and c = 2
group by a, b, c;
-- Original assertion failure:
--
-- TRAP: failed Assert("_bt_verify_arrays_bt_first(scan, dir)"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 2776, PID: 513412
-- [0x556451e17798] _bt_preprocess_keys: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtutils.c:2776
-- [0x556451e0e646] _bt_first: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtsearch.c:1181
-- [0x556451e0b0da] btgettuple: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtree.c:290
--
-- Fix for this was to move the assertion into _bt_array_keys_remain, where
-- _bt_preprocess_keys incremental advancement cannot break things.
execute functional_dependencies_norequired_no_first_elem;
 count | a | b | c 
-------+---+---+---
    50 | 2 | 2 | 2
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_no_first_elem;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..6.76 rows=1 width=48) (actual rows=1 loops=1)
   Group Key: a, b
   Buffers: shared hit=33
   ->  Index Scan using fdeps_abc_idx on functional_dependencies  (cost=0.28..6.74 rows=1 width=40) (actual rows=50 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (c = ANY ('{1,2,3}'::integer[])) AND (c = 2))
         Buffers: shared hit=33
(6 rows)

deallocate functional_dependencies_norequired_no_first_elem;
------------------------------------------------
-- functional_dependencies random test cases  --
------------------------------------------------
set client_min_messages=error;
drop table if exists functional_dependencies_random;
reset client_min_messages;
CREATE UNLOGGED TABLE functional_dependencies_random (
    filler1 TEXT,
    filler2 NUMERIC,
    a INT,
    b TEXT,
    filler3 DATE,
    c INT,
    d TEXT
);
CREATE INDEX fdeps_abc_random_idx ON functional_dependencies_random (a, b, c);
INSERT INTO functional_dependencies_random (a, b, c, filler1)
     SELECT mod(i, 5), mod(i, 7), mod(i, 11), i FROM generate_series(1,1000) s(i);
-- prewarm
select count(*) from functional_dependencies_random;
 count 
-------
  1000
(1 row)

vacuum analyze functional_dependencies_random;
SELECT count(*) FROM functional_dependencies_random WHERE a IN (1, 51) AND b IN ('1', '2');
 count 
-------
    58
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
SELECT count(*) FROM functional_dependencies_random  WHERE a IN (1, 51) AND b IN ('1', '2');
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=17.62..17.63 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=62
   ->  Index Scan using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..17.48 rows=57 width=0) (actual rows=58 loops=1)
         Index Cond: ((a = ANY ('{1,51}'::integer[])) AND (b = ANY ('{1,2}'::text[])))
         Buffers: shared hit=62
(5 rows)

select count(*) from functional_dependencies_random
where
  a in (1, 2, 26, 27, 51, 52, 76, 77)
  and b in ('1', '2', '26', '27')
  and c in (1, 2);
 count 
-------
    22
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from functional_dependencies_random
where
  a in (1, 2, 26, 27, 51, 52, 76, 77)
  and b in ('1', '2', '26', '27')
  and c in (1, 2);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=16.84..16.85 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=27
   ->  Index Scan using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..16.79 rows=21 width=0) (actual rows=22 loops=1)
         Index Cond: ((a = ANY ('{1,2,26,27,51,52,76,77}'::integer[])) AND (b = ANY ('{1,2,26,27}'::text[])) AND (c = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=27
(5 rows)

-- Test case for missing key column in predicate -- simple
prepare functional_dependencies_norequired_one_random as
select count(*), a, b, c
from
  functional_dependencies_random
where a = 25 and c in (0, 1, 2, 3)
group by a, b, c;
execute functional_dependencies_norequired_one_random;
 count | a | b | c 
-------+---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_one_random;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..4.27 rows=1 width=18) (actual rows=0 loops=1)
   Group Key: b, c
   Buffers: shared hit=2
   ->  Index Scan using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..4.25 rows=1 width=10) (actual rows=0 loops=1)
         Index Cond: ((a = 25) AND (c = ANY ('{0,1,2,3}'::integer[])))
         Buffers: shared hit=2
(6 rows)

deallocate functional_dependencies_norequired_one_random;
-- Test case for missing key column in predicate -- must skip 14 and match on
-- 15 here, slightly trickier
prepare functional_dependencies_norequired_two_random as
select count(*), a, b, c
from
  functional_dependencies_random
where a = 65 and c in (14, 15)
group by a, b, c;
execute functional_dependencies_norequired_two_random;
 count | a | b | c 
-------+---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_two_random;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..4.27 rows=1 width=18) (actual rows=0 loops=1)
   Group Key: b, c
   Buffers: shared hit=2
   ->  Index Scan using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..4.25 rows=1 width=10) (actual rows=0 loops=1)
         Index Cond: ((a = 65) AND (c = ANY ('{14,15}'::integer[])))
         Buffers: shared hit=2
(6 rows)

deallocate functional_dependencies_norequired_two_random;
-- Skip to different parts of index for each of 44, 94:
prepare functional_dependencies_norequired_three_random as
select count(*), a, b, c
from
  functional_dependencies_random
  where a in (44,94) and c in (18,19,20)
  group by a, b, c;
execute functional_dependencies_norequired_three_random;
 count | a | b | c 
-------+---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_three_random;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..6.56 rows=1 width=18) (actual rows=0 loops=1)
   Group Key: a, b, c
   Buffers: shared hit=2
   ->  Index Scan using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..6.54 rows=1 width=10) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{44,94}'::integer[])) AND (c = ANY ('{18,19,20}'::integer[])))
         Buffers: shared hit=2
(6 rows)

deallocate functional_dependencies_norequired_three_random;
prepare functional_dependencies_norequired_four_random as
select count(*), a, b, c
from
  functional_dependencies_random
where
  a = any (array[1, 51])
  and b = '1'
group by a, b, c;
execute functional_dependencies_norequired_four_random;
 count | a | b | c  
-------+---+---+----
     3 | 1 | 1 |  0
     3 | 1 | 1 |  1
     3 | 1 | 1 |  2
     3 | 1 | 1 |  3
     2 | 1 | 1 |  4
     3 | 1 | 1 |  5
     2 | 1 | 1 |  6
     3 | 1 | 1 |  7
     2 | 1 | 1 |  8
     3 | 1 | 1 |  9
     2 | 1 | 1 | 10
(11 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_four_random;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..17.34 rows=23 width=18) (actual rows=11 loops=1)
   Group Key: a, c
   Buffers: shared hit=33
   ->  Index Scan using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..16.90 rows=29 width=10) (actual rows=29 loops=1)
         Index Cond: ((a = ANY ('{1,51}'::integer[])) AND (b = '1'::text))
         Buffers: shared hit=33
(6 rows)

deallocate functional_dependencies_norequired_four_random;
prepare functional_dependencies_norequired_five_random as
select count(*), a, b, c
from
  functional_dependencies_random
where
  a = any (array[1, 26, 51, 76])
  and b = any (array['1', '26'])
  and c = 1
group by a, b, c;
execute functional_dependencies_norequired_five_random;
 count | a | b | c 
-------+---+---+---
     3 | 1 | 1 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_five_random;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..10.57 rows=3 width=18) (actual rows=1 loops=1)
   Group Key: a, b
   Buffers: shared hit=7
   ->  Index Scan using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..10.52 rows=3 width=10) (actual rows=3 loops=1)
         Index Cond: ((a = ANY ('{1,26,51,76}'::integer[])) AND (b = ANY ('{1,26}'::text[])) AND (c = 1))
         Buffers: shared hit=7
(6 rows)

deallocate functional_dependencies_norequired_five_random;
prepare functional_dependencies_norequired_six_random as
select count(*), a, b, c
from
  functional_dependencies_random
where
  a in (1, 2, 51, 52) and b = '1'
group by a, b, c;
execute functional_dependencies_norequired_six_random;
 count | a | b | c  
-------+---+---+----
     3 | 1 | 1 |  0
     3 | 1 | 1 |  1
     3 | 1 | 1 |  2
     3 | 1 | 1 |  3
     2 | 1 | 1 |  4
     3 | 1 | 1 |  5
     2 | 1 | 1 |  6
     3 | 1 | 1 |  7
     2 | 1 | 1 |  8
     3 | 1 | 1 |  9
     2 | 1 | 1 | 10
     3 | 2 | 1 |  0
     2 | 2 | 1 |  1
     3 | 2 | 1 |  2
     2 | 2 | 1 |  3
     3 | 2 | 1 |  4
     2 | 2 | 1 |  5
     3 | 2 | 1 |  6
     2 | 2 | 1 |  7
     3 | 2 | 1 |  8
     2 | 2 | 1 |  9
     3 | 2 | 1 | 10
(22 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_six_random;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..18.26 rows=36 width=18) (actual rows=22 loops=1)
   Group Key: a, c
   Buffers: shared hit=62
   ->  Index Scan using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..17.48 rows=57 width=10) (actual rows=57 loops=1)
         Index Cond: ((a = ANY ('{1,2,51,52}'::integer[])) AND (b = '1'::text))
         Buffers: shared hit=62
(6 rows)

deallocate functional_dependencies_norequired_six_random;
select a, b, c from functional_dependencies_random
where
  a in (1, 2, 26, 27, 51, 52, 76, 77)
  and b in ('1', '2', '26', '27')
  and c in (1, 2)
order by a desc, b desc, c desc limit 52;
 a | b | c 
---+---+---
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 2
 2 | 2 | 1
 2 | 2 | 1
 2 | 2 | 1
 2 | 1 | 2
 2 | 1 | 2
 2 | 1 | 2
 2 | 1 | 1
 2 | 1 | 1
 1 | 2 | 2
 1 | 2 | 2
 1 | 2 | 2
 1 | 2 | 1
 1 | 2 | 1
 1 | 1 | 2
 1 | 1 | 2
 1 | 1 | 2
 1 | 1 | 1
 1 | 1 | 1
 1 | 1 | 1
(22 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b, c from functional_dependencies_random
where
  a in (1, 2, 26, 27, 51, 52, 76, 77)
  and b in ('1', '2', '26', '27')
  and c in (1, 2)
order by a desc, b desc, c desc limit 52;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.28..16.79 rows=21 width=10) (actual rows=22 loops=1)
   Buffers: shared hit=28
   ->  Index Scan Backward using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..16.79 rows=21 width=10) (actual rows=22 loops=1)
         Index Cond: ((a = ANY ('{1,2,26,27,51,52,76,77}'::integer[])) AND (b = ANY ('{1,2,26,27}'::text[])) AND (c = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=28
(5 rows)

-- Test case for missing key column in predicate -- simple
prepare functional_dependencies_norequired_one_desc_random as
select count(*), a, b, c
from
  functional_dependencies_random
where a = 25 and c in (0, 1, 2, 3)
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_one_desc_random;
 count | a | b | c 
-------+---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_one_desc_random;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..4.27 rows=1 width=18) (actual rows=0 loops=1)
   Group Key: b, c
   Buffers: shared hit=2
   ->  Index Scan Backward using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..4.25 rows=1 width=10) (actual rows=0 loops=1)
         Index Cond: ((a = 25) AND (c = ANY ('{0,1,2,3}'::integer[])))
         Buffers: shared hit=2
(6 rows)

deallocate functional_dependencies_norequired_one_desc_random;
prepare functional_dependencies_norequired_two_desc_random as
select count(*), a, b, c
from
  functional_dependencies_random
where a = 65 and c in (14, 15)
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_two_desc_random;
 count | a | b | c 
-------+---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_two_desc_random;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..4.27 rows=1 width=18) (actual rows=0 loops=1)
   Group Key: b, c
   Buffers: shared hit=2
   ->  Index Scan Backward using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..4.25 rows=1 width=10) (actual rows=0 loops=1)
         Index Cond: ((a = 65) AND (c = ANY ('{14,15}'::integer[])))
         Buffers: shared hit=2
(6 rows)

deallocate functional_dependencies_norequired_two_desc_random;
-- Skip to different parts of index for each of 44, 94:
prepare functional_dependencies_norequired_three_desc_random as
select count(*), a, b, c
from
  functional_dependencies_random
  where a in (44,94) and c in (18,19,20)
  group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_three_desc_random;
 count | a | b | c 
-------+---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_three_desc_random;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..6.56 rows=1 width=18) (actual rows=0 loops=1)
   Group Key: a, b, c
   Buffers: shared hit=2
   ->  Index Scan Backward using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..6.54 rows=1 width=10) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{44,94}'::integer[])) AND (c = ANY ('{18,19,20}'::integer[])))
         Buffers: shared hit=2
(6 rows)

deallocate functional_dependencies_norequired_three_desc_random;
prepare functional_dependencies_norequired_four_desc_random as
select count(*), a, b, c
from
  functional_dependencies_random
where
  a = any (array[1, 51])
  and b = '1'
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_four_desc_random;
 count | a | b | c  
-------+---+---+----
     2 | 1 | 1 | 10
     3 | 1 | 1 |  9
     2 | 1 | 1 |  8
     3 | 1 | 1 |  7
     2 | 1 | 1 |  6
     3 | 1 | 1 |  5
     2 | 1 | 1 |  4
     3 | 1 | 1 |  3
     3 | 1 | 1 |  2
     3 | 1 | 1 |  1
     3 | 1 | 1 |  0
(11 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_four_desc_random;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..17.34 rows=23 width=18) (actual rows=11 loops=1)
   Group Key: a, c
   Buffers: shared hit=33
   ->  Index Scan Backward using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..16.90 rows=29 width=10) (actual rows=29 loops=1)
         Index Cond: ((a = ANY ('{1,51}'::integer[])) AND (b = '1'::text))
         Buffers: shared hit=33
(6 rows)

deallocate functional_dependencies_norequired_four_desc_random;
prepare functional_dependencies_norequired_five_desc_random as
select count(*), a, b, c
from
  functional_dependencies_random
where
  a = any (array[1, 26, 51, 76])
  and b = any (array['1', '26'])
  and c = 1
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_five_desc_random;
 count | a | b | c 
-------+---+---+---
     3 | 1 | 1 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_five_desc_random;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..10.57 rows=3 width=18) (actual rows=1 loops=1)
   Group Key: a, b
   Buffers: shared hit=7
   ->  Index Scan Backward using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..10.52 rows=3 width=10) (actual rows=3 loops=1)
         Index Cond: ((a = ANY ('{1,26,51,76}'::integer[])) AND (b = ANY ('{1,26}'::text[])) AND (c = 1))
         Buffers: shared hit=7
(6 rows)

deallocate functional_dependencies_norequired_five_desc_random;
prepare functional_dependencies_norequired_six_desc_random as
select count(*), a, b, c
from
  functional_dependencies_random
where
  a in (1, 2, 51, 52) and b = '1'
group by a, b, c
order by a desc, b desc, c desc;
execute functional_dependencies_norequired_six_desc_random;
 count | a | b | c  
-------+---+---+----
     3 | 2 | 1 | 10
     2 | 2 | 1 |  9
     3 | 2 | 1 |  8
     2 | 2 | 1 |  7
     3 | 2 | 1 |  6
     2 | 2 | 1 |  5
     3 | 2 | 1 |  4
     2 | 2 | 1 |  3
     3 | 2 | 1 |  2
     2 | 2 | 1 |  1
     3 | 2 | 1 |  0
     2 | 1 | 1 | 10
     3 | 1 | 1 |  9
     2 | 1 | 1 |  8
     3 | 1 | 1 |  7
     2 | 1 | 1 |  6
     3 | 1 | 1 |  5
     2 | 1 | 1 |  4
     3 | 1 | 1 |  3
     3 | 1 | 1 |  2
     3 | 1 | 1 |  1
     3 | 1 | 1 |  0
(22 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute functional_dependencies_norequired_six_desc_random;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.28..18.26 rows=36 width=18) (actual rows=22 loops=1)
   Group Key: a, c
   Buffers: shared hit=63
   ->  Index Scan Backward using fdeps_abc_random_idx on functional_dependencies_random  (cost=0.28..17.48 rows=57 width=10) (actual rows=57 loops=1)
         Index Cond: ((a = ANY ('{1,2,51,52}'::integer[])) AND (b = '1'::text))
         Buffers: shared hit=63
(6 rows)

deallocate functional_dependencies_norequired_six_desc_random;
---------------------------------------------------------------------------------
-- Don't accidentally scan way too many leaf pages rather than re-descend tree --
---------------------------------------------------------------------------------
--
-- UPDATE: (October 21) This variant of redescend_test was discovered by random chance
-- when you stressed the implementation by varying BTREE_DEFAULT_FILLFACTOR.
--
-- Apparently wraparound during backwards scans results in buggy
-- behavior/confusion when the scan direction changes.
--
-- UPDATE: (October 28) This bug was related to wraparound from incremental
-- advancement of array keys.  Recall that every form of what you could call array
-- wraparound (including during incremental advancement of array keys) has
-- since been removed.
--
-- UPDATE: (November 5) Recall that you originally had a separate test case
-- that minimally reproduced the wraparound bug by duplicating the start of
-- this test, but with fillfactor=30.  Today you decided to remove the smaller
-- test, and just use fillfactor=30 here, for the full test suite.
--
-- This decision was based on the fact that one of the later fetches from
-- cursor would fail a newly added assertion verifying agreement between input and
-- output scan keys, which wouldn't have been caught had I not randomly
-- decided to recheck what happened when I once again lowered fillfactor for
-- this test.  (The other factor that led to changing the tests like this was
-- the total lack of evidence that having independent coverage for default
-- fillfactor=90 had any independent benefit.  Plus it saved test cycles.)
set client_min_messages=error;
drop table if exists redescend_test;
reset client_min_messages;
create unlogged table redescend_test (district int4, warehouse int4, orderid int4, orderline int4);
create index must_not_full_scan on redescend_test (district, warehouse, orderid, orderline) with (fillfactor=30);
insert into redescend_test
select district, warehouse, orderid, orderline
from
  generate_series(1, 3) district,
  generate_series(1, 5) warehouse,
  generate_series(1, 150) orderid,
  generate_series(1, 10) orderline
order by
district, warehouse, orderid, orderline;
-- prewarm
select count(*) from redescend_test;
 count 
-------
 22500
(1 row)

vacuum analyze redescend_test;
---------------------------------------------------------------------------------
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Our goal here (and the only reasonable approach that's possible given all
-- the specifics) is to be at parity with the master branch, index-buffer-hit-wise.
select ctid, * from redescend_test where district in (1,2,3) and warehouse = 5 and orderid = 22;
   ctid    | district | warehouse | orderid | orderline 
-----------+----------+-----------+---------+-----------
 (33,106)  |        1 |         5 |      22 |         1
 (33,107)  |        1 |         5 |      22 |         2
 (33,108)  |        1 |         5 |      22 |         3
 (33,109)  |        1 |         5 |      22 |         4
 (33,110)  |        1 |         5 |      22 |         5
 (33,111)  |        1 |         5 |      22 |         6
 (33,112)  |        1 |         5 |      22 |         7
 (33,113)  |        1 |         5 |      22 |         8
 (33,114)  |        1 |         5 |      22 |         9
 (33,115)  |        1 |         5 |      22 |        10
 (74,21)   |        2 |         5 |      22 |         1
 (74,22)   |        2 |         5 |      22 |         2
 (74,23)   |        2 |         5 |      22 |         3
 (74,24)   |        2 |         5 |      22 |         4
 (74,25)   |        2 |         5 |      22 |         5
 (74,26)   |        2 |         5 |      22 |         6
 (74,27)   |        2 |         5 |      22 |         7
 (74,28)   |        2 |         5 |      22 |         8
 (74,29)   |        2 |         5 |      22 |         9
 (74,30)   |        2 |         5 |      22 |        10
 (114,121) |        3 |         5 |      22 |         1
 (114,122) |        3 |         5 |      22 |         2
 (114,123) |        3 |         5 |      22 |         3
 (114,124) |        3 |         5 |      22 |         4
 (114,125) |        3 |         5 |      22 |         5
 (114,126) |        3 |         5 |      22 |         6
 (114,127) |        3 |         5 |      22 |         7
 (114,128) |        3 |         5 |      22 |         8
 (114,129) |        3 |         5 |      22 |         9
 (114,130) |        3 |         5 |      22 |        10
(30 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from redescend_test where district in (1,2,3) and warehouse = 5 and orderid = 22;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=7.13..39.43 rows=21 width=22) (actual rows=30 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse = 5) AND (orderid = 22))
   Heap Blocks: exact=3
   Buffers: shared hit=9
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..7.12 rows=21 width=0) (actual rows=30 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse = 5) AND (orderid = 22))
         Buffers: shared hit=6
(7 rows)

--
-- Page 75 (from index 'must_not_full_scan') high key looks like this:
-- (district, warehouse, orderid, orderline)=(3, 3, 125)
--
-- This provides us with "NULL > NOT_NULL" coverage, which led to assertion
-- failure because this is a forward scan, contrary to my expectations:
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,124,125) and orderline is null;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,124,125) and orderline is null; -- 2 buffer hits
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=6.91..8.93 rows=1 width=16) (actual rows=0 loops=1)
   Recheck Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,124,125}'::integer[])) AND (orderline IS NULL))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..6.91 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,124,125}'::integer[])) AND (orderline IS NULL))
         Buffers: shared hit=2
(6 rows)

-- This should only need 2 buffer hits:
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,124) and orderline > 1000;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,124) and orderline > 1000; -- 2 buffer hits
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=4.61..6.63 rows=1 width=16) (actual rows=0 loops=1)
   Recheck Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,124}'::integer[])) AND (orderline > 1000))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..4.61 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,124}'::integer[])) AND (orderline > 1000))
         Buffers: shared hit=2
(6 rows)

-- This should also only need 2 buffer hits:
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,124) and orderline < 1000;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         3 |     121 |         1
        3 |         3 |     121 |         2
        3 |         3 |     121 |         3
        3 |         3 |     121 |         4
        3 |         3 |     121 |         5
        3 |         3 |     121 |         6
        3 |         3 |     121 |         7
        3 |         3 |     121 |         8
        3 |         3 |     121 |         9
        3 |         3 |     121 |        10
        3 |         3 |     124 |         1
        3 |         3 |     124 |         2
        3 |         3 |     124 |         3
        3 |         3 |     124 |         4
        3 |         3 |     124 |         5
        3 |         3 |     124 |         6
        3 |         3 |     124 |         7
        3 |         3 |     124 |         8
        3 |         3 |     124 |         9
        3 |         3 |     124 |        10
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,124) and orderline < 1000; -- 2 buffer hits
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=4.88..35.78 rows=20 width=16) (actual rows=20 loops=1)
   Recheck Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,124}'::integer[])) AND (orderline < 1000))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..4.88 rows=20 width=0) (actual rows=20 loops=1)
         Index Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,124}'::integer[])) AND (orderline < 1000))
         Buffers: shared hit=2
(7 rows)

-- This will also need 2:
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,125) and orderline > 1000;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,125) and orderline > 1000; -- 2 buffer hits
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=4.61..6.63 rows=1 width=16) (actual rows=0 loops=1)
   Recheck Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,125}'::integer[])) AND (orderline > 1000))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..4.61 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,125}'::integer[])) AND (orderline > 1000))
         Buffers: shared hit=2
(6 rows)

-- This will also need 2:
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,125) and orderline < 1000;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         3 |     121 |         1
        3 |         3 |     121 |         2
        3 |         3 |     121 |         3
        3 |         3 |     121 |         4
        3 |         3 |     121 |         5
        3 |         3 |     121 |         6
        3 |         3 |     121 |         7
        3 |         3 |     121 |         8
        3 |         3 |     121 |         9
        3 |         3 |     121 |        10
        3 |         3 |     125 |         1
        3 |         3 |     125 |         2
        3 |         3 |     125 |         3
        3 |         3 |     125 |         4
        3 |         3 |     125 |         5
        3 |         3 |     125 |         6
        3 |         3 |     125 |         7
        3 |         3 |     125 |         8
        3 |         3 |     125 |         9
        3 |         3 |     125 |        10
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,125) and orderline < 1000; -- 2 buffer hits
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=4.88..35.78 rows=20 width=16) (actual rows=20 loops=1)
   Recheck Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,125}'::integer[])) AND (orderline < 1000))
   Heap Blocks: exact=2
   Buffers: shared hit=4
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..4.88 rows=20 width=0) (actual rows=20 loops=1)
         Index Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,125}'::integer[])) AND (orderline < 1000))
         Buffers: shared hit=2
(7 rows)

-- Try it the other way -- 'NOT NULL' this time around:
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,124,125) and orderline is not null;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         3 |     121 |         1
        3 |         3 |     121 |         2
        3 |         3 |     121 |         3
        3 |         3 |     121 |         4
        3 |         3 |     121 |         5
        3 |         3 |     121 |         6
        3 |         3 |     121 |         7
        3 |         3 |     121 |         8
        3 |         3 |     121 |         9
        3 |         3 |     121 |        10
        3 |         3 |     124 |         1
        3 |         3 |     124 |         2
        3 |         3 |     124 |         3
        3 |         3 |     124 |         4
        3 |         3 |     124 |         5
        3 |         3 |     124 |         6
        3 |         3 |     124 |         7
        3 |         3 |     124 |         8
        3 |         3 |     124 |         9
        3 |         3 |     124 |        10
        3 |         3 |     125 |         1
        3 |         3 |     125 |         2
        3 |         3 |     125 |         3
        3 |         3 |     125 |         4
        3 |         3 |     125 |         5
        3 |         3 |     125 |         6
        3 |         3 |     125 |         7
        3 |         3 |     125 |         8
        3 |         3 |     125 |         9
        3 |         3 |     125 |        10
(30 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district = 3 and warehouse = 3 and orderid in (121,124,125) and orderline is not null;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=7.32..49.18 rows=30 width=16) (actual rows=30 loops=1)
   Recheck Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,124,125}'::integer[])) AND (orderline IS NOT NULL))
   Heap Blocks: exact=2
   Buffers: shared hit=4
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..7.31 rows=30 width=0) (actual rows=30 loops=1)
         Index Cond: ((district = 3) AND (warehouse = 3) AND (orderid = ANY ('{121,124,125}'::integer[])) AND (orderline IS NOT NULL))
         Buffers: shared hit=2
(7 rows)

-- Can support ScalarArrayOpExr-as-index-quals alongside RowCompareExpr:
select count(*) from redescend_test where district = 3 and warehouse in (4,5) and (orderid,orderline) >= (3,3);
 count 
-------
  2956
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from redescend_test where district = 3 and warehouse in (4,5) and (orderid,orderline) >= (3,3);
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=290.91..290.92 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=35
   ->  Bitmap Heap Scan on redescend_test  (cost=102.31..283.51 rows=2960 width=0) (actual rows=2956 loops=1)
         Recheck Cond: ((district = 3) AND (warehouse = ANY ('{4,5}'::integer[])) AND (ROW(orderid, orderline) >= ROW(3, 3)))
         Buffers: shared hit=35
         ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..101.58 rows=2960 width=0) (actual rows=2956 loops=1)
               Index Cond: ((district = 3) AND (warehouse = ANY ('{4,5}'::integer[])) AND (ROW(orderid, orderline) >= ROW(3, 3)))
               Buffers: shared hit=33
(8 rows)

-- Ditto:
select count(*) from redescend_test where district = 3 and warehouse in (4,5) and (orderid,orderline) < (1,3);
 count 
-------
     4
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from redescend_test where district = 3 and warehouse in (4,5) and (orderid,orderline) < (1,3);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=6.62..6.63 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=6
   ->  Bitmap Heap Scan on redescend_test  (cost=4.60..6.62 rows=1 width=0) (actual rows=4 loops=1)
         Recheck Cond: ((district = 3) AND (warehouse = ANY ('{4,5}'::integer[])) AND (ROW(orderid, orderline) < ROW(1, 3)))
         Buffers: shared hit=6
         ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..4.60 rows=1 width=0) (actual rows=4 loops=1)
               Index Cond: ((district = 3) AND (warehouse = ANY ('{4,5}'::integer[])) AND (ROW(orderid, orderline) < ROW(1, 3)))
               Buffers: shared hit=4
(8 rows)

-- (November 17 2023)
--
-- Test handling of scans where it's important to account for how a scan key
-- that's only required in the direction opposite the current scan direction
-- (i.e. one that can affect _bt_first's initial position but won't terminate scan)
--
-- Here the trick is to not fail to terminate a primitive index scan that can
-- advance the arrays to the next set of equality constraint values, that
-- fails to notice that we're still way before where we'd end up if _bt_first
-- was used instead.
--
-- We expect parity with master branch for this (much like any other simple
-- low cardinality array column case).
--
-- (November 22) UPDATE: Make life harder by adding a handful of NULL rows
-- around the boundaries of each district.  This caused some assertion
-- failures in your original fixes for these issues.
--
-- Recall how _bt_checkkeys/_bt_check_compare has weird rules around
-- required-ness and NULLs, that also affected Korotkov's required scan keys
-- optimization.  (See commit 882368e8, "Fix btree stop-at-nulls logic properly"
-- for more context on this behavior).
insert into redescend_test
select district, NULL, NULL, NULL
from
  generate_series(1, 3) district,
  generate_series(1, 5) want_five_nulls_per_district;
select * from redescend_test where district in (1,2,3) and warehouse > 4 and orderid > 149;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         1
        1 |         5 |     150 |         2
        1 |         5 |     150 |         3
        1 |         5 |     150 |         4
        1 |         5 |     150 |         5
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        1 |         5 |     150 |         9
        1 |         5 |     150 |        10
        2 |         5 |     150 |         1
        2 |         5 |     150 |         2
        2 |         5 |     150 |         3
        2 |         5 |     150 |         4
        2 |         5 |     150 |         5
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        2 |         5 |     150 |         9
        2 |         5 |     150 |        10
        3 |         5 |     150 |         1
        3 |         5 |     150 |         2
        3 |         5 |     150 |         3
        3 |         5 |     150 |         4
        3 |         5 |     150 |         5
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
        3 |         5 |     150 |         9
        3 |         5 |     150 |        10
(30 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district in (1,2,3) and warehouse > 4 and orderid > 149; -- 6 buffer hits with skip scan
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=108.47..142.17 rows=22 width=16) (actual rows=30 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > 4) AND (orderid > 149))
   Heap Blocks: exact=3
   Buffers: shared hit=57
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..108.46 rows=22 width=0) (actual rows=30 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > 4) AND (orderid > 149))
         Buffers: shared hit=54
(7 rows)

-- (November 1 2024)
-- Same again, but use cross-type operators for skip arrays, expecting same
-- number of buffer hits:
--
-- UPDATE XXX (November 15 2024): I decided that cross-type support from this
-- transformation wasn't going to happen after all (see timestamptz tests in
-- skip_scan suit), so we're back to doing it the inefficient way now.
select * from redescend_test where district in (1,2,3) and warehouse > 4::int8 and orderid > 149::int8;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         1
        1 |         5 |     150 |         2
        1 |         5 |     150 |         3
        1 |         5 |     150 |         4
        1 |         5 |     150 |         5
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        1 |         5 |     150 |         9
        1 |         5 |     150 |        10
        2 |         5 |     150 |         1
        2 |         5 |     150 |         2
        2 |         5 |     150 |         3
        2 |         5 |     150 |         4
        2 |         5 |     150 |         5
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        2 |         5 |     150 |         9
        2 |         5 |     150 |        10
        3 |         5 |     150 |         1
        3 |         5 |     150 |         2
        3 |         5 |     150 |         3
        3 |         5 |     150 |         4
        3 |         5 |     150 |         5
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
        3 |         5 |     150 |         9
        3 |         5 |     150 |        10
(30 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district in (1,2,3) and warehouse > 4::int8 and orderid > 149::int8;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=108.47..142.17 rows=22 width=16) (actual rows=30 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > '4'::bigint) AND (orderid > '149'::bigint))
   Heap Blocks: exact=3
   Buffers: shared hit=57
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..108.46 rows=22 width=0) (actual rows=30 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > '4'::bigint) AND (orderid > '149'::bigint))
         Buffers: shared hit=54
(7 rows)

-- This variant returns same rows as previous test case, but has equality
-- constraints for all columns barring the last, making it visit far fewer
-- leaf pages:
--
-- Note: this variant *doesn't* exercise bug like the original did at first,
-- because we've long been able to recognize that we're passed the end of
-- "warehouse = 5" equality constraint grouping.
--
-- (November 22) UPDATE:
--
-- Note: this is one of the only test cases that demonstrates that non-array
-- equality scan keys cannot exclusively rely on _bt_check_compare/the =
-- operator, which isn't too obvious (even less so now that we have
-- sktrig-based beyond_end_advance advancement).
--
-- IOW this shows that in general non-array equality scan keys need to be able
-- to trigger both beyond_end_advance and !all_eqtype_sk_equal/"before-start"
-- advancement.  IOW it shows that we can't get away with only having ORDER
-- procs for arrays themselves, which has been something that you've been
-- confused by at various points.
select * from redescend_test where district in (1,2,3) and warehouse = 5 and orderid > 149;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         1
        1 |         5 |     150 |         2
        1 |         5 |     150 |         3
        1 |         5 |     150 |         4
        1 |         5 |     150 |         5
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        1 |         5 |     150 |         9
        1 |         5 |     150 |        10
        2 |         5 |     150 |         1
        2 |         5 |     150 |         2
        2 |         5 |     150 |         3
        2 |         5 |     150 |         4
        2 |         5 |     150 |         5
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        2 |         5 |     150 |         9
        2 |         5 |     150 |        10
        3 |         5 |     150 |         1
        3 |         5 |     150 |         2
        3 |         5 |     150 |         3
        3 |         5 |     150 |         4
        3 |         5 |     150 |         5
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
        3 |         5 |     150 |         9
        3 |         5 |     150 |        10
(30 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test where district in (1,2,3) and warehouse = 5 and orderid > 149; -- 6 buffer hits (patch + master)
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=7.13..40.83 rows=22 width=16) (actual rows=30 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse = 5) AND (orderid > 149))
   Heap Blocks: exact=3
   Buffers: shared hit=9
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..7.12 rows=22 width=0) (actual rows=30 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse = 5) AND (orderid > 149))
         Buffers: shared hit=6
(7 rows)

-- This variant found a bug in my bugfix for the original (though only an hour
-- or so after), when I realized that I'd been sloppy about
-- required-vs-nonrequired arrays in my original fix.
--
-- This is exactly the same in terms of buffers accessed -- but the addition
-- of the non-required "orderline in (6,7,8)" array makes it slightly harder.
select * from redescend_test
where district in (1, 2, 3) and warehouse > 4 and orderid > 149 and orderline in (6, 7, 8);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse > 4 and orderid > 149 and orderline in (6, 7, 8);
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=116.38..127.19 rows=6 width=16) (actual rows=9 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > 4) AND (orderid > 149) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Heap Blocks: exact=3
   Buffers: shared hit=57
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..116.38 rows=6 width=0) (actual rows=9 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > 4) AND (orderid > 149) AND (orderline = ANY ('{6,7,8}'::integer[])))
         Buffers: shared hit=54
(7 rows)

-- (November 19)
--
-- >= instead of > variant, independently found a bug:
--
-- Update (February 18): What's really notable about this test case is that it
-- makes "orderline" non-required, but also sees _bt_first use all 4 scan keys (including
-- "orderline") in its initial descent insertion scan key.
--
-- As such, it is a good demonstration of possible dangers around being too clever about giving up
-- earlier for an unsatisfiable non-required array -- it might be that
-- _bt_first expects the non-required array keys to be advanced.
--
-- UPDATE XXX (February 19): see also, later similar redescend_test that goes
-- further than this one.
select * from redescend_test
where district in (1, 2, 3) and warehouse >= 5 and orderid >= 150 and orderline in (6, 7, 8);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse >= 5 and orderid >= 150 and orderline in (6, 7, 8);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=116.38..127.19 rows=6 width=16) (actual rows=9 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid >= 150) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Heap Blocks: exact=3
   Buffers: shared hit=9
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..116.38 rows=6 width=0) (actual rows=9 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid >= 150) AND (orderline = ANY ('{6,7,8}'::integer[])))
         Buffers: shared hit=6
(7 rows)

-- Gap this time (just for good luck):
select * from redescend_test
where district in (1, 2, 3) and warehouse >= 5 and orderid >= 150 and orderline in (-1, 6, 8, 1000);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         6
        1 |         5 |     150 |         8
        2 |         5 |     150 |         6
        2 |         5 |     150 |         8
        3 |         5 |     150 |         6
        3 |         5 |     150 |         8
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse >= 5 and orderid >= 150 and orderline in (-1, 6, 8, 1000);
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=116.38..123.75 rows=4 width=16) (actual rows=6 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid >= 150) AND (orderline = ANY ('{-1,6,8,1000}'::integer[])))
   Heap Blocks: exact=3
   Buffers: shared hit=9
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..116.38 rows=4 width=0) (actual rows=6 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid >= 150) AND (orderline = ANY ('{-1,6,8,1000}'::integer[])))
         Buffers: shared hit=6
(7 rows)

-- Mix >= and >:
select * from redescend_test
where district in (1, 2, 3) and warehouse >= 5 and orderid > 149 and orderline in (6, 7, 8);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse >= 5 and orderid > 149 and orderline in (6, 7, 8);
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=116.38..127.19 rows=6 width=16) (actual rows=9 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid > 149) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Heap Blocks: exact=3
   Buffers: shared hit=9
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..116.38 rows=6 width=0) (actual rows=9 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid > 149) AND (orderline = ANY ('{6,7,8}'::integer[])))
         Buffers: shared hit=6
(7 rows)

-- Mix >= and > again:
select * from redescend_test
where district in (1, 2, 3) and warehouse > 4 and orderid >= 150 and orderline in (6, 7, 8);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse > 4 and orderid >= 150 and orderline in (6, 7, 8);
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on redescend_test  (cost=116.38..127.19 rows=6 width=16) (actual rows=9 loops=1)
   Recheck Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > 4) AND (orderid >= 150) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Heap Blocks: exact=3
   Buffers: shared hit=57
   ->  Bitmap Index Scan on must_not_full_scan  (cost=0.00..116.38 rows=6 width=0) (actual rows=9 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > 4) AND (orderid >= 150) AND (orderline = ANY ('{6,7,8}'::integer[])))
         Buffers: shared hit=54
(7 rows)

-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Never had this same problem with same query once it uses a backwards scan:
select * from redescend_test
where district in (1, 2, 3) and warehouse > 4 and orderid > 149 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         5 |     150 |         8
        3 |         5 |     150 |         7
        3 |         5 |     150 |         6
        2 |         5 |     150 |         8
        2 |         5 |     150 |         7
        2 |         5 |     150 |         6
        1 |         5 |     150 |         8
        1 |         5 |     150 |         7
        1 |         5 |     150 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse > 4 and orderid > 149 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > 4) AND (orderid > 149) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=57
(3 rows)

-- (November 19 2024) Never had this same problem with same query once it uses a backwards scan:
-- (Repeat without skip support, caught a bug in avoid-coleman-testcase-regressions patch)
set skipscan_skipsupport_enabled=false;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
select * from redescend_test
where district in (1, 2, 3) and warehouse > 4 and orderid > 149 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         5 |     150 |         8
        3 |         5 |     150 |         7
        3 |         5 |     150 |         6
        2 |         5 |     150 |         8
        2 |         5 |     150 |         7
        2 |         5 |     150 |         6
        1 |         5 |     150 |         8
        1 |         5 |     150 |         7
        1 |         5 |     150 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse > 4 and orderid > 149 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse > 4) AND (orderid > 149) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=57
(3 rows)

reset skipscan_skipsupport_enabled;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
-- UPDATE (March 2): "never had this problem" must have been due to how
-- _bt_first can "cons up" a SK_SEARCHNOTNULL scan key in its insertion scan
-- key, even though that doesn't appear in search type scan keys.
--
-- See:
/*
👾  btbeginscan to begin scan of index "must_not_full_scan"
♻️  btrescan
btrescan: BTScanPosInvalidate() called for markPos
_bt_preprocess_array_keys: SK_SEARCHARRAY input 0: [ flags: [SK_SEARCHARRAY], attno: 1 func OID: 65 ]
_bt_preprocess_array_keys: SK_SEARCHARRAY input 3: [ flags: [SK_SEARCHARRAY], attno: 4 func OID: 65 ]
_bt_preprocess_array_keys: scan_key: 0, num_elems: 3
_bt_preprocess_array_keys: scan_key: 3, num_elems: 3
 so->numArrayKeys is 2
_bt_start_array_keys: cur_elem 2, sk_attno: 1, val: 3 [NULLS LAST, ASC]
_bt_start_array_keys: cur_elem 2, sk_attno: 4, val: 8 [NULLS LAST, ASC]
_bt_preprocess_keys:  inkeys[0]: [ flags: [SK_SEARCHARRAY], attno: 1 func OID: 65 ]
_bt_preprocess_keys:  inkeys[1]: [ flags: [], attno: 2 func OID: 147 ]
_bt_preprocess_keys:  inkeys[2]: [ flags: [], attno: 3 func OID: 147 ]
_bt_preprocess_keys:  inkeys[3]: [ flags: [SK_SEARCHARRAY], attno: 4 func OID: 65 ]
_bt_preprocess_keys: outkeys[0]: [ flags: [SK_SEARCHARRAY, SK_BT_REQFWD, SK_BT_REQBKWD], attno: 1 func OID: 65 ]
_bt_preprocess_keys: outkeys[1]: [ flags: [SK_BT_REQBKWD], attno: 2 func OID: 147 ]
_bt_preprocess_keys: outkeys[2]: [ flags: [], attno: 3 func OID: 147 ]
_bt_preprocess_keys: outkeys[3]: [ flags: [SK_SEARCHARRAY], attno: 4 func OID: 65 ]
_bt_preprocess_keys: scan->numberOfKeys is 4, so->numberOfKeys on output is 4

➕     ➕     ➕
_bt_first: generating insertion scankey for initial positioning purposes using search/operator type scan keys
_bt_first: input startKeys[0]: [ flags: [SK_SEARCHARRAY, SK_BT_REQFWD, SK_BT_REQBKWD], attno: 1 func OID: 65 ]
_bt_first: sk_attno 1. val: 3, flags: [SK_SEARCHARRAY, SK_BT_REQFWD, SK_BT_REQBKWD]
_bt_first: input startKeys[1]: [ flags: [SK_ISNULL, SK_SEARCHNOTNULL], attno: 2 func OID: 0 ]
           sk_attno 2. val: NULL, flags: [SK_ISNULL, SK_SEARCHNOTNULL]
          with strat_total=1, inskey.keys=2, inskey.nextkey=0, inskey.backward=1
*/
-- This is the one case where a scan key required in the same direction as the
-- scan actually influences initial positioning strategy (usually it's only
-- equality strategy scan keys and required-in-opposite-direction-only
-- inequalities that can do that).  This is related to how _bt_check_compares
-- has that one case with NULLs that sees required-in-opposite-direction-only
-- cases passed as the sktrig to _bt_advance_array_keys.
--
-- The central feature of both of these optimizations is that the requiredness
-- of an inequality doesn't affect our continuescan-setting behavior with NULLs.
-- All that matters is the current scan direction, and the relationship
-- between that direction and whether NULLs are stored first or last relative
-- to non-NULLs
-- Same isn't true with this variant of the original query, that's also a
-- backwards scan, but has the operators flipped -- now the query has the same
-- adversarial character as the original (relative to the scan direction)
select * from redescend_test
where district in (1, 2, 3) and warehouse < 2 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse < 2 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse < 2) AND (orderid < 2) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=58
(3 rows)

-- (November 1 2024)
--
-- Same again, but this time make life hard for skip scan preprocessing
-- optimization by using cross-type operators for those attributes that'll get
-- skip arrays:
--
-- UPDATE XXX (November 15 2024): I decided that cross-type support from this
-- transformation wasn't going to happen after all (see timestamptz tests in
-- skip_scan suit), so we're back to doing it the inefficient way now.
select * from redescend_test
where district in (1, 2, 3) and warehouse < 2::int8 and orderid < 2::int8 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- Should have same number of hits as before
select * from redescend_test
where district in (1, 2, 3) and warehouse < 2::int8 and orderid < 2::int8 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse < '2'::bigint) AND (orderid < '2'::bigint) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=58
(3 rows)

-- (November 19)
--
-- <= instead of < variant, independently found a bug:
--
-- Update (February 18): What's really notable about this test case is that it
-- makes "orderline" non-required, but also sees _bt_first use all 4 scan keys (including
-- "orderline") in its initial descent insertion scan key.
--
-- As such, it is a good demonstration of possible dangers around being too clever about giving up
-- earlier for an unsatisfiable non-required array -- it might be that
-- _bt_first expects the non-required array keys to be advanced.
--
-- UPDATE XXX (February 19): see also, later similar redescend_test that goes
-- further than this one.
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse <= 1) AND (orderid <= 1) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=9
(3 rows)

-- (March 8)
-- Derp, simple error in _bt_rewind_nonrequired_arrays (used && when I should
-- have used || instead)
--
-- TRAP: failed Assert("array->scan_key == ikey"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 1037, PID: 154561
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid in (0, 1) and orderline >= any ('{6,7,8}')
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |        10
        3 |         1 |       1 |         9
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |        10
        2 |         1 |       1 |         9
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |        10
        1 |         1 |       1 |         9
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(15 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid in (0, 1) and orderline >= any ('{6,7,8}')
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..144.09 rows=33 width=16) (actual rows=15 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse <= 1) AND (orderid = ANY ('{0,1}'::integer[])) AND (orderline >= ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=9
(3 rows)

-- Gap this time (just for good luck):
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (-1, 6, 8, 1000)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         6
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (-1, 6, 8, 1000)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..121.05 rows=4 width=16) (actual rows=6 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse <= 1) AND (orderid <= 1) AND (orderline = ANY ('{-1,6,8,1000}'::integer[])))
   Buffers: shared hit=9
(3 rows)

-- Mix <= and <:
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse <= 1) AND (orderid < 2) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=9
(3 rows)

-- Mix <= and < again:
select * from redescend_test
where district in (1, 2, 3) and warehouse < 2 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse < 2 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse < 2) AND (orderid <= 1) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=58
(3 rows)

-- (November 21)
--
-- RowCompare inequality variants
-- Test > RowCompare
prepare test_rowcompare as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) > (4, 149)
group by district, warehouse, orderid
order by district, warehouse, orderid;
execute test_rowcompare;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
    10 |        1 |         4 |     150
    10 |        1 |         5 |       1
    10 |        1 |         5 |       2
    10 |        1 |         5 |       3
    10 |        1 |         5 |       4
    10 |        1 |         5 |       5
    10 |        1 |         5 |       6
    10 |        1 |         5 |       7
    10 |        1 |         5 |       8
    10 |        1 |         5 |       9
    10 |        1 |         5 |      10
    10 |        1 |         5 |      11
    10 |        1 |         5 |      12
    10 |        1 |         5 |      13
    10 |        1 |         5 |      14
    10 |        1 |         5 |      15
    10 |        1 |         5 |      16
    10 |        1 |         5 |      17
    10 |        1 |         5 |      18
    10 |        1 |         5 |      19
    10 |        1 |         5 |      20
    10 |        1 |         5 |      21
    10 |        1 |         5 |      22
    10 |        1 |         5 |      23
    10 |        1 |         5 |      24
    10 |        1 |         5 |      25
    10 |        1 |         5 |      26
    10 |        1 |         5 |      27
    10 |        1 |         5 |      28
    10 |        1 |         5 |      29
    10 |        1 |         5 |      30
    10 |        1 |         5 |      31
    10 |        1 |         5 |      32
    10 |        1 |         5 |      33
    10 |        1 |         5 |      34
    10 |        1 |         5 |      35
    10 |        1 |         5 |      36
    10 |        1 |         5 |      37
    10 |        1 |         5 |      38
    10 |        1 |         5 |      39
    10 |        1 |         5 |      40
    10 |        1 |         5 |      41
    10 |        1 |         5 |      42
    10 |        1 |         5 |      43
    10 |        1 |         5 |      44
    10 |        1 |         5 |      45
    10 |        1 |         5 |      46
    10 |        1 |         5 |      47
    10 |        1 |         5 |      48
    10 |        1 |         5 |      49
    10 |        1 |         5 |      50
    10 |        1 |         5 |      51
    10 |        1 |         5 |      52
    10 |        1 |         5 |      53
    10 |        1 |         5 |      54
    10 |        1 |         5 |      55
    10 |        1 |         5 |      56
    10 |        1 |         5 |      57
    10 |        1 |         5 |      58
    10 |        1 |         5 |      59
    10 |        1 |         5 |      60
    10 |        1 |         5 |      61
    10 |        1 |         5 |      62
    10 |        1 |         5 |      63
    10 |        1 |         5 |      64
    10 |        1 |         5 |      65
    10 |        1 |         5 |      66
    10 |        1 |         5 |      67
    10 |        1 |         5 |      68
    10 |        1 |         5 |      69
    10 |        1 |         5 |      70
    10 |        1 |         5 |      71
    10 |        1 |         5 |      72
    10 |        1 |         5 |      73
    10 |        1 |         5 |      74
    10 |        1 |         5 |      75
    10 |        1 |         5 |      76
    10 |        1 |         5 |      77
    10 |        1 |         5 |      78
    10 |        1 |         5 |      79
    10 |        1 |         5 |      80
    10 |        1 |         5 |      81
    10 |        1 |         5 |      82
    10 |        1 |         5 |      83
    10 |        1 |         5 |      84
    10 |        1 |         5 |      85
    10 |        1 |         5 |      86
    10 |        1 |         5 |      87
    10 |        1 |         5 |      88
    10 |        1 |         5 |      89
    10 |        1 |         5 |      90
    10 |        1 |         5 |      91
    10 |        1 |         5 |      92
    10 |        1 |         5 |      93
    10 |        1 |         5 |      94
    10 |        1 |         5 |      95
    10 |        1 |         5 |      96
    10 |        1 |         5 |      97
    10 |        1 |         5 |      98
    10 |        1 |         5 |      99
    10 |        1 |         5 |     100
    10 |        1 |         5 |     101
    10 |        1 |         5 |     102
    10 |        1 |         5 |     103
    10 |        1 |         5 |     104
    10 |        1 |         5 |     105
    10 |        1 |         5 |     106
    10 |        1 |         5 |     107
    10 |        1 |         5 |     108
    10 |        1 |         5 |     109
    10 |        1 |         5 |     110
    10 |        1 |         5 |     111
    10 |        1 |         5 |     112
    10 |        1 |         5 |     113
    10 |        1 |         5 |     114
    10 |        1 |         5 |     115
    10 |        1 |         5 |     116
    10 |        1 |         5 |     117
    10 |        1 |         5 |     118
    10 |        1 |         5 |     119
    10 |        1 |         5 |     120
    10 |        1 |         5 |     121
    10 |        1 |         5 |     122
    10 |        1 |         5 |     123
    10 |        1 |         5 |     124
    10 |        1 |         5 |     125
    10 |        1 |         5 |     126
    10 |        1 |         5 |     127
    10 |        1 |         5 |     128
    10 |        1 |         5 |     129
    10 |        1 |         5 |     130
    10 |        1 |         5 |     131
    10 |        1 |         5 |     132
    10 |        1 |         5 |     133
    10 |        1 |         5 |     134
    10 |        1 |         5 |     135
    10 |        1 |         5 |     136
    10 |        1 |         5 |     137
    10 |        1 |         5 |     138
    10 |        1 |         5 |     139
    10 |        1 |         5 |     140
    10 |        1 |         5 |     141
    10 |        1 |         5 |     142
    10 |        1 |         5 |     143
    10 |        1 |         5 |     144
    10 |        1 |         5 |     145
    10 |        1 |         5 |     146
    10 |        1 |         5 |     147
    10 |        1 |         5 |     148
    10 |        1 |         5 |     149
    10 |        1 |         5 |     150
    10 |        2 |         4 |     150
    10 |        2 |         5 |       1
    10 |        2 |         5 |       2
    10 |        2 |         5 |       3
    10 |        2 |         5 |       4
    10 |        2 |         5 |       5
    10 |        2 |         5 |       6
    10 |        2 |         5 |       7
    10 |        2 |         5 |       8
    10 |        2 |         5 |       9
    10 |        2 |         5 |      10
    10 |        2 |         5 |      11
    10 |        2 |         5 |      12
    10 |        2 |         5 |      13
    10 |        2 |         5 |      14
    10 |        2 |         5 |      15
    10 |        2 |         5 |      16
    10 |        2 |         5 |      17
    10 |        2 |         5 |      18
    10 |        2 |         5 |      19
    10 |        2 |         5 |      20
    10 |        2 |         5 |      21
    10 |        2 |         5 |      22
    10 |        2 |         5 |      23
    10 |        2 |         5 |      24
    10 |        2 |         5 |      25
    10 |        2 |         5 |      26
    10 |        2 |         5 |      27
    10 |        2 |         5 |      28
    10 |        2 |         5 |      29
    10 |        2 |         5 |      30
    10 |        2 |         5 |      31
    10 |        2 |         5 |      32
    10 |        2 |         5 |      33
    10 |        2 |         5 |      34
    10 |        2 |         5 |      35
    10 |        2 |         5 |      36
    10 |        2 |         5 |      37
    10 |        2 |         5 |      38
    10 |        2 |         5 |      39
    10 |        2 |         5 |      40
    10 |        2 |         5 |      41
    10 |        2 |         5 |      42
    10 |        2 |         5 |      43
    10 |        2 |         5 |      44
    10 |        2 |         5 |      45
    10 |        2 |         5 |      46
    10 |        2 |         5 |      47
    10 |        2 |         5 |      48
    10 |        2 |         5 |      49
    10 |        2 |         5 |      50
    10 |        2 |         5 |      51
    10 |        2 |         5 |      52
    10 |        2 |         5 |      53
    10 |        2 |         5 |      54
    10 |        2 |         5 |      55
    10 |        2 |         5 |      56
    10 |        2 |         5 |      57
    10 |        2 |         5 |      58
    10 |        2 |         5 |      59
    10 |        2 |         5 |      60
    10 |        2 |         5 |      61
    10 |        2 |         5 |      62
    10 |        2 |         5 |      63
    10 |        2 |         5 |      64
    10 |        2 |         5 |      65
    10 |        2 |         5 |      66
    10 |        2 |         5 |      67
    10 |        2 |         5 |      68
    10 |        2 |         5 |      69
    10 |        2 |         5 |      70
    10 |        2 |         5 |      71
    10 |        2 |         5 |      72
    10 |        2 |         5 |      73
    10 |        2 |         5 |      74
    10 |        2 |         5 |      75
    10 |        2 |         5 |      76
    10 |        2 |         5 |      77
    10 |        2 |         5 |      78
    10 |        2 |         5 |      79
    10 |        2 |         5 |      80
    10 |        2 |         5 |      81
    10 |        2 |         5 |      82
    10 |        2 |         5 |      83
    10 |        2 |         5 |      84
    10 |        2 |         5 |      85
    10 |        2 |         5 |      86
    10 |        2 |         5 |      87
    10 |        2 |         5 |      88
    10 |        2 |         5 |      89
    10 |        2 |         5 |      90
    10 |        2 |         5 |      91
    10 |        2 |         5 |      92
    10 |        2 |         5 |      93
    10 |        2 |         5 |      94
    10 |        2 |         5 |      95
    10 |        2 |         5 |      96
    10 |        2 |         5 |      97
    10 |        2 |         5 |      98
    10 |        2 |         5 |      99
    10 |        2 |         5 |     100
    10 |        2 |         5 |     101
    10 |        2 |         5 |     102
    10 |        2 |         5 |     103
    10 |        2 |         5 |     104
    10 |        2 |         5 |     105
    10 |        2 |         5 |     106
    10 |        2 |         5 |     107
    10 |        2 |         5 |     108
    10 |        2 |         5 |     109
    10 |        2 |         5 |     110
    10 |        2 |         5 |     111
    10 |        2 |         5 |     112
    10 |        2 |         5 |     113
    10 |        2 |         5 |     114
    10 |        2 |         5 |     115
    10 |        2 |         5 |     116
    10 |        2 |         5 |     117
    10 |        2 |         5 |     118
    10 |        2 |         5 |     119
    10 |        2 |         5 |     120
    10 |        2 |         5 |     121
    10 |        2 |         5 |     122
    10 |        2 |         5 |     123
    10 |        2 |         5 |     124
    10 |        2 |         5 |     125
    10 |        2 |         5 |     126
    10 |        2 |         5 |     127
    10 |        2 |         5 |     128
    10 |        2 |         5 |     129
    10 |        2 |         5 |     130
    10 |        2 |         5 |     131
    10 |        2 |         5 |     132
    10 |        2 |         5 |     133
    10 |        2 |         5 |     134
    10 |        2 |         5 |     135
    10 |        2 |         5 |     136
    10 |        2 |         5 |     137
    10 |        2 |         5 |     138
    10 |        2 |         5 |     139
    10 |        2 |         5 |     140
    10 |        2 |         5 |     141
    10 |        2 |         5 |     142
    10 |        2 |         5 |     143
    10 |        2 |         5 |     144
    10 |        2 |         5 |     145
    10 |        2 |         5 |     146
    10 |        2 |         5 |     147
    10 |        2 |         5 |     148
    10 |        2 |         5 |     149
    10 |        2 |         5 |     150
    10 |        3 |         4 |     150
    10 |        3 |         5 |       1
    10 |        3 |         5 |       2
    10 |        3 |         5 |       3
    10 |        3 |         5 |       4
    10 |        3 |         5 |       5
    10 |        3 |         5 |       6
    10 |        3 |         5 |       7
    10 |        3 |         5 |       8
    10 |        3 |         5 |       9
    10 |        3 |         5 |      10
    10 |        3 |         5 |      11
    10 |        3 |         5 |      12
    10 |        3 |         5 |      13
    10 |        3 |         5 |      14
    10 |        3 |         5 |      15
    10 |        3 |         5 |      16
    10 |        3 |         5 |      17
    10 |        3 |         5 |      18
    10 |        3 |         5 |      19
    10 |        3 |         5 |      20
    10 |        3 |         5 |      21
    10 |        3 |         5 |      22
    10 |        3 |         5 |      23
    10 |        3 |         5 |      24
    10 |        3 |         5 |      25
    10 |        3 |         5 |      26
    10 |        3 |         5 |      27
    10 |        3 |         5 |      28
    10 |        3 |         5 |      29
    10 |        3 |         5 |      30
    10 |        3 |         5 |      31
    10 |        3 |         5 |      32
    10 |        3 |         5 |      33
    10 |        3 |         5 |      34
    10 |        3 |         5 |      35
    10 |        3 |         5 |      36
    10 |        3 |         5 |      37
    10 |        3 |         5 |      38
    10 |        3 |         5 |      39
    10 |        3 |         5 |      40
    10 |        3 |         5 |      41
    10 |        3 |         5 |      42
    10 |        3 |         5 |      43
    10 |        3 |         5 |      44
    10 |        3 |         5 |      45
    10 |        3 |         5 |      46
    10 |        3 |         5 |      47
    10 |        3 |         5 |      48
    10 |        3 |         5 |      49
    10 |        3 |         5 |      50
    10 |        3 |         5 |      51
    10 |        3 |         5 |      52
    10 |        3 |         5 |      53
    10 |        3 |         5 |      54
    10 |        3 |         5 |      55
    10 |        3 |         5 |      56
    10 |        3 |         5 |      57
    10 |        3 |         5 |      58
    10 |        3 |         5 |      59
    10 |        3 |         5 |      60
    10 |        3 |         5 |      61
    10 |        3 |         5 |      62
    10 |        3 |         5 |      63
    10 |        3 |         5 |      64
    10 |        3 |         5 |      65
    10 |        3 |         5 |      66
    10 |        3 |         5 |      67
    10 |        3 |         5 |      68
    10 |        3 |         5 |      69
    10 |        3 |         5 |      70
    10 |        3 |         5 |      71
    10 |        3 |         5 |      72
    10 |        3 |         5 |      73
    10 |        3 |         5 |      74
    10 |        3 |         5 |      75
    10 |        3 |         5 |      76
    10 |        3 |         5 |      77
    10 |        3 |         5 |      78
    10 |        3 |         5 |      79
    10 |        3 |         5 |      80
    10 |        3 |         5 |      81
    10 |        3 |         5 |      82
    10 |        3 |         5 |      83
    10 |        3 |         5 |      84
    10 |        3 |         5 |      85
    10 |        3 |         5 |      86
    10 |        3 |         5 |      87
    10 |        3 |         5 |      88
    10 |        3 |         5 |      89
    10 |        3 |         5 |      90
    10 |        3 |         5 |      91
    10 |        3 |         5 |      92
    10 |        3 |         5 |      93
    10 |        3 |         5 |      94
    10 |        3 |         5 |      95
    10 |        3 |         5 |      96
    10 |        3 |         5 |      97
    10 |        3 |         5 |      98
    10 |        3 |         5 |      99
    10 |        3 |         5 |     100
    10 |        3 |         5 |     101
    10 |        3 |         5 |     102
    10 |        3 |         5 |     103
    10 |        3 |         5 |     104
    10 |        3 |         5 |     105
    10 |        3 |         5 |     106
    10 |        3 |         5 |     107
    10 |        3 |         5 |     108
    10 |        3 |         5 |     109
    10 |        3 |         5 |     110
    10 |        3 |         5 |     111
    10 |        3 |         5 |     112
    10 |        3 |         5 |     113
    10 |        3 |         5 |     114
    10 |        3 |         5 |     115
    10 |        3 |         5 |     116
    10 |        3 |         5 |     117
    10 |        3 |         5 |     118
    10 |        3 |         5 |     119
    10 |        3 |         5 |     120
    10 |        3 |         5 |     121
    10 |        3 |         5 |     122
    10 |        3 |         5 |     123
    10 |        3 |         5 |     124
    10 |        3 |         5 |     125
    10 |        3 |         5 |     126
    10 |        3 |         5 |     127
    10 |        3 |         5 |     128
    10 |        3 |         5 |     129
    10 |        3 |         5 |     130
    10 |        3 |         5 |     131
    10 |        3 |         5 |     132
    10 |        3 |         5 |     133
    10 |        3 |         5 |     134
    10 |        3 |         5 |     135
    10 |        3 |         5 |     136
    10 |        3 |         5 |     137
    10 |        3 |         5 |     138
    10 |        3 |         5 |     139
    10 |        3 |         5 |     140
    10 |        3 |         5 |     141
    10 |        3 |         5 |     142
    10 |        3 |         5 |     143
    10 |        3 |         5 |     144
    10 |        3 |         5 |     145
    10 |        3 |         5 |     146
    10 |        3 |         5 |     147
    10 |        3 |         5 |     148
    10 |        3 |         5 |     149
    10 |        3 |         5 |     150
(453 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..298.88 rows=1756 width=20) (actual rows=453 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=82
   ->  Index Scan using must_not_full_scan on redescend_test  (cost=0.29..249.65 rows=3167 width=12) (actual rows=4530 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) > ROW(4, 149)))
         Buffers: shared hit=82
(6 rows)

deallocate test_rowcompare;
-- Test > RowCompare + non-required SAOPs
prepare test_rowcompare as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) > (4, 149) and orderline in (-5,1,7,9,10,11)
group by district, warehouse, orderid
order by district, warehouse, orderid;
execute test_rowcompare;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
     4 |        1 |         4 |     150
     4 |        1 |         5 |       1
     4 |        1 |         5 |       2
     4 |        1 |         5 |       3
     4 |        1 |         5 |       4
     4 |        1 |         5 |       5
     4 |        1 |         5 |       6
     4 |        1 |         5 |       7
     4 |        1 |         5 |       8
     4 |        1 |         5 |       9
     4 |        1 |         5 |      10
     4 |        1 |         5 |      11
     4 |        1 |         5 |      12
     4 |        1 |         5 |      13
     4 |        1 |         5 |      14
     4 |        1 |         5 |      15
     4 |        1 |         5 |      16
     4 |        1 |         5 |      17
     4 |        1 |         5 |      18
     4 |        1 |         5 |      19
     4 |        1 |         5 |      20
     4 |        1 |         5 |      21
     4 |        1 |         5 |      22
     4 |        1 |         5 |      23
     4 |        1 |         5 |      24
     4 |        1 |         5 |      25
     4 |        1 |         5 |      26
     4 |        1 |         5 |      27
     4 |        1 |         5 |      28
     4 |        1 |         5 |      29
     4 |        1 |         5 |      30
     4 |        1 |         5 |      31
     4 |        1 |         5 |      32
     4 |        1 |         5 |      33
     4 |        1 |         5 |      34
     4 |        1 |         5 |      35
     4 |        1 |         5 |      36
     4 |        1 |         5 |      37
     4 |        1 |         5 |      38
     4 |        1 |         5 |      39
     4 |        1 |         5 |      40
     4 |        1 |         5 |      41
     4 |        1 |         5 |      42
     4 |        1 |         5 |      43
     4 |        1 |         5 |      44
     4 |        1 |         5 |      45
     4 |        1 |         5 |      46
     4 |        1 |         5 |      47
     4 |        1 |         5 |      48
     4 |        1 |         5 |      49
     4 |        1 |         5 |      50
     4 |        1 |         5 |      51
     4 |        1 |         5 |      52
     4 |        1 |         5 |      53
     4 |        1 |         5 |      54
     4 |        1 |         5 |      55
     4 |        1 |         5 |      56
     4 |        1 |         5 |      57
     4 |        1 |         5 |      58
     4 |        1 |         5 |      59
     4 |        1 |         5 |      60
     4 |        1 |         5 |      61
     4 |        1 |         5 |      62
     4 |        1 |         5 |      63
     4 |        1 |         5 |      64
     4 |        1 |         5 |      65
     4 |        1 |         5 |      66
     4 |        1 |         5 |      67
     4 |        1 |         5 |      68
     4 |        1 |         5 |      69
     4 |        1 |         5 |      70
     4 |        1 |         5 |      71
     4 |        1 |         5 |      72
     4 |        1 |         5 |      73
     4 |        1 |         5 |      74
     4 |        1 |         5 |      75
     4 |        1 |         5 |      76
     4 |        1 |         5 |      77
     4 |        1 |         5 |      78
     4 |        1 |         5 |      79
     4 |        1 |         5 |      80
     4 |        1 |         5 |      81
     4 |        1 |         5 |      82
     4 |        1 |         5 |      83
     4 |        1 |         5 |      84
     4 |        1 |         5 |      85
     4 |        1 |         5 |      86
     4 |        1 |         5 |      87
     4 |        1 |         5 |      88
     4 |        1 |         5 |      89
     4 |        1 |         5 |      90
     4 |        1 |         5 |      91
     4 |        1 |         5 |      92
     4 |        1 |         5 |      93
     4 |        1 |         5 |      94
     4 |        1 |         5 |      95
     4 |        1 |         5 |      96
     4 |        1 |         5 |      97
     4 |        1 |         5 |      98
     4 |        1 |         5 |      99
     4 |        1 |         5 |     100
     4 |        1 |         5 |     101
     4 |        1 |         5 |     102
     4 |        1 |         5 |     103
     4 |        1 |         5 |     104
     4 |        1 |         5 |     105
     4 |        1 |         5 |     106
     4 |        1 |         5 |     107
     4 |        1 |         5 |     108
     4 |        1 |         5 |     109
     4 |        1 |         5 |     110
     4 |        1 |         5 |     111
     4 |        1 |         5 |     112
     4 |        1 |         5 |     113
     4 |        1 |         5 |     114
     4 |        1 |         5 |     115
     4 |        1 |         5 |     116
     4 |        1 |         5 |     117
     4 |        1 |         5 |     118
     4 |        1 |         5 |     119
     4 |        1 |         5 |     120
     4 |        1 |         5 |     121
     4 |        1 |         5 |     122
     4 |        1 |         5 |     123
     4 |        1 |         5 |     124
     4 |        1 |         5 |     125
     4 |        1 |         5 |     126
     4 |        1 |         5 |     127
     4 |        1 |         5 |     128
     4 |        1 |         5 |     129
     4 |        1 |         5 |     130
     4 |        1 |         5 |     131
     4 |        1 |         5 |     132
     4 |        1 |         5 |     133
     4 |        1 |         5 |     134
     4 |        1 |         5 |     135
     4 |        1 |         5 |     136
     4 |        1 |         5 |     137
     4 |        1 |         5 |     138
     4 |        1 |         5 |     139
     4 |        1 |         5 |     140
     4 |        1 |         5 |     141
     4 |        1 |         5 |     142
     4 |        1 |         5 |     143
     4 |        1 |         5 |     144
     4 |        1 |         5 |     145
     4 |        1 |         5 |     146
     4 |        1 |         5 |     147
     4 |        1 |         5 |     148
     4 |        1 |         5 |     149
     4 |        1 |         5 |     150
     4 |        2 |         4 |     150
     4 |        2 |         5 |       1
     4 |        2 |         5 |       2
     4 |        2 |         5 |       3
     4 |        2 |         5 |       4
     4 |        2 |         5 |       5
     4 |        2 |         5 |       6
     4 |        2 |         5 |       7
     4 |        2 |         5 |       8
     4 |        2 |         5 |       9
     4 |        2 |         5 |      10
     4 |        2 |         5 |      11
     4 |        2 |         5 |      12
     4 |        2 |         5 |      13
     4 |        2 |         5 |      14
     4 |        2 |         5 |      15
     4 |        2 |         5 |      16
     4 |        2 |         5 |      17
     4 |        2 |         5 |      18
     4 |        2 |         5 |      19
     4 |        2 |         5 |      20
     4 |        2 |         5 |      21
     4 |        2 |         5 |      22
     4 |        2 |         5 |      23
     4 |        2 |         5 |      24
     4 |        2 |         5 |      25
     4 |        2 |         5 |      26
     4 |        2 |         5 |      27
     4 |        2 |         5 |      28
     4 |        2 |         5 |      29
     4 |        2 |         5 |      30
     4 |        2 |         5 |      31
     4 |        2 |         5 |      32
     4 |        2 |         5 |      33
     4 |        2 |         5 |      34
     4 |        2 |         5 |      35
     4 |        2 |         5 |      36
     4 |        2 |         5 |      37
     4 |        2 |         5 |      38
     4 |        2 |         5 |      39
     4 |        2 |         5 |      40
     4 |        2 |         5 |      41
     4 |        2 |         5 |      42
     4 |        2 |         5 |      43
     4 |        2 |         5 |      44
     4 |        2 |         5 |      45
     4 |        2 |         5 |      46
     4 |        2 |         5 |      47
     4 |        2 |         5 |      48
     4 |        2 |         5 |      49
     4 |        2 |         5 |      50
     4 |        2 |         5 |      51
     4 |        2 |         5 |      52
     4 |        2 |         5 |      53
     4 |        2 |         5 |      54
     4 |        2 |         5 |      55
     4 |        2 |         5 |      56
     4 |        2 |         5 |      57
     4 |        2 |         5 |      58
     4 |        2 |         5 |      59
     4 |        2 |         5 |      60
     4 |        2 |         5 |      61
     4 |        2 |         5 |      62
     4 |        2 |         5 |      63
     4 |        2 |         5 |      64
     4 |        2 |         5 |      65
     4 |        2 |         5 |      66
     4 |        2 |         5 |      67
     4 |        2 |         5 |      68
     4 |        2 |         5 |      69
     4 |        2 |         5 |      70
     4 |        2 |         5 |      71
     4 |        2 |         5 |      72
     4 |        2 |         5 |      73
     4 |        2 |         5 |      74
     4 |        2 |         5 |      75
     4 |        2 |         5 |      76
     4 |        2 |         5 |      77
     4 |        2 |         5 |      78
     4 |        2 |         5 |      79
     4 |        2 |         5 |      80
     4 |        2 |         5 |      81
     4 |        2 |         5 |      82
     4 |        2 |         5 |      83
     4 |        2 |         5 |      84
     4 |        2 |         5 |      85
     4 |        2 |         5 |      86
     4 |        2 |         5 |      87
     4 |        2 |         5 |      88
     4 |        2 |         5 |      89
     4 |        2 |         5 |      90
     4 |        2 |         5 |      91
     4 |        2 |         5 |      92
     4 |        2 |         5 |      93
     4 |        2 |         5 |      94
     4 |        2 |         5 |      95
     4 |        2 |         5 |      96
     4 |        2 |         5 |      97
     4 |        2 |         5 |      98
     4 |        2 |         5 |      99
     4 |        2 |         5 |     100
     4 |        2 |         5 |     101
     4 |        2 |         5 |     102
     4 |        2 |         5 |     103
     4 |        2 |         5 |     104
     4 |        2 |         5 |     105
     4 |        2 |         5 |     106
     4 |        2 |         5 |     107
     4 |        2 |         5 |     108
     4 |        2 |         5 |     109
     4 |        2 |         5 |     110
     4 |        2 |         5 |     111
     4 |        2 |         5 |     112
     4 |        2 |         5 |     113
     4 |        2 |         5 |     114
     4 |        2 |         5 |     115
     4 |        2 |         5 |     116
     4 |        2 |         5 |     117
     4 |        2 |         5 |     118
     4 |        2 |         5 |     119
     4 |        2 |         5 |     120
     4 |        2 |         5 |     121
     4 |        2 |         5 |     122
     4 |        2 |         5 |     123
     4 |        2 |         5 |     124
     4 |        2 |         5 |     125
     4 |        2 |         5 |     126
     4 |        2 |         5 |     127
     4 |        2 |         5 |     128
     4 |        2 |         5 |     129
     4 |        2 |         5 |     130
     4 |        2 |         5 |     131
     4 |        2 |         5 |     132
     4 |        2 |         5 |     133
     4 |        2 |         5 |     134
     4 |        2 |         5 |     135
     4 |        2 |         5 |     136
     4 |        2 |         5 |     137
     4 |        2 |         5 |     138
     4 |        2 |         5 |     139
     4 |        2 |         5 |     140
     4 |        2 |         5 |     141
     4 |        2 |         5 |     142
     4 |        2 |         5 |     143
     4 |        2 |         5 |     144
     4 |        2 |         5 |     145
     4 |        2 |         5 |     146
     4 |        2 |         5 |     147
     4 |        2 |         5 |     148
     4 |        2 |         5 |     149
     4 |        2 |         5 |     150
     4 |        3 |         4 |     150
     4 |        3 |         5 |       1
     4 |        3 |         5 |       2
     4 |        3 |         5 |       3
     4 |        3 |         5 |       4
     4 |        3 |         5 |       5
     4 |        3 |         5 |       6
     4 |        3 |         5 |       7
     4 |        3 |         5 |       8
     4 |        3 |         5 |       9
     4 |        3 |         5 |      10
     4 |        3 |         5 |      11
     4 |        3 |         5 |      12
     4 |        3 |         5 |      13
     4 |        3 |         5 |      14
     4 |        3 |         5 |      15
     4 |        3 |         5 |      16
     4 |        3 |         5 |      17
     4 |        3 |         5 |      18
     4 |        3 |         5 |      19
     4 |        3 |         5 |      20
     4 |        3 |         5 |      21
     4 |        3 |         5 |      22
     4 |        3 |         5 |      23
     4 |        3 |         5 |      24
     4 |        3 |         5 |      25
     4 |        3 |         5 |      26
     4 |        3 |         5 |      27
     4 |        3 |         5 |      28
     4 |        3 |         5 |      29
     4 |        3 |         5 |      30
     4 |        3 |         5 |      31
     4 |        3 |         5 |      32
     4 |        3 |         5 |      33
     4 |        3 |         5 |      34
     4 |        3 |         5 |      35
     4 |        3 |         5 |      36
     4 |        3 |         5 |      37
     4 |        3 |         5 |      38
     4 |        3 |         5 |      39
     4 |        3 |         5 |      40
     4 |        3 |         5 |      41
     4 |        3 |         5 |      42
     4 |        3 |         5 |      43
     4 |        3 |         5 |      44
     4 |        3 |         5 |      45
     4 |        3 |         5 |      46
     4 |        3 |         5 |      47
     4 |        3 |         5 |      48
     4 |        3 |         5 |      49
     4 |        3 |         5 |      50
     4 |        3 |         5 |      51
     4 |        3 |         5 |      52
     4 |        3 |         5 |      53
     4 |        3 |         5 |      54
     4 |        3 |         5 |      55
     4 |        3 |         5 |      56
     4 |        3 |         5 |      57
     4 |        3 |         5 |      58
     4 |        3 |         5 |      59
     4 |        3 |         5 |      60
     4 |        3 |         5 |      61
     4 |        3 |         5 |      62
     4 |        3 |         5 |      63
     4 |        3 |         5 |      64
     4 |        3 |         5 |      65
     4 |        3 |         5 |      66
     4 |        3 |         5 |      67
     4 |        3 |         5 |      68
     4 |        3 |         5 |      69
     4 |        3 |         5 |      70
     4 |        3 |         5 |      71
     4 |        3 |         5 |      72
     4 |        3 |         5 |      73
     4 |        3 |         5 |      74
     4 |        3 |         5 |      75
     4 |        3 |         5 |      76
     4 |        3 |         5 |      77
     4 |        3 |         5 |      78
     4 |        3 |         5 |      79
     4 |        3 |         5 |      80
     4 |        3 |         5 |      81
     4 |        3 |         5 |      82
     4 |        3 |         5 |      83
     4 |        3 |         5 |      84
     4 |        3 |         5 |      85
     4 |        3 |         5 |      86
     4 |        3 |         5 |      87
     4 |        3 |         5 |      88
     4 |        3 |         5 |      89
     4 |        3 |         5 |      90
     4 |        3 |         5 |      91
     4 |        3 |         5 |      92
     4 |        3 |         5 |      93
     4 |        3 |         5 |      94
     4 |        3 |         5 |      95
     4 |        3 |         5 |      96
     4 |        3 |         5 |      97
     4 |        3 |         5 |      98
     4 |        3 |         5 |      99
     4 |        3 |         5 |     100
     4 |        3 |         5 |     101
     4 |        3 |         5 |     102
     4 |        3 |         5 |     103
     4 |        3 |         5 |     104
     4 |        3 |         5 |     105
     4 |        3 |         5 |     106
     4 |        3 |         5 |     107
     4 |        3 |         5 |     108
     4 |        3 |         5 |     109
     4 |        3 |         5 |     110
     4 |        3 |         5 |     111
     4 |        3 |         5 |     112
     4 |        3 |         5 |     113
     4 |        3 |         5 |     114
     4 |        3 |         5 |     115
     4 |        3 |         5 |     116
     4 |        3 |         5 |     117
     4 |        3 |         5 |     118
     4 |        3 |         5 |     119
     4 |        3 |         5 |     120
     4 |        3 |         5 |     121
     4 |        3 |         5 |     122
     4 |        3 |         5 |     123
     4 |        3 |         5 |     124
     4 |        3 |         5 |     125
     4 |        3 |         5 |     126
     4 |        3 |         5 |     127
     4 |        3 |         5 |     128
     4 |        3 |         5 |     129
     4 |        3 |         5 |     130
     4 |        3 |         5 |     131
     4 |        3 |         5 |     132
     4 |        3 |         5 |     133
     4 |        3 |         5 |     134
     4 |        3 |         5 |     135
     4 |        3 |         5 |     136
     4 |        3 |         5 |     137
     4 |        3 |         5 |     138
     4 |        3 |         5 |     139
     4 |        3 |         5 |     140
     4 |        3 |         5 |     141
     4 |        3 |         5 |     142
     4 |        3 |         5 |     143
     4 |        3 |         5 |     144
     4 |        3 |         5 |     145
     4 |        3 |         5 |     146
     4 |        3 |         5 |     147
     4 |        3 |         5 |     148
     4 |        3 |         5 |     149
     4 |        3 |         5 |     150
(453 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare;
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..254.95 rows=990 width=20) (actual rows=453 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=82
   ->  Index Scan using must_not_full_scan on redescend_test  (cost=0.29..232.38 rows=1267 width=12) (actual rows=1812 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) > ROW(4, 149)) AND (orderline = ANY ('{-5,1,7,9,10,11}'::integer[])))
         Buffers: shared hit=82
(6 rows)

deallocate test_rowcompare;
-- Test > RowCompare + non-required SAOPs, but with NULL RowCompare
prepare test_rowcompare_null as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) > (4, NULL) and orderline in (-5,1,7,9,10,11)
group by district, warehouse, orderid
order by district, warehouse, orderid;
execute test_rowcompare_null;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
     4 |        1 |         5 |       1
     4 |        1 |         5 |       2
     4 |        1 |         5 |       3
     4 |        1 |         5 |       4
     4 |        1 |         5 |       5
     4 |        1 |         5 |       6
     4 |        1 |         5 |       7
     4 |        1 |         5 |       8
     4 |        1 |         5 |       9
     4 |        1 |         5 |      10
     4 |        1 |         5 |      11
     4 |        1 |         5 |      12
     4 |        1 |         5 |      13
     4 |        1 |         5 |      14
     4 |        1 |         5 |      15
     4 |        1 |         5 |      16
     4 |        1 |         5 |      17
     4 |        1 |         5 |      18
     4 |        1 |         5 |      19
     4 |        1 |         5 |      20
     4 |        1 |         5 |      21
     4 |        1 |         5 |      22
     4 |        1 |         5 |      23
     4 |        1 |         5 |      24
     4 |        1 |         5 |      25
     4 |        1 |         5 |      26
     4 |        1 |         5 |      27
     4 |        1 |         5 |      28
     4 |        1 |         5 |      29
     4 |        1 |         5 |      30
     4 |        1 |         5 |      31
     4 |        1 |         5 |      32
     4 |        1 |         5 |      33
     4 |        1 |         5 |      34
     4 |        1 |         5 |      35
     4 |        1 |         5 |      36
     4 |        1 |         5 |      37
     4 |        1 |         5 |      38
     4 |        1 |         5 |      39
     4 |        1 |         5 |      40
     4 |        1 |         5 |      41
     4 |        1 |         5 |      42
     4 |        1 |         5 |      43
     4 |        1 |         5 |      44
     4 |        1 |         5 |      45
     4 |        1 |         5 |      46
     4 |        1 |         5 |      47
     4 |        1 |         5 |      48
     4 |        1 |         5 |      49
     4 |        1 |         5 |      50
     4 |        1 |         5 |      51
     4 |        1 |         5 |      52
     4 |        1 |         5 |      53
     4 |        1 |         5 |      54
     4 |        1 |         5 |      55
     4 |        1 |         5 |      56
     4 |        1 |         5 |      57
     4 |        1 |         5 |      58
     4 |        1 |         5 |      59
     4 |        1 |         5 |      60
     4 |        1 |         5 |      61
     4 |        1 |         5 |      62
     4 |        1 |         5 |      63
     4 |        1 |         5 |      64
     4 |        1 |         5 |      65
     4 |        1 |         5 |      66
     4 |        1 |         5 |      67
     4 |        1 |         5 |      68
     4 |        1 |         5 |      69
     4 |        1 |         5 |      70
     4 |        1 |         5 |      71
     4 |        1 |         5 |      72
     4 |        1 |         5 |      73
     4 |        1 |         5 |      74
     4 |        1 |         5 |      75
     4 |        1 |         5 |      76
     4 |        1 |         5 |      77
     4 |        1 |         5 |      78
     4 |        1 |         5 |      79
     4 |        1 |         5 |      80
     4 |        1 |         5 |      81
     4 |        1 |         5 |      82
     4 |        1 |         5 |      83
     4 |        1 |         5 |      84
     4 |        1 |         5 |      85
     4 |        1 |         5 |      86
     4 |        1 |         5 |      87
     4 |        1 |         5 |      88
     4 |        1 |         5 |      89
     4 |        1 |         5 |      90
     4 |        1 |         5 |      91
     4 |        1 |         5 |      92
     4 |        1 |         5 |      93
     4 |        1 |         5 |      94
     4 |        1 |         5 |      95
     4 |        1 |         5 |      96
     4 |        1 |         5 |      97
     4 |        1 |         5 |      98
     4 |        1 |         5 |      99
     4 |        1 |         5 |     100
     4 |        1 |         5 |     101
     4 |        1 |         5 |     102
     4 |        1 |         5 |     103
     4 |        1 |         5 |     104
     4 |        1 |         5 |     105
     4 |        1 |         5 |     106
     4 |        1 |         5 |     107
     4 |        1 |         5 |     108
     4 |        1 |         5 |     109
     4 |        1 |         5 |     110
     4 |        1 |         5 |     111
     4 |        1 |         5 |     112
     4 |        1 |         5 |     113
     4 |        1 |         5 |     114
     4 |        1 |         5 |     115
     4 |        1 |         5 |     116
     4 |        1 |         5 |     117
     4 |        1 |         5 |     118
     4 |        1 |         5 |     119
     4 |        1 |         5 |     120
     4 |        1 |         5 |     121
     4 |        1 |         5 |     122
     4 |        1 |         5 |     123
     4 |        1 |         5 |     124
     4 |        1 |         5 |     125
     4 |        1 |         5 |     126
     4 |        1 |         5 |     127
     4 |        1 |         5 |     128
     4 |        1 |         5 |     129
     4 |        1 |         5 |     130
     4 |        1 |         5 |     131
     4 |        1 |         5 |     132
     4 |        1 |         5 |     133
     4 |        1 |         5 |     134
     4 |        1 |         5 |     135
     4 |        1 |         5 |     136
     4 |        1 |         5 |     137
     4 |        1 |         5 |     138
     4 |        1 |         5 |     139
     4 |        1 |         5 |     140
     4 |        1 |         5 |     141
     4 |        1 |         5 |     142
     4 |        1 |         5 |     143
     4 |        1 |         5 |     144
     4 |        1 |         5 |     145
     4 |        1 |         5 |     146
     4 |        1 |         5 |     147
     4 |        1 |         5 |     148
     4 |        1 |         5 |     149
     4 |        1 |         5 |     150
     4 |        2 |         5 |       1
     4 |        2 |         5 |       2
     4 |        2 |         5 |       3
     4 |        2 |         5 |       4
     4 |        2 |         5 |       5
     4 |        2 |         5 |       6
     4 |        2 |         5 |       7
     4 |        2 |         5 |       8
     4 |        2 |         5 |       9
     4 |        2 |         5 |      10
     4 |        2 |         5 |      11
     4 |        2 |         5 |      12
     4 |        2 |         5 |      13
     4 |        2 |         5 |      14
     4 |        2 |         5 |      15
     4 |        2 |         5 |      16
     4 |        2 |         5 |      17
     4 |        2 |         5 |      18
     4 |        2 |         5 |      19
     4 |        2 |         5 |      20
     4 |        2 |         5 |      21
     4 |        2 |         5 |      22
     4 |        2 |         5 |      23
     4 |        2 |         5 |      24
     4 |        2 |         5 |      25
     4 |        2 |         5 |      26
     4 |        2 |         5 |      27
     4 |        2 |         5 |      28
     4 |        2 |         5 |      29
     4 |        2 |         5 |      30
     4 |        2 |         5 |      31
     4 |        2 |         5 |      32
     4 |        2 |         5 |      33
     4 |        2 |         5 |      34
     4 |        2 |         5 |      35
     4 |        2 |         5 |      36
     4 |        2 |         5 |      37
     4 |        2 |         5 |      38
     4 |        2 |         5 |      39
     4 |        2 |         5 |      40
     4 |        2 |         5 |      41
     4 |        2 |         5 |      42
     4 |        2 |         5 |      43
     4 |        2 |         5 |      44
     4 |        2 |         5 |      45
     4 |        2 |         5 |      46
     4 |        2 |         5 |      47
     4 |        2 |         5 |      48
     4 |        2 |         5 |      49
     4 |        2 |         5 |      50
     4 |        2 |         5 |      51
     4 |        2 |         5 |      52
     4 |        2 |         5 |      53
     4 |        2 |         5 |      54
     4 |        2 |         5 |      55
     4 |        2 |         5 |      56
     4 |        2 |         5 |      57
     4 |        2 |         5 |      58
     4 |        2 |         5 |      59
     4 |        2 |         5 |      60
     4 |        2 |         5 |      61
     4 |        2 |         5 |      62
     4 |        2 |         5 |      63
     4 |        2 |         5 |      64
     4 |        2 |         5 |      65
     4 |        2 |         5 |      66
     4 |        2 |         5 |      67
     4 |        2 |         5 |      68
     4 |        2 |         5 |      69
     4 |        2 |         5 |      70
     4 |        2 |         5 |      71
     4 |        2 |         5 |      72
     4 |        2 |         5 |      73
     4 |        2 |         5 |      74
     4 |        2 |         5 |      75
     4 |        2 |         5 |      76
     4 |        2 |         5 |      77
     4 |        2 |         5 |      78
     4 |        2 |         5 |      79
     4 |        2 |         5 |      80
     4 |        2 |         5 |      81
     4 |        2 |         5 |      82
     4 |        2 |         5 |      83
     4 |        2 |         5 |      84
     4 |        2 |         5 |      85
     4 |        2 |         5 |      86
     4 |        2 |         5 |      87
     4 |        2 |         5 |      88
     4 |        2 |         5 |      89
     4 |        2 |         5 |      90
     4 |        2 |         5 |      91
     4 |        2 |         5 |      92
     4 |        2 |         5 |      93
     4 |        2 |         5 |      94
     4 |        2 |         5 |      95
     4 |        2 |         5 |      96
     4 |        2 |         5 |      97
     4 |        2 |         5 |      98
     4 |        2 |         5 |      99
     4 |        2 |         5 |     100
     4 |        2 |         5 |     101
     4 |        2 |         5 |     102
     4 |        2 |         5 |     103
     4 |        2 |         5 |     104
     4 |        2 |         5 |     105
     4 |        2 |         5 |     106
     4 |        2 |         5 |     107
     4 |        2 |         5 |     108
     4 |        2 |         5 |     109
     4 |        2 |         5 |     110
     4 |        2 |         5 |     111
     4 |        2 |         5 |     112
     4 |        2 |         5 |     113
     4 |        2 |         5 |     114
     4 |        2 |         5 |     115
     4 |        2 |         5 |     116
     4 |        2 |         5 |     117
     4 |        2 |         5 |     118
     4 |        2 |         5 |     119
     4 |        2 |         5 |     120
     4 |        2 |         5 |     121
     4 |        2 |         5 |     122
     4 |        2 |         5 |     123
     4 |        2 |         5 |     124
     4 |        2 |         5 |     125
     4 |        2 |         5 |     126
     4 |        2 |         5 |     127
     4 |        2 |         5 |     128
     4 |        2 |         5 |     129
     4 |        2 |         5 |     130
     4 |        2 |         5 |     131
     4 |        2 |         5 |     132
     4 |        2 |         5 |     133
     4 |        2 |         5 |     134
     4 |        2 |         5 |     135
     4 |        2 |         5 |     136
     4 |        2 |         5 |     137
     4 |        2 |         5 |     138
     4 |        2 |         5 |     139
     4 |        2 |         5 |     140
     4 |        2 |         5 |     141
     4 |        2 |         5 |     142
     4 |        2 |         5 |     143
     4 |        2 |         5 |     144
     4 |        2 |         5 |     145
     4 |        2 |         5 |     146
     4 |        2 |         5 |     147
     4 |        2 |         5 |     148
     4 |        2 |         5 |     149
     4 |        2 |         5 |     150
     4 |        3 |         5 |       1
     4 |        3 |         5 |       2
     4 |        3 |         5 |       3
     4 |        3 |         5 |       4
     4 |        3 |         5 |       5
     4 |        3 |         5 |       6
     4 |        3 |         5 |       7
     4 |        3 |         5 |       8
     4 |        3 |         5 |       9
     4 |        3 |         5 |      10
     4 |        3 |         5 |      11
     4 |        3 |         5 |      12
     4 |        3 |         5 |      13
     4 |        3 |         5 |      14
     4 |        3 |         5 |      15
     4 |        3 |         5 |      16
     4 |        3 |         5 |      17
     4 |        3 |         5 |      18
     4 |        3 |         5 |      19
     4 |        3 |         5 |      20
     4 |        3 |         5 |      21
     4 |        3 |         5 |      22
     4 |        3 |         5 |      23
     4 |        3 |         5 |      24
     4 |        3 |         5 |      25
     4 |        3 |         5 |      26
     4 |        3 |         5 |      27
     4 |        3 |         5 |      28
     4 |        3 |         5 |      29
     4 |        3 |         5 |      30
     4 |        3 |         5 |      31
     4 |        3 |         5 |      32
     4 |        3 |         5 |      33
     4 |        3 |         5 |      34
     4 |        3 |         5 |      35
     4 |        3 |         5 |      36
     4 |        3 |         5 |      37
     4 |        3 |         5 |      38
     4 |        3 |         5 |      39
     4 |        3 |         5 |      40
     4 |        3 |         5 |      41
     4 |        3 |         5 |      42
     4 |        3 |         5 |      43
     4 |        3 |         5 |      44
     4 |        3 |         5 |      45
     4 |        3 |         5 |      46
     4 |        3 |         5 |      47
     4 |        3 |         5 |      48
     4 |        3 |         5 |      49
     4 |        3 |         5 |      50
     4 |        3 |         5 |      51
     4 |        3 |         5 |      52
     4 |        3 |         5 |      53
     4 |        3 |         5 |      54
     4 |        3 |         5 |      55
     4 |        3 |         5 |      56
     4 |        3 |         5 |      57
     4 |        3 |         5 |      58
     4 |        3 |         5 |      59
     4 |        3 |         5 |      60
     4 |        3 |         5 |      61
     4 |        3 |         5 |      62
     4 |        3 |         5 |      63
     4 |        3 |         5 |      64
     4 |        3 |         5 |      65
     4 |        3 |         5 |      66
     4 |        3 |         5 |      67
     4 |        3 |         5 |      68
     4 |        3 |         5 |      69
     4 |        3 |         5 |      70
     4 |        3 |         5 |      71
     4 |        3 |         5 |      72
     4 |        3 |         5 |      73
     4 |        3 |         5 |      74
     4 |        3 |         5 |      75
     4 |        3 |         5 |      76
     4 |        3 |         5 |      77
     4 |        3 |         5 |      78
     4 |        3 |         5 |      79
     4 |        3 |         5 |      80
     4 |        3 |         5 |      81
     4 |        3 |         5 |      82
     4 |        3 |         5 |      83
     4 |        3 |         5 |      84
     4 |        3 |         5 |      85
     4 |        3 |         5 |      86
     4 |        3 |         5 |      87
     4 |        3 |         5 |      88
     4 |        3 |         5 |      89
     4 |        3 |         5 |      90
     4 |        3 |         5 |      91
     4 |        3 |         5 |      92
     4 |        3 |         5 |      93
     4 |        3 |         5 |      94
     4 |        3 |         5 |      95
     4 |        3 |         5 |      96
     4 |        3 |         5 |      97
     4 |        3 |         5 |      98
     4 |        3 |         5 |      99
     4 |        3 |         5 |     100
     4 |        3 |         5 |     101
     4 |        3 |         5 |     102
     4 |        3 |         5 |     103
     4 |        3 |         5 |     104
     4 |        3 |         5 |     105
     4 |        3 |         5 |     106
     4 |        3 |         5 |     107
     4 |        3 |         5 |     108
     4 |        3 |         5 |     109
     4 |        3 |         5 |     110
     4 |        3 |         5 |     111
     4 |        3 |         5 |     112
     4 |        3 |         5 |     113
     4 |        3 |         5 |     114
     4 |        3 |         5 |     115
     4 |        3 |         5 |     116
     4 |        3 |         5 |     117
     4 |        3 |         5 |     118
     4 |        3 |         5 |     119
     4 |        3 |         5 |     120
     4 |        3 |         5 |     121
     4 |        3 |         5 |     122
     4 |        3 |         5 |     123
     4 |        3 |         5 |     124
     4 |        3 |         5 |     125
     4 |        3 |         5 |     126
     4 |        3 |         5 |     127
     4 |        3 |         5 |     128
     4 |        3 |         5 |     129
     4 |        3 |         5 |     130
     4 |        3 |         5 |     131
     4 |        3 |         5 |     132
     4 |        3 |         5 |     133
     4 |        3 |         5 |     134
     4 |        3 |         5 |     135
     4 |        3 |         5 |     136
     4 |        3 |         5 |     137
     4 |        3 |         5 |     138
     4 |        3 |         5 |     139
     4 |        3 |         5 |     140
     4 |        3 |         5 |     141
     4 |        3 |         5 |     142
     4 |        3 |         5 |     143
     4 |        3 |         5 |     144
     4 |        3 |         5 |     145
     4 |        3 |         5 |     146
     4 |        3 |         5 |     147
     4 |        3 |         5 |     148
     4 |        3 |         5 |     149
     4 |        3 |         5 |     150
(450 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare_null;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..254.95 rows=990 width=20) (actual rows=450 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=131
   ->  Index Scan using must_not_full_scan on redescend_test  (cost=0.29..232.38 rows=1267 width=12) (actual rows=1800 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) > ROW(4, NULL::integer)) AND (orderline = ANY ('{-5,1,7,9,10,11}'::integer[])))
         Buffers: shared hit=131
(6 rows)

deallocate test_rowcompare_null;
-- Test >= RowCompare
prepare test_rowcompare as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) >= (5, 149)
group by district, warehouse, orderid
order by district, warehouse, orderid;
execute test_rowcompare;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
    10 |        1 |         5 |     149
    10 |        1 |         5 |     150
    10 |        2 |         5 |     149
    10 |        2 |         5 |     150
    10 |        3 |         5 |     149
    10 |        3 |         5 |     150
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..298.88 rows=1756 width=20) (actual rows=6 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=10
   ->  Index Scan using must_not_full_scan on redescend_test  (cost=0.29..249.65 rows=3167 width=12) (actual rows=60 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) >= ROW(5, 149)))
         Buffers: shared hit=10
(6 rows)

deallocate test_rowcompare;
-- Test >= RowCompare + non-required SAOPs
prepare test_rowcompare as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) >= (5, 149) and orderline in (-5,1,7,9,10,11)
group by district, warehouse, orderid
order by district, warehouse, orderid;
execute test_rowcompare;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
     4 |        1 |         5 |     149
     4 |        1 |         5 |     150
     4 |        2 |         5 |     149
     4 |        2 |         5 |     150
     4 |        3 |         5 |     149
     4 |        3 |         5 |     150
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..254.95 rows=990 width=20) (actual rows=6 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=10
   ->  Index Scan using must_not_full_scan on redescend_test  (cost=0.29..232.38 rows=1267 width=12) (actual rows=24 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) >= ROW(5, 149)) AND (orderline = ANY ('{-5,1,7,9,10,11}'::integer[])))
         Buffers: shared hit=10
(6 rows)

deallocate test_rowcompare;
-- Test < RowCompare (backwards scan)
prepare test_rowcompare as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) < (2, 2)
group by district, warehouse, orderid
order by district desc, warehouse desc, orderid desc;
execute test_rowcompare;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
    10 |        3 |         2 |       1
    10 |        3 |         1 |     150
    10 |        3 |         1 |     149
    10 |        3 |         1 |     148
    10 |        3 |         1 |     147
    10 |        3 |         1 |     146
    10 |        3 |         1 |     145
    10 |        3 |         1 |     144
    10 |        3 |         1 |     143
    10 |        3 |         1 |     142
    10 |        3 |         1 |     141
    10 |        3 |         1 |     140
    10 |        3 |         1 |     139
    10 |        3 |         1 |     138
    10 |        3 |         1 |     137
    10 |        3 |         1 |     136
    10 |        3 |         1 |     135
    10 |        3 |         1 |     134
    10 |        3 |         1 |     133
    10 |        3 |         1 |     132
    10 |        3 |         1 |     131
    10 |        3 |         1 |     130
    10 |        3 |         1 |     129
    10 |        3 |         1 |     128
    10 |        3 |         1 |     127
    10 |        3 |         1 |     126
    10 |        3 |         1 |     125
    10 |        3 |         1 |     124
    10 |        3 |         1 |     123
    10 |        3 |         1 |     122
    10 |        3 |         1 |     121
    10 |        3 |         1 |     120
    10 |        3 |         1 |     119
    10 |        3 |         1 |     118
    10 |        3 |         1 |     117
    10 |        3 |         1 |     116
    10 |        3 |         1 |     115
    10 |        3 |         1 |     114
    10 |        3 |         1 |     113
    10 |        3 |         1 |     112
    10 |        3 |         1 |     111
    10 |        3 |         1 |     110
    10 |        3 |         1 |     109
    10 |        3 |         1 |     108
    10 |        3 |         1 |     107
    10 |        3 |         1 |     106
    10 |        3 |         1 |     105
    10 |        3 |         1 |     104
    10 |        3 |         1 |     103
    10 |        3 |         1 |     102
    10 |        3 |         1 |     101
    10 |        3 |         1 |     100
    10 |        3 |         1 |      99
    10 |        3 |         1 |      98
    10 |        3 |         1 |      97
    10 |        3 |         1 |      96
    10 |        3 |         1 |      95
    10 |        3 |         1 |      94
    10 |        3 |         1 |      93
    10 |        3 |         1 |      92
    10 |        3 |         1 |      91
    10 |        3 |         1 |      90
    10 |        3 |         1 |      89
    10 |        3 |         1 |      88
    10 |        3 |         1 |      87
    10 |        3 |         1 |      86
    10 |        3 |         1 |      85
    10 |        3 |         1 |      84
    10 |        3 |         1 |      83
    10 |        3 |         1 |      82
    10 |        3 |         1 |      81
    10 |        3 |         1 |      80
    10 |        3 |         1 |      79
    10 |        3 |         1 |      78
    10 |        3 |         1 |      77
    10 |        3 |         1 |      76
    10 |        3 |         1 |      75
    10 |        3 |         1 |      74
    10 |        3 |         1 |      73
    10 |        3 |         1 |      72
    10 |        3 |         1 |      71
    10 |        3 |         1 |      70
    10 |        3 |         1 |      69
    10 |        3 |         1 |      68
    10 |        3 |         1 |      67
    10 |        3 |         1 |      66
    10 |        3 |         1 |      65
    10 |        3 |         1 |      64
    10 |        3 |         1 |      63
    10 |        3 |         1 |      62
    10 |        3 |         1 |      61
    10 |        3 |         1 |      60
    10 |        3 |         1 |      59
    10 |        3 |         1 |      58
    10 |        3 |         1 |      57
    10 |        3 |         1 |      56
    10 |        3 |         1 |      55
    10 |        3 |         1 |      54
    10 |        3 |         1 |      53
    10 |        3 |         1 |      52
    10 |        3 |         1 |      51
    10 |        3 |         1 |      50
    10 |        3 |         1 |      49
    10 |        3 |         1 |      48
    10 |        3 |         1 |      47
    10 |        3 |         1 |      46
    10 |        3 |         1 |      45
    10 |        3 |         1 |      44
    10 |        3 |         1 |      43
    10 |        3 |         1 |      42
    10 |        3 |         1 |      41
    10 |        3 |         1 |      40
    10 |        3 |         1 |      39
    10 |        3 |         1 |      38
    10 |        3 |         1 |      37
    10 |        3 |         1 |      36
    10 |        3 |         1 |      35
    10 |        3 |         1 |      34
    10 |        3 |         1 |      33
    10 |        3 |         1 |      32
    10 |        3 |         1 |      31
    10 |        3 |         1 |      30
    10 |        3 |         1 |      29
    10 |        3 |         1 |      28
    10 |        3 |         1 |      27
    10 |        3 |         1 |      26
    10 |        3 |         1 |      25
    10 |        3 |         1 |      24
    10 |        3 |         1 |      23
    10 |        3 |         1 |      22
    10 |        3 |         1 |      21
    10 |        3 |         1 |      20
    10 |        3 |         1 |      19
    10 |        3 |         1 |      18
    10 |        3 |         1 |      17
    10 |        3 |         1 |      16
    10 |        3 |         1 |      15
    10 |        3 |         1 |      14
    10 |        3 |         1 |      13
    10 |        3 |         1 |      12
    10 |        3 |         1 |      11
    10 |        3 |         1 |      10
    10 |        3 |         1 |       9
    10 |        3 |         1 |       8
    10 |        3 |         1 |       7
    10 |        3 |         1 |       6
    10 |        3 |         1 |       5
    10 |        3 |         1 |       4
    10 |        3 |         1 |       3
    10 |        3 |         1 |       2
    10 |        3 |         1 |       1
    10 |        2 |         2 |       1
    10 |        2 |         1 |     150
    10 |        2 |         1 |     149
    10 |        2 |         1 |     148
    10 |        2 |         1 |     147
    10 |        2 |         1 |     146
    10 |        2 |         1 |     145
    10 |        2 |         1 |     144
    10 |        2 |         1 |     143
    10 |        2 |         1 |     142
    10 |        2 |         1 |     141
    10 |        2 |         1 |     140
    10 |        2 |         1 |     139
    10 |        2 |         1 |     138
    10 |        2 |         1 |     137
    10 |        2 |         1 |     136
    10 |        2 |         1 |     135
    10 |        2 |         1 |     134
    10 |        2 |         1 |     133
    10 |        2 |         1 |     132
    10 |        2 |         1 |     131
    10 |        2 |         1 |     130
    10 |        2 |         1 |     129
    10 |        2 |         1 |     128
    10 |        2 |         1 |     127
    10 |        2 |         1 |     126
    10 |        2 |         1 |     125
    10 |        2 |         1 |     124
    10 |        2 |         1 |     123
    10 |        2 |         1 |     122
    10 |        2 |         1 |     121
    10 |        2 |         1 |     120
    10 |        2 |         1 |     119
    10 |        2 |         1 |     118
    10 |        2 |         1 |     117
    10 |        2 |         1 |     116
    10 |        2 |         1 |     115
    10 |        2 |         1 |     114
    10 |        2 |         1 |     113
    10 |        2 |         1 |     112
    10 |        2 |         1 |     111
    10 |        2 |         1 |     110
    10 |        2 |         1 |     109
    10 |        2 |         1 |     108
    10 |        2 |         1 |     107
    10 |        2 |         1 |     106
    10 |        2 |         1 |     105
    10 |        2 |         1 |     104
    10 |        2 |         1 |     103
    10 |        2 |         1 |     102
    10 |        2 |         1 |     101
    10 |        2 |         1 |     100
    10 |        2 |         1 |      99
    10 |        2 |         1 |      98
    10 |        2 |         1 |      97
    10 |        2 |         1 |      96
    10 |        2 |         1 |      95
    10 |        2 |         1 |      94
    10 |        2 |         1 |      93
    10 |        2 |         1 |      92
    10 |        2 |         1 |      91
    10 |        2 |         1 |      90
    10 |        2 |         1 |      89
    10 |        2 |         1 |      88
    10 |        2 |         1 |      87
    10 |        2 |         1 |      86
    10 |        2 |         1 |      85
    10 |        2 |         1 |      84
    10 |        2 |         1 |      83
    10 |        2 |         1 |      82
    10 |        2 |         1 |      81
    10 |        2 |         1 |      80
    10 |        2 |         1 |      79
    10 |        2 |         1 |      78
    10 |        2 |         1 |      77
    10 |        2 |         1 |      76
    10 |        2 |         1 |      75
    10 |        2 |         1 |      74
    10 |        2 |         1 |      73
    10 |        2 |         1 |      72
    10 |        2 |         1 |      71
    10 |        2 |         1 |      70
    10 |        2 |         1 |      69
    10 |        2 |         1 |      68
    10 |        2 |         1 |      67
    10 |        2 |         1 |      66
    10 |        2 |         1 |      65
    10 |        2 |         1 |      64
    10 |        2 |         1 |      63
    10 |        2 |         1 |      62
    10 |        2 |         1 |      61
    10 |        2 |         1 |      60
    10 |        2 |         1 |      59
    10 |        2 |         1 |      58
    10 |        2 |         1 |      57
    10 |        2 |         1 |      56
    10 |        2 |         1 |      55
    10 |        2 |         1 |      54
    10 |        2 |         1 |      53
    10 |        2 |         1 |      52
    10 |        2 |         1 |      51
    10 |        2 |         1 |      50
    10 |        2 |         1 |      49
    10 |        2 |         1 |      48
    10 |        2 |         1 |      47
    10 |        2 |         1 |      46
    10 |        2 |         1 |      45
    10 |        2 |         1 |      44
    10 |        2 |         1 |      43
    10 |        2 |         1 |      42
    10 |        2 |         1 |      41
    10 |        2 |         1 |      40
    10 |        2 |         1 |      39
    10 |        2 |         1 |      38
    10 |        2 |         1 |      37
    10 |        2 |         1 |      36
    10 |        2 |         1 |      35
    10 |        2 |         1 |      34
    10 |        2 |         1 |      33
    10 |        2 |         1 |      32
    10 |        2 |         1 |      31
    10 |        2 |         1 |      30
    10 |        2 |         1 |      29
    10 |        2 |         1 |      28
    10 |        2 |         1 |      27
    10 |        2 |         1 |      26
    10 |        2 |         1 |      25
    10 |        2 |         1 |      24
    10 |        2 |         1 |      23
    10 |        2 |         1 |      22
    10 |        2 |         1 |      21
    10 |        2 |         1 |      20
    10 |        2 |         1 |      19
    10 |        2 |         1 |      18
    10 |        2 |         1 |      17
    10 |        2 |         1 |      16
    10 |        2 |         1 |      15
    10 |        2 |         1 |      14
    10 |        2 |         1 |      13
    10 |        2 |         1 |      12
    10 |        2 |         1 |      11
    10 |        2 |         1 |      10
    10 |        2 |         1 |       9
    10 |        2 |         1 |       8
    10 |        2 |         1 |       7
    10 |        2 |         1 |       6
    10 |        2 |         1 |       5
    10 |        2 |         1 |       4
    10 |        2 |         1 |       3
    10 |        2 |         1 |       2
    10 |        2 |         1 |       1
    10 |        1 |         2 |       1
    10 |        1 |         1 |     150
    10 |        1 |         1 |     149
    10 |        1 |         1 |     148
    10 |        1 |         1 |     147
    10 |        1 |         1 |     146
    10 |        1 |         1 |     145
    10 |        1 |         1 |     144
    10 |        1 |         1 |     143
    10 |        1 |         1 |     142
    10 |        1 |         1 |     141
    10 |        1 |         1 |     140
    10 |        1 |         1 |     139
    10 |        1 |         1 |     138
    10 |        1 |         1 |     137
    10 |        1 |         1 |     136
    10 |        1 |         1 |     135
    10 |        1 |         1 |     134
    10 |        1 |         1 |     133
    10 |        1 |         1 |     132
    10 |        1 |         1 |     131
    10 |        1 |         1 |     130
    10 |        1 |         1 |     129
    10 |        1 |         1 |     128
    10 |        1 |         1 |     127
    10 |        1 |         1 |     126
    10 |        1 |         1 |     125
    10 |        1 |         1 |     124
    10 |        1 |         1 |     123
    10 |        1 |         1 |     122
    10 |        1 |         1 |     121
    10 |        1 |         1 |     120
    10 |        1 |         1 |     119
    10 |        1 |         1 |     118
    10 |        1 |         1 |     117
    10 |        1 |         1 |     116
    10 |        1 |         1 |     115
    10 |        1 |         1 |     114
    10 |        1 |         1 |     113
    10 |        1 |         1 |     112
    10 |        1 |         1 |     111
    10 |        1 |         1 |     110
    10 |        1 |         1 |     109
    10 |        1 |         1 |     108
    10 |        1 |         1 |     107
    10 |        1 |         1 |     106
    10 |        1 |         1 |     105
    10 |        1 |         1 |     104
    10 |        1 |         1 |     103
    10 |        1 |         1 |     102
    10 |        1 |         1 |     101
    10 |        1 |         1 |     100
    10 |        1 |         1 |      99
    10 |        1 |         1 |      98
    10 |        1 |         1 |      97
    10 |        1 |         1 |      96
    10 |        1 |         1 |      95
    10 |        1 |         1 |      94
    10 |        1 |         1 |      93
    10 |        1 |         1 |      92
    10 |        1 |         1 |      91
    10 |        1 |         1 |      90
    10 |        1 |         1 |      89
    10 |        1 |         1 |      88
    10 |        1 |         1 |      87
    10 |        1 |         1 |      86
    10 |        1 |         1 |      85
    10 |        1 |         1 |      84
    10 |        1 |         1 |      83
    10 |        1 |         1 |      82
    10 |        1 |         1 |      81
    10 |        1 |         1 |      80
    10 |        1 |         1 |      79
    10 |        1 |         1 |      78
    10 |        1 |         1 |      77
    10 |        1 |         1 |      76
    10 |        1 |         1 |      75
    10 |        1 |         1 |      74
    10 |        1 |         1 |      73
    10 |        1 |         1 |      72
    10 |        1 |         1 |      71
    10 |        1 |         1 |      70
    10 |        1 |         1 |      69
    10 |        1 |         1 |      68
    10 |        1 |         1 |      67
    10 |        1 |         1 |      66
    10 |        1 |         1 |      65
    10 |        1 |         1 |      64
    10 |        1 |         1 |      63
    10 |        1 |         1 |      62
    10 |        1 |         1 |      61
    10 |        1 |         1 |      60
    10 |        1 |         1 |      59
    10 |        1 |         1 |      58
    10 |        1 |         1 |      57
    10 |        1 |         1 |      56
    10 |        1 |         1 |      55
    10 |        1 |         1 |      54
    10 |        1 |         1 |      53
    10 |        1 |         1 |      52
    10 |        1 |         1 |      51
    10 |        1 |         1 |      50
    10 |        1 |         1 |      49
    10 |        1 |         1 |      48
    10 |        1 |         1 |      47
    10 |        1 |         1 |      46
    10 |        1 |         1 |      45
    10 |        1 |         1 |      44
    10 |        1 |         1 |      43
    10 |        1 |         1 |      42
    10 |        1 |         1 |      41
    10 |        1 |         1 |      40
    10 |        1 |         1 |      39
    10 |        1 |         1 |      38
    10 |        1 |         1 |      37
    10 |        1 |         1 |      36
    10 |        1 |         1 |      35
    10 |        1 |         1 |      34
    10 |        1 |         1 |      33
    10 |        1 |         1 |      32
    10 |        1 |         1 |      31
    10 |        1 |         1 |      30
    10 |        1 |         1 |      29
    10 |        1 |         1 |      28
    10 |        1 |         1 |      27
    10 |        1 |         1 |      26
    10 |        1 |         1 |      25
    10 |        1 |         1 |      24
    10 |        1 |         1 |      23
    10 |        1 |         1 |      22
    10 |        1 |         1 |      21
    10 |        1 |         1 |      20
    10 |        1 |         1 |      19
    10 |        1 |         1 |      18
    10 |        1 |         1 |      17
    10 |        1 |         1 |      16
    10 |        1 |         1 |      15
    10 |        1 |         1 |      14
    10 |        1 |         1 |      13
    10 |        1 |         1 |      12
    10 |        1 |         1 |      11
    10 |        1 |         1 |      10
    10 |        1 |         1 |       9
    10 |        1 |         1 |       8
    10 |        1 |         1 |       7
    10 |        1 |         1 |       6
    10 |        1 |         1 |       5
    10 |        1 |         1 |       4
    10 |        1 |         1 |       3
    10 |        1 |         1 |       2
    10 |        1 |         1 |       1
(453 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..298.88 rows=1756 width=20) (actual rows=453 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=83
   ->  Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..249.65 rows=3167 width=12) (actual rows=4530 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) < ROW(2, 2)))
         Buffers: shared hit=83
(6 rows)

deallocate test_rowcompare;
-- Test < RowCompare (backwards scan) + non-required SAOPs
prepare test_rowcompare as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) < (2, 2) and orderline in (-5,1,7,9,10,11)
group by district, warehouse, orderid
order by district desc, warehouse desc, orderid desc;
execute test_rowcompare;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
     4 |        3 |         2 |       1
     4 |        3 |         1 |     150
     4 |        3 |         1 |     149
     4 |        3 |         1 |     148
     4 |        3 |         1 |     147
     4 |        3 |         1 |     146
     4 |        3 |         1 |     145
     4 |        3 |         1 |     144
     4 |        3 |         1 |     143
     4 |        3 |         1 |     142
     4 |        3 |         1 |     141
     4 |        3 |         1 |     140
     4 |        3 |         1 |     139
     4 |        3 |         1 |     138
     4 |        3 |         1 |     137
     4 |        3 |         1 |     136
     4 |        3 |         1 |     135
     4 |        3 |         1 |     134
     4 |        3 |         1 |     133
     4 |        3 |         1 |     132
     4 |        3 |         1 |     131
     4 |        3 |         1 |     130
     4 |        3 |         1 |     129
     4 |        3 |         1 |     128
     4 |        3 |         1 |     127
     4 |        3 |         1 |     126
     4 |        3 |         1 |     125
     4 |        3 |         1 |     124
     4 |        3 |         1 |     123
     4 |        3 |         1 |     122
     4 |        3 |         1 |     121
     4 |        3 |         1 |     120
     4 |        3 |         1 |     119
     4 |        3 |         1 |     118
     4 |        3 |         1 |     117
     4 |        3 |         1 |     116
     4 |        3 |         1 |     115
     4 |        3 |         1 |     114
     4 |        3 |         1 |     113
     4 |        3 |         1 |     112
     4 |        3 |         1 |     111
     4 |        3 |         1 |     110
     4 |        3 |         1 |     109
     4 |        3 |         1 |     108
     4 |        3 |         1 |     107
     4 |        3 |         1 |     106
     4 |        3 |         1 |     105
     4 |        3 |         1 |     104
     4 |        3 |         1 |     103
     4 |        3 |         1 |     102
     4 |        3 |         1 |     101
     4 |        3 |         1 |     100
     4 |        3 |         1 |      99
     4 |        3 |         1 |      98
     4 |        3 |         1 |      97
     4 |        3 |         1 |      96
     4 |        3 |         1 |      95
     4 |        3 |         1 |      94
     4 |        3 |         1 |      93
     4 |        3 |         1 |      92
     4 |        3 |         1 |      91
     4 |        3 |         1 |      90
     4 |        3 |         1 |      89
     4 |        3 |         1 |      88
     4 |        3 |         1 |      87
     4 |        3 |         1 |      86
     4 |        3 |         1 |      85
     4 |        3 |         1 |      84
     4 |        3 |         1 |      83
     4 |        3 |         1 |      82
     4 |        3 |         1 |      81
     4 |        3 |         1 |      80
     4 |        3 |         1 |      79
     4 |        3 |         1 |      78
     4 |        3 |         1 |      77
     4 |        3 |         1 |      76
     4 |        3 |         1 |      75
     4 |        3 |         1 |      74
     4 |        3 |         1 |      73
     4 |        3 |         1 |      72
     4 |        3 |         1 |      71
     4 |        3 |         1 |      70
     4 |        3 |         1 |      69
     4 |        3 |         1 |      68
     4 |        3 |         1 |      67
     4 |        3 |         1 |      66
     4 |        3 |         1 |      65
     4 |        3 |         1 |      64
     4 |        3 |         1 |      63
     4 |        3 |         1 |      62
     4 |        3 |         1 |      61
     4 |        3 |         1 |      60
     4 |        3 |         1 |      59
     4 |        3 |         1 |      58
     4 |        3 |         1 |      57
     4 |        3 |         1 |      56
     4 |        3 |         1 |      55
     4 |        3 |         1 |      54
     4 |        3 |         1 |      53
     4 |        3 |         1 |      52
     4 |        3 |         1 |      51
     4 |        3 |         1 |      50
     4 |        3 |         1 |      49
     4 |        3 |         1 |      48
     4 |        3 |         1 |      47
     4 |        3 |         1 |      46
     4 |        3 |         1 |      45
     4 |        3 |         1 |      44
     4 |        3 |         1 |      43
     4 |        3 |         1 |      42
     4 |        3 |         1 |      41
     4 |        3 |         1 |      40
     4 |        3 |         1 |      39
     4 |        3 |         1 |      38
     4 |        3 |         1 |      37
     4 |        3 |         1 |      36
     4 |        3 |         1 |      35
     4 |        3 |         1 |      34
     4 |        3 |         1 |      33
     4 |        3 |         1 |      32
     4 |        3 |         1 |      31
     4 |        3 |         1 |      30
     4 |        3 |         1 |      29
     4 |        3 |         1 |      28
     4 |        3 |         1 |      27
     4 |        3 |         1 |      26
     4 |        3 |         1 |      25
     4 |        3 |         1 |      24
     4 |        3 |         1 |      23
     4 |        3 |         1 |      22
     4 |        3 |         1 |      21
     4 |        3 |         1 |      20
     4 |        3 |         1 |      19
     4 |        3 |         1 |      18
     4 |        3 |         1 |      17
     4 |        3 |         1 |      16
     4 |        3 |         1 |      15
     4 |        3 |         1 |      14
     4 |        3 |         1 |      13
     4 |        3 |         1 |      12
     4 |        3 |         1 |      11
     4 |        3 |         1 |      10
     4 |        3 |         1 |       9
     4 |        3 |         1 |       8
     4 |        3 |         1 |       7
     4 |        3 |         1 |       6
     4 |        3 |         1 |       5
     4 |        3 |         1 |       4
     4 |        3 |         1 |       3
     4 |        3 |         1 |       2
     4 |        3 |         1 |       1
     4 |        2 |         2 |       1
     4 |        2 |         1 |     150
     4 |        2 |         1 |     149
     4 |        2 |         1 |     148
     4 |        2 |         1 |     147
     4 |        2 |         1 |     146
     4 |        2 |         1 |     145
     4 |        2 |         1 |     144
     4 |        2 |         1 |     143
     4 |        2 |         1 |     142
     4 |        2 |         1 |     141
     4 |        2 |         1 |     140
     4 |        2 |         1 |     139
     4 |        2 |         1 |     138
     4 |        2 |         1 |     137
     4 |        2 |         1 |     136
     4 |        2 |         1 |     135
     4 |        2 |         1 |     134
     4 |        2 |         1 |     133
     4 |        2 |         1 |     132
     4 |        2 |         1 |     131
     4 |        2 |         1 |     130
     4 |        2 |         1 |     129
     4 |        2 |         1 |     128
     4 |        2 |         1 |     127
     4 |        2 |         1 |     126
     4 |        2 |         1 |     125
     4 |        2 |         1 |     124
     4 |        2 |         1 |     123
     4 |        2 |         1 |     122
     4 |        2 |         1 |     121
     4 |        2 |         1 |     120
     4 |        2 |         1 |     119
     4 |        2 |         1 |     118
     4 |        2 |         1 |     117
     4 |        2 |         1 |     116
     4 |        2 |         1 |     115
     4 |        2 |         1 |     114
     4 |        2 |         1 |     113
     4 |        2 |         1 |     112
     4 |        2 |         1 |     111
     4 |        2 |         1 |     110
     4 |        2 |         1 |     109
     4 |        2 |         1 |     108
     4 |        2 |         1 |     107
     4 |        2 |         1 |     106
     4 |        2 |         1 |     105
     4 |        2 |         1 |     104
     4 |        2 |         1 |     103
     4 |        2 |         1 |     102
     4 |        2 |         1 |     101
     4 |        2 |         1 |     100
     4 |        2 |         1 |      99
     4 |        2 |         1 |      98
     4 |        2 |         1 |      97
     4 |        2 |         1 |      96
     4 |        2 |         1 |      95
     4 |        2 |         1 |      94
     4 |        2 |         1 |      93
     4 |        2 |         1 |      92
     4 |        2 |         1 |      91
     4 |        2 |         1 |      90
     4 |        2 |         1 |      89
     4 |        2 |         1 |      88
     4 |        2 |         1 |      87
     4 |        2 |         1 |      86
     4 |        2 |         1 |      85
     4 |        2 |         1 |      84
     4 |        2 |         1 |      83
     4 |        2 |         1 |      82
     4 |        2 |         1 |      81
     4 |        2 |         1 |      80
     4 |        2 |         1 |      79
     4 |        2 |         1 |      78
     4 |        2 |         1 |      77
     4 |        2 |         1 |      76
     4 |        2 |         1 |      75
     4 |        2 |         1 |      74
     4 |        2 |         1 |      73
     4 |        2 |         1 |      72
     4 |        2 |         1 |      71
     4 |        2 |         1 |      70
     4 |        2 |         1 |      69
     4 |        2 |         1 |      68
     4 |        2 |         1 |      67
     4 |        2 |         1 |      66
     4 |        2 |         1 |      65
     4 |        2 |         1 |      64
     4 |        2 |         1 |      63
     4 |        2 |         1 |      62
     4 |        2 |         1 |      61
     4 |        2 |         1 |      60
     4 |        2 |         1 |      59
     4 |        2 |         1 |      58
     4 |        2 |         1 |      57
     4 |        2 |         1 |      56
     4 |        2 |         1 |      55
     4 |        2 |         1 |      54
     4 |        2 |         1 |      53
     4 |        2 |         1 |      52
     4 |        2 |         1 |      51
     4 |        2 |         1 |      50
     4 |        2 |         1 |      49
     4 |        2 |         1 |      48
     4 |        2 |         1 |      47
     4 |        2 |         1 |      46
     4 |        2 |         1 |      45
     4 |        2 |         1 |      44
     4 |        2 |         1 |      43
     4 |        2 |         1 |      42
     4 |        2 |         1 |      41
     4 |        2 |         1 |      40
     4 |        2 |         1 |      39
     4 |        2 |         1 |      38
     4 |        2 |         1 |      37
     4 |        2 |         1 |      36
     4 |        2 |         1 |      35
     4 |        2 |         1 |      34
     4 |        2 |         1 |      33
     4 |        2 |         1 |      32
     4 |        2 |         1 |      31
     4 |        2 |         1 |      30
     4 |        2 |         1 |      29
     4 |        2 |         1 |      28
     4 |        2 |         1 |      27
     4 |        2 |         1 |      26
     4 |        2 |         1 |      25
     4 |        2 |         1 |      24
     4 |        2 |         1 |      23
     4 |        2 |         1 |      22
     4 |        2 |         1 |      21
     4 |        2 |         1 |      20
     4 |        2 |         1 |      19
     4 |        2 |         1 |      18
     4 |        2 |         1 |      17
     4 |        2 |         1 |      16
     4 |        2 |         1 |      15
     4 |        2 |         1 |      14
     4 |        2 |         1 |      13
     4 |        2 |         1 |      12
     4 |        2 |         1 |      11
     4 |        2 |         1 |      10
     4 |        2 |         1 |       9
     4 |        2 |         1 |       8
     4 |        2 |         1 |       7
     4 |        2 |         1 |       6
     4 |        2 |         1 |       5
     4 |        2 |         1 |       4
     4 |        2 |         1 |       3
     4 |        2 |         1 |       2
     4 |        2 |         1 |       1
     4 |        1 |         2 |       1
     4 |        1 |         1 |     150
     4 |        1 |         1 |     149
     4 |        1 |         1 |     148
     4 |        1 |         1 |     147
     4 |        1 |         1 |     146
     4 |        1 |         1 |     145
     4 |        1 |         1 |     144
     4 |        1 |         1 |     143
     4 |        1 |         1 |     142
     4 |        1 |         1 |     141
     4 |        1 |         1 |     140
     4 |        1 |         1 |     139
     4 |        1 |         1 |     138
     4 |        1 |         1 |     137
     4 |        1 |         1 |     136
     4 |        1 |         1 |     135
     4 |        1 |         1 |     134
     4 |        1 |         1 |     133
     4 |        1 |         1 |     132
     4 |        1 |         1 |     131
     4 |        1 |         1 |     130
     4 |        1 |         1 |     129
     4 |        1 |         1 |     128
     4 |        1 |         1 |     127
     4 |        1 |         1 |     126
     4 |        1 |         1 |     125
     4 |        1 |         1 |     124
     4 |        1 |         1 |     123
     4 |        1 |         1 |     122
     4 |        1 |         1 |     121
     4 |        1 |         1 |     120
     4 |        1 |         1 |     119
     4 |        1 |         1 |     118
     4 |        1 |         1 |     117
     4 |        1 |         1 |     116
     4 |        1 |         1 |     115
     4 |        1 |         1 |     114
     4 |        1 |         1 |     113
     4 |        1 |         1 |     112
     4 |        1 |         1 |     111
     4 |        1 |         1 |     110
     4 |        1 |         1 |     109
     4 |        1 |         1 |     108
     4 |        1 |         1 |     107
     4 |        1 |         1 |     106
     4 |        1 |         1 |     105
     4 |        1 |         1 |     104
     4 |        1 |         1 |     103
     4 |        1 |         1 |     102
     4 |        1 |         1 |     101
     4 |        1 |         1 |     100
     4 |        1 |         1 |      99
     4 |        1 |         1 |      98
     4 |        1 |         1 |      97
     4 |        1 |         1 |      96
     4 |        1 |         1 |      95
     4 |        1 |         1 |      94
     4 |        1 |         1 |      93
     4 |        1 |         1 |      92
     4 |        1 |         1 |      91
     4 |        1 |         1 |      90
     4 |        1 |         1 |      89
     4 |        1 |         1 |      88
     4 |        1 |         1 |      87
     4 |        1 |         1 |      86
     4 |        1 |         1 |      85
     4 |        1 |         1 |      84
     4 |        1 |         1 |      83
     4 |        1 |         1 |      82
     4 |        1 |         1 |      81
     4 |        1 |         1 |      80
     4 |        1 |         1 |      79
     4 |        1 |         1 |      78
     4 |        1 |         1 |      77
     4 |        1 |         1 |      76
     4 |        1 |         1 |      75
     4 |        1 |         1 |      74
     4 |        1 |         1 |      73
     4 |        1 |         1 |      72
     4 |        1 |         1 |      71
     4 |        1 |         1 |      70
     4 |        1 |         1 |      69
     4 |        1 |         1 |      68
     4 |        1 |         1 |      67
     4 |        1 |         1 |      66
     4 |        1 |         1 |      65
     4 |        1 |         1 |      64
     4 |        1 |         1 |      63
     4 |        1 |         1 |      62
     4 |        1 |         1 |      61
     4 |        1 |         1 |      60
     4 |        1 |         1 |      59
     4 |        1 |         1 |      58
     4 |        1 |         1 |      57
     4 |        1 |         1 |      56
     4 |        1 |         1 |      55
     4 |        1 |         1 |      54
     4 |        1 |         1 |      53
     4 |        1 |         1 |      52
     4 |        1 |         1 |      51
     4 |        1 |         1 |      50
     4 |        1 |         1 |      49
     4 |        1 |         1 |      48
     4 |        1 |         1 |      47
     4 |        1 |         1 |      46
     4 |        1 |         1 |      45
     4 |        1 |         1 |      44
     4 |        1 |         1 |      43
     4 |        1 |         1 |      42
     4 |        1 |         1 |      41
     4 |        1 |         1 |      40
     4 |        1 |         1 |      39
     4 |        1 |         1 |      38
     4 |        1 |         1 |      37
     4 |        1 |         1 |      36
     4 |        1 |         1 |      35
     4 |        1 |         1 |      34
     4 |        1 |         1 |      33
     4 |        1 |         1 |      32
     4 |        1 |         1 |      31
     4 |        1 |         1 |      30
     4 |        1 |         1 |      29
     4 |        1 |         1 |      28
     4 |        1 |         1 |      27
     4 |        1 |         1 |      26
     4 |        1 |         1 |      25
     4 |        1 |         1 |      24
     4 |        1 |         1 |      23
     4 |        1 |         1 |      22
     4 |        1 |         1 |      21
     4 |        1 |         1 |      20
     4 |        1 |         1 |      19
     4 |        1 |         1 |      18
     4 |        1 |         1 |      17
     4 |        1 |         1 |      16
     4 |        1 |         1 |      15
     4 |        1 |         1 |      14
     4 |        1 |         1 |      13
     4 |        1 |         1 |      12
     4 |        1 |         1 |      11
     4 |        1 |         1 |      10
     4 |        1 |         1 |       9
     4 |        1 |         1 |       8
     4 |        1 |         1 |       7
     4 |        1 |         1 |       6
     4 |        1 |         1 |       5
     4 |        1 |         1 |       4
     4 |        1 |         1 |       3
     4 |        1 |         1 |       2
     4 |        1 |         1 |       1
(453 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..254.95 rows=990 width=20) (actual rows=453 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=83
   ->  Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..232.38 rows=1267 width=12) (actual rows=1812 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) < ROW(2, 2)) AND (orderline = ANY ('{-5,1,7,9,10,11}'::integer[])))
         Buffers: shared hit=83
(6 rows)

deallocate test_rowcompare;
-- Test <= RowCompare (backwards scan)
prepare test_rowcompare as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) <= (1, 2)
group by district, warehouse, orderid
order by district desc, warehouse desc, orderid desc;
execute test_rowcompare;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
    10 |        3 |         1 |       2
    10 |        3 |         1 |       1
    10 |        2 |         1 |       2
    10 |        2 |         1 |       1
    10 |        1 |         1 |       2
    10 |        1 |         1 |       1
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..298.88 rows=1756 width=20) (actual rows=6 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=9
   ->  Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..249.65 rows=3167 width=12) (actual rows=60 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) <= ROW(1, 2)))
         Buffers: shared hit=9
(6 rows)

deallocate test_rowcompare;
-- Test <= RowCompare (backwards scan), but with NULL RowCompare
prepare test_rowcompare_null as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) <= (1, NULL)
group by district, warehouse, orderid
order by district desc, warehouse desc, orderid desc;
execute test_rowcompare_null;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare_null;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..298.88 rows=1756 width=20) (actual rows=0 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=55
   ->  Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..249.65 rows=3167 width=12) (actual rows=0 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) <= ROW(1, NULL::integer)))
         Buffers: shared hit=55
(6 rows)

deallocate test_rowcompare_null;
-- Test <= RowCompare (backwards scan) + non-required SAOPs
prepare test_rowcompare as
select count(*), district, warehouse, orderid
from redescend_test
where district in (1, 2, 3) and (warehouse, orderid) <= (1, 2) and orderline in (-5,1,7,9,10,11)
group by district, warehouse, orderid
order by district desc, warehouse desc, orderid desc;
execute test_rowcompare;
 count | district | warehouse | orderid 
-------+----------+-----------+---------
     4 |        3 |         1 |       2
     4 |        3 |         1 |       1
     4 |        2 |         1 |       2
     4 |        2 |         1 |       1
     4 |        1 |         1 |       2
     4 |        1 |         1 |       1
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute test_rowcompare;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..254.95 rows=990 width=20) (actual rows=6 loops=1)
   Group Key: district, warehouse, orderid
   Buffers: shared hit=9
   ->  Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..232.38 rows=1267 width=12) (actual rows=24 loops=1)
         Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) <= ROW(1, 2)) AND (orderline = ANY ('{-5,1,7,9,10,11}'::integer[])))
         Buffers: shared hit=9
(6 rows)

deallocate test_rowcompare;
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Repeat last "backwards scan" test, but now use a forward/bitmap scan, to
-- exercise same code paths in the never-buggy scan direction (forwards):
select * from redescend_test
where district in (1, 2, 3) and warehouse < 2 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse < 2 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Disabled: true
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse < 2) AND (orderid < 2) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=58
(4 rows)

-- Now test cursors that change the direction of the scan repeatedly, with
-- default scroll behavior:
set work_mem = 64;
set enable_sort = off;
-- forces index scan to get cursor to truly change directions in nbtree code
begin;
declare default_scroll_cursor cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
order by district, warehouse, orderid, orderline;
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
fetch forward 100 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         1
        1 |         3 |       1 |         2
        1 |         3 |       1 |         3
        1 |         3 |       1 |         4
        1 |         3 |       1 |         5
        1 |         3 |       1 |         6
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       1 |        10
        1 |         3 |       2 |         1
        1 |         3 |       2 |         2
        1 |         3 |       2 |         3
        1 |         3 |       2 |         4
        1 |         3 |       2 |         5
        1 |         3 |       2 |         6
        1 |         3 |       2 |         7
        1 |         3 |       2 |         8
        1 |         3 |       2 |         9
        1 |         3 |       2 |        10
        1 |         3 |       3 |         1
        1 |         3 |       3 |         2
        1 |         3 |       3 |         3
        1 |         3 |       3 |         4
        1 |         3 |       3 |         5
        1 |         3 |       3 |         6
        1 |         3 |       3 |         7
        1 |         3 |       3 |         8
        1 |         3 |       3 |         9
        1 |         3 |       3 |        10
        1 |         3 |       4 |         1
        1 |         3 |       4 |         2
        1 |         3 |       4 |         3
        1 |         3 |       4 |         4
        1 |         3 |       4 |         5
        1 |         3 |       4 |         6
        1 |         3 |       4 |         7
        1 |         3 |       4 |         8
        1 |         3 |       4 |         9
        1 |         3 |       4 |        10
        1 |         3 |       5 |         1
        1 |         3 |       5 |         2
        1 |         3 |       5 |         3
        1 |         3 |       5 |         4
        1 |         3 |       5 |         5
        1 |         3 |       5 |         6
        1 |         3 |       5 |         7
        1 |         3 |       5 |         8
        1 |         3 |       5 |         9
        1 |         3 |       5 |        10
        1 |         3 |       6 |         1
        1 |         3 |       6 |         2
        1 |         3 |       6 |         3
        1 |         3 |       6 |         4
        1 |         3 |       6 |         5
        1 |         3 |       6 |         6
        1 |         3 |       6 |         7
        1 |         3 |       6 |         8
        1 |         3 |       6 |         9
        1 |         3 |       6 |        10
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
        1 |         3 |       7 |         6
        1 |         3 |       7 |         7
        1 |         3 |       7 |         8
        1 |         3 |       7 |         9
        1 |         3 |       7 |        10
        1 |         3 |       8 |         1
        1 |         3 |       8 |         2
        1 |         3 |       8 |         3
        1 |         3 |       8 |         4
        1 |         3 |       8 |         5
        1 |         3 |       8 |         6
        1 |         3 |       8 |         7
        1 |         3 |       8 |         8
        1 |         3 |       8 |         9
        1 |         3 |       8 |        10
        1 |         3 |       9 |         1
        1 |         3 |       9 |         2
        1 |         3 |       9 |         3
        1 |         3 |       9 |         4
        1 |         3 |       9 |         5
        1 |         3 |       9 |         6
        1 |         3 |       9 |         7
        1 |         3 |       9 |         8
        1 |         3 |       9 |         9
        1 |         3 |       9 |        10
        1 |         3 |      10 |         1
        1 |         3 |      10 |         2
        1 |         3 |      10 |         3
        1 |         3 |      10 |         4
        1 |         3 |      10 |         5
        1 |         3 |      10 |         6
        1 |         3 |      10 |         7
        1 |         3 |      10 |         8
        1 |         3 |      10 |         9
        1 |         3 |      10 |        10
(100 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

fetch backward 50 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      10 |         9
        1 |         3 |      10 |         8
        1 |         3 |      10 |         7
        1 |         3 |      10 |         6
        1 |         3 |      10 |         5
        1 |         3 |      10 |         4
        1 |         3 |      10 |         3
        1 |         3 |      10 |         2
        1 |         3 |      10 |         1
        1 |         3 |       9 |        10
        1 |         3 |       9 |         9
        1 |         3 |       9 |         8
        1 |         3 |       9 |         7
        1 |         3 |       9 |         6
        1 |         3 |       9 |         5
        1 |         3 |       9 |         4
        1 |         3 |       9 |         3
        1 |         3 |       9 |         2
        1 |         3 |       9 |         1
        1 |         3 |       8 |        10
        1 |         3 |       8 |         9
        1 |         3 |       8 |         8
        1 |         3 |       8 |         7
        1 |         3 |       8 |         6
        1 |         3 |       8 |         5
        1 |         3 |       8 |         4
        1 |         3 |       8 |         3
        1 |         3 |       8 |         2
        1 |         3 |       8 |         1
        1 |         3 |       7 |        10
        1 |         3 |       7 |         9
        1 |         3 |       7 |         8
        1 |         3 |       7 |         7
        1 |         3 |       7 |         6
        1 |         3 |       7 |         5
        1 |         3 |       7 |         4
        1 |         3 |       7 |         3
        1 |         3 |       7 |         2
        1 |         3 |       7 |         1
        1 |         3 |       6 |        10
        1 |         3 |       6 |         9
        1 |         3 |       6 |         8
        1 |         3 |       6 |         7
        1 |         3 |       6 |         6
        1 |         3 |       6 |         5
        1 |         3 |       6 |         4
        1 |         3 |       6 |         3
        1 |         3 |       6 |         2
        1 |         3 |       6 |         1
        1 |         3 |       5 |        10
(50 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch forward 25 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       6 |         1
        1 |         3 |       6 |         2
        1 |         3 |       6 |         3
        1 |         3 |       6 |         4
        1 |         3 |       6 |         5
        1 |         3 |       6 |         6
        1 |         3 |       6 |         7
        1 |         3 |       6 |         8
        1 |         3 |       6 |         9
        1 |         3 |       6 |        10
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
        1 |         3 |       7 |         6
        1 |         3 |       7 |         7
        1 |         3 |       7 |         8
        1 |         3 |       7 |         9
        1 |         3 |       7 |        10
        1 |         3 |       8 |         1
        1 |         3 |       8 |         2
        1 |         3 |       8 |         3
        1 |         3 |       8 |         4
        1 |         3 |       8 |         5
(25 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

-- This fetch proves that we need to not allow incremental advancement of
-- array keys to wrap/roll over, since if you remove that hardening you'll see
-- Assert(_bt_verify_array_scankeys(scan)) fail:
fetch backward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       8 |         4
        1 |         3 |       8 |         3
        1 |         3 |       8 |         2
        1 |         3 |       8 |         1
        1 |         3 |       7 |        10
        1 |         3 |       7 |         9
        1 |         3 |       7 |         8
        1 |         3 |       7 |         7
        1 |         3 |       7 |         6
        1 |         3 |       7 |         5
        1 |         3 |       7 |         4
        1 |         3 |       7 |         3
        1 |         3 |       7 |         2
        1 |         3 |       7 |         1
        1 |         3 |       6 |        10
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch forward 5 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
(5 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

-- Move to the end of the key space:
move forward 10000 in default_scroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
 98
(1 row)

-- See the last few rows there:
fetch backward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         5 |     150 |        10
        3 |         5 |     150 |         9
        3 |         5 |     150 |         8
        3 |         5 |     150 |         7
        3 |         5 |     150 |         6
        3 |         5 |     150 |         5
        3 |         5 |     150 |         4
        3 |         5 |     150 |         3
        3 |         5 |     150 |         2
        3 |         5 |     150 |         1
        3 |         5 |     149 |        10
        3 |         5 |     149 |         9
        3 |         5 |     149 |         8
        3 |         5 |     149 |         7
        3 |         5 |     149 |         6
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

-- Move back to the start of the key space:
move backward 10000 in default_scroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh  
-----
 100
(1 row)

-- See the first few rows there:
fetch forward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         1
        1 |         3 |       1 |         2
        1 |         3 |       1 |         3
        1 |         3 |       1 |         4
        1 |         3 |       1 |         5
        1 |         3 |       1 |         6
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       1 |        10
        1 |         3 |       2 |         1
        1 |         3 |       2 |         2
        1 |         3 |       2 |         3
        1 |         3 |       2 |         4
        1 |         3 |       2 |         5
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

/* default_scroll_cursor */ commit;
-- Show EXPLAIN ANALYZE for cursor from transaction block (doing better than
-- this seems nontrivial):
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare default_scroll_cursor cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
order by district, warehouse, orderid, orderline;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..485.75 rows=9000 width=16) (actual rows=9000 loops=1)
   Disabled: true
   Index Cond: ((district = ANY ('{1,3}'::integer[])) AND (warehouse = ANY ('{3,4,5,6,7}'::integer[])))
   Buffers: shared hit=151
(4 rows)

-- Same thing again, but with full scroll behavior this time around:
begin;
declare full_scroll_cursor scroll cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
order by district, warehouse, orderid, orderline;
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
fetch forward 100 from full_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         1
        1 |         3 |       1 |         2
        1 |         3 |       1 |         3
        1 |         3 |       1 |         4
        1 |         3 |       1 |         5
        1 |         3 |       1 |         6
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       1 |        10
        1 |         3 |       2 |         1
        1 |         3 |       2 |         2
        1 |         3 |       2 |         3
        1 |         3 |       2 |         4
        1 |         3 |       2 |         5
        1 |         3 |       2 |         6
        1 |         3 |       2 |         7
        1 |         3 |       2 |         8
        1 |         3 |       2 |         9
        1 |         3 |       2 |        10
        1 |         3 |       3 |         1
        1 |         3 |       3 |         2
        1 |         3 |       3 |         3
        1 |         3 |       3 |         4
        1 |         3 |       3 |         5
        1 |         3 |       3 |         6
        1 |         3 |       3 |         7
        1 |         3 |       3 |         8
        1 |         3 |       3 |         9
        1 |         3 |       3 |        10
        1 |         3 |       4 |         1
        1 |         3 |       4 |         2
        1 |         3 |       4 |         3
        1 |         3 |       4 |         4
        1 |         3 |       4 |         5
        1 |         3 |       4 |         6
        1 |         3 |       4 |         7
        1 |         3 |       4 |         8
        1 |         3 |       4 |         9
        1 |         3 |       4 |        10
        1 |         3 |       5 |         1
        1 |         3 |       5 |         2
        1 |         3 |       5 |         3
        1 |         3 |       5 |         4
        1 |         3 |       5 |         5
        1 |         3 |       5 |         6
        1 |         3 |       5 |         7
        1 |         3 |       5 |         8
        1 |         3 |       5 |         9
        1 |         3 |       5 |        10
        1 |         3 |       6 |         1
        1 |         3 |       6 |         2
        1 |         3 |       6 |         3
        1 |         3 |       6 |         4
        1 |         3 |       6 |         5
        1 |         3 |       6 |         6
        1 |         3 |       6 |         7
        1 |         3 |       6 |         8
        1 |         3 |       6 |         9
        1 |         3 |       6 |        10
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
        1 |         3 |       7 |         6
        1 |         3 |       7 |         7
        1 |         3 |       7 |         8
        1 |         3 |       7 |         9
        1 |         3 |       7 |        10
        1 |         3 |       8 |         1
        1 |         3 |       8 |         2
        1 |         3 |       8 |         3
        1 |         3 |       8 |         4
        1 |         3 |       8 |         5
        1 |         3 |       8 |         6
        1 |         3 |       8 |         7
        1 |         3 |       8 |         8
        1 |         3 |       8 |         9
        1 |         3 |       8 |        10
        1 |         3 |       9 |         1
        1 |         3 |       9 |         2
        1 |         3 |       9 |         3
        1 |         3 |       9 |         4
        1 |         3 |       9 |         5
        1 |         3 |       9 |         6
        1 |         3 |       9 |         7
        1 |         3 |       9 |         8
        1 |         3 |       9 |         9
        1 |         3 |       9 |        10
        1 |         3 |      10 |         1
        1 |         3 |      10 |         2
        1 |         3 |      10 |         3
        1 |         3 |      10 |         4
        1 |         3 |      10 |         5
        1 |         3 |      10 |         6
        1 |         3 |      10 |         7
        1 |         3 |      10 |         8
        1 |         3 |      10 |         9
        1 |         3 |      10 |        10
(100 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

fetch backward 50 from full_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      10 |         9
        1 |         3 |      10 |         8
        1 |         3 |      10 |         7
        1 |         3 |      10 |         6
        1 |         3 |      10 |         5
        1 |         3 |      10 |         4
        1 |         3 |      10 |         3
        1 |         3 |      10 |         2
        1 |         3 |      10 |         1
        1 |         3 |       9 |        10
        1 |         3 |       9 |         9
        1 |         3 |       9 |         8
        1 |         3 |       9 |         7
        1 |         3 |       9 |         6
        1 |         3 |       9 |         5
        1 |         3 |       9 |         4
        1 |         3 |       9 |         3
        1 |         3 |       9 |         2
        1 |         3 |       9 |         1
        1 |         3 |       8 |        10
        1 |         3 |       8 |         9
        1 |         3 |       8 |         8
        1 |         3 |       8 |         7
        1 |         3 |       8 |         6
        1 |         3 |       8 |         5
        1 |         3 |       8 |         4
        1 |         3 |       8 |         3
        1 |         3 |       8 |         2
        1 |         3 |       8 |         1
        1 |         3 |       7 |        10
        1 |         3 |       7 |         9
        1 |         3 |       7 |         8
        1 |         3 |       7 |         7
        1 |         3 |       7 |         6
        1 |         3 |       7 |         5
        1 |         3 |       7 |         4
        1 |         3 |       7 |         3
        1 |         3 |       7 |         2
        1 |         3 |       7 |         1
        1 |         3 |       6 |        10
        1 |         3 |       6 |         9
        1 |         3 |       6 |         8
        1 |         3 |       6 |         7
        1 |         3 |       6 |         6
        1 |         3 |       6 |         5
        1 |         3 |       6 |         4
        1 |         3 |       6 |         3
        1 |         3 |       6 |         2
        1 |         3 |       6 |         1
        1 |         3 |       5 |        10
(50 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch forward 25 from full_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       6 |         1
        1 |         3 |       6 |         2
        1 |         3 |       6 |         3
        1 |         3 |       6 |         4
        1 |         3 |       6 |         5
        1 |         3 |       6 |         6
        1 |         3 |       6 |         7
        1 |         3 |       6 |         8
        1 |         3 |       6 |         9
        1 |         3 |       6 |        10
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
        1 |         3 |       7 |         6
        1 |         3 |       7 |         7
        1 |         3 |       7 |         8
        1 |         3 |       7 |         9
        1 |         3 |       7 |        10
        1 |         3 |       8 |         1
        1 |         3 |       8 |         2
        1 |         3 |       8 |         3
        1 |         3 |       8 |         4
        1 |         3 |       8 |         5
(25 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch backward 15 from full_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       8 |         4
        1 |         3 |       8 |         3
        1 |         3 |       8 |         2
        1 |         3 |       8 |         1
        1 |         3 |       7 |        10
        1 |         3 |       7 |         9
        1 |         3 |       7 |         8
        1 |         3 |       7 |         7
        1 |         3 |       7 |         6
        1 |         3 |       7 |         5
        1 |         3 |       7 |         4
        1 |         3 |       7 |         3
        1 |         3 |       7 |         2
        1 |         3 |       7 |         1
        1 |         3 |       6 |        10
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch forward 5 from full_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
(5 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

-- Move to the end of the key space:
move forward 10000 in full_scroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
 98
(1 row)

-- See the last few rows there:
fetch backward 15 from full_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         5 |     150 |        10
        3 |         5 |     150 |         9
        3 |         5 |     150 |         8
        3 |         5 |     150 |         7
        3 |         5 |     150 |         6
        3 |         5 |     150 |         5
        3 |         5 |     150 |         4
        3 |         5 |     150 |         3
        3 |         5 |     150 |         2
        3 |         5 |     150 |         1
        3 |         5 |     149 |        10
        3 |         5 |     149 |         9
        3 |         5 |     149 |         8
        3 |         5 |     149 |         7
        3 |         5 |     149 |         6
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

-- Move back to the start of the key space:
move backward 10000 in full_scroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh  
-----
 100
(1 row)

-- See the first few rows there:
fetch forward 15 from full_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         1
        1 |         3 |       1 |         2
        1 |         3 |       1 |         3
        1 |         3 |       1 |         4
        1 |         3 |       1 |         5
        1 |         3 |       1 |         6
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       1 |        10
        1 |         3 |       2 |         1
        1 |         3 |       2 |         2
        1 |         3 |       2 |         3
        1 |         3 |       2 |         4
        1 |         3 |       2 |         5
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

/* full_scroll_cursor */ commit;
-- Show EXPLAIN ANALYZE for cursor from transaction block:
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare full_scroll_cursor scroll cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
order by district, warehouse, orderid, orderline;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..485.75 rows=9000 width=16) (actual rows=9000 loops=1)
   Disabled: true
   Index Cond: ((district = ANY ('{1,3}'::integer[])) AND (warehouse = ANY ('{3,4,5,6,7}'::integer[])))
   Buffers: shared hit=151
(4 rows)

begin;
declare noscroll_cursor no scroll cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
order by district, warehouse, orderid, orderline;
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
fetch forward 100 from noscroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         1
        1 |         3 |       1 |         2
        1 |         3 |       1 |         3
        1 |         3 |       1 |         4
        1 |         3 |       1 |         5
        1 |         3 |       1 |         6
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       1 |        10
        1 |         3 |       2 |         1
        1 |         3 |       2 |         2
        1 |         3 |       2 |         3
        1 |         3 |       2 |         4
        1 |         3 |       2 |         5
        1 |         3 |       2 |         6
        1 |         3 |       2 |         7
        1 |         3 |       2 |         8
        1 |         3 |       2 |         9
        1 |         3 |       2 |        10
        1 |         3 |       3 |         1
        1 |         3 |       3 |         2
        1 |         3 |       3 |         3
        1 |         3 |       3 |         4
        1 |         3 |       3 |         5
        1 |         3 |       3 |         6
        1 |         3 |       3 |         7
        1 |         3 |       3 |         8
        1 |         3 |       3 |         9
        1 |         3 |       3 |        10
        1 |         3 |       4 |         1
        1 |         3 |       4 |         2
        1 |         3 |       4 |         3
        1 |         3 |       4 |         4
        1 |         3 |       4 |         5
        1 |         3 |       4 |         6
        1 |         3 |       4 |         7
        1 |         3 |       4 |         8
        1 |         3 |       4 |         9
        1 |         3 |       4 |        10
        1 |         3 |       5 |         1
        1 |         3 |       5 |         2
        1 |         3 |       5 |         3
        1 |         3 |       5 |         4
        1 |         3 |       5 |         5
        1 |         3 |       5 |         6
        1 |         3 |       5 |         7
        1 |         3 |       5 |         8
        1 |         3 |       5 |         9
        1 |         3 |       5 |        10
        1 |         3 |       6 |         1
        1 |         3 |       6 |         2
        1 |         3 |       6 |         3
        1 |         3 |       6 |         4
        1 |         3 |       6 |         5
        1 |         3 |       6 |         6
        1 |         3 |       6 |         7
        1 |         3 |       6 |         8
        1 |         3 |       6 |         9
        1 |         3 |       6 |        10
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
        1 |         3 |       7 |         6
        1 |         3 |       7 |         7
        1 |         3 |       7 |         8
        1 |         3 |       7 |         9
        1 |         3 |       7 |        10
        1 |         3 |       8 |         1
        1 |         3 |       8 |         2
        1 |         3 |       8 |         3
        1 |         3 |       8 |         4
        1 |         3 |       8 |         5
        1 |         3 |       8 |         6
        1 |         3 |       8 |         7
        1 |         3 |       8 |         8
        1 |         3 |       8 |         9
        1 |         3 |       8 |        10
        1 |         3 |       9 |         1
        1 |         3 |       9 |         2
        1 |         3 |       9 |         3
        1 |         3 |       9 |         4
        1 |         3 |       9 |         5
        1 |         3 |       9 |         6
        1 |         3 |       9 |         7
        1 |         3 |       9 |         8
        1 |         3 |       9 |         9
        1 |         3 |       9 |        10
        1 |         3 |      10 |         1
        1 |         3 |      10 |         2
        1 |         3 |      10 |         3
        1 |         3 |      10 |         4
        1 |         3 |      10 |         5
        1 |         3 |      10 |         6
        1 |         3 |      10 |         7
        1 |         3 |      10 |         8
        1 |         3 |      10 |         9
        1 |         3 |      10 |        10
(100 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

fetch forward 25 from noscroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      11 |         1
        1 |         3 |      11 |         2
        1 |         3 |      11 |         3
        1 |         3 |      11 |         4
        1 |         3 |      11 |         5
        1 |         3 |      11 |         6
        1 |         3 |      11 |         7
        1 |         3 |      11 |         8
        1 |         3 |      11 |         9
        1 |         3 |      11 |        10
        1 |         3 |      12 |         1
        1 |         3 |      12 |         2
        1 |         3 |      12 |         3
        1 |         3 |      12 |         4
        1 |         3 |      12 |         5
        1 |         3 |      12 |         6
        1 |         3 |      12 |         7
        1 |         3 |      12 |         8
        1 |         3 |      12 |         9
        1 |         3 |      12 |        10
        1 |         3 |      13 |         1
        1 |         3 |      13 |         2
        1 |         3 |      13 |         3
        1 |         3 |      13 |         4
        1 |         3 |      13 |         5
(25 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

fetch forward 5 from noscroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      13 |         6
        1 |         3 |      13 |         7
        1 |         3 |      13 |         8
        1 |         3 |      13 |         9
        1 |         3 |      13 |        10
(5 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

-- Move to the end of the key space:
move forward 10000 in noscroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
 98
(1 row)

-- See the last few rows there:
fetch backward 15 from noscroll_cursor; -- fails this time around
ERROR:  cursor can only scan forward
HINT:  Declare it with SCROLL option to enable backward scan.
/* noscroll_cursor */ abort;
-- Show EXPLAIN ANALYZE for cursor from transaction block:
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare noscroll_cursor no scroll cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
order by district, warehouse, orderid, orderline;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..485.75 rows=9000 width=16) (actual rows=9000 loops=1)
   Disabled: true
   Index Cond: ((district = ANY ('{1,3}'::integer[])) AND (warehouse = ANY ('{3,4,5,6,7}'::integer[])))
   Buffers: shared hit=151
(4 rows)

-- Index scan
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- (November 23) Variant of "forces index scan to get cursor to truly change
-- directions in nbtree code", but with inequalities
--
-- The intention here is to add some inequalities that don't actually change
-- the answers we get compared to the original, and stress the implementation
-- by tickling the "required in opposite direction only" code path within
-- _bt_advance_array_keys.
--
-- This was the first test case added on thanksgiving -- this one was
-- exploratory, motivated by recent issues with inequalities.
begin;
declare default_scroll_cursor cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
and orderid > 0 and orderid <= 150
order by district, warehouse, orderid, orderline;
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
fetch forward 100 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         1
        1 |         3 |       1 |         2
        1 |         3 |       1 |         3
        1 |         3 |       1 |         4
        1 |         3 |       1 |         5
        1 |         3 |       1 |         6
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       1 |        10
        1 |         3 |       2 |         1
        1 |         3 |       2 |         2
        1 |         3 |       2 |         3
        1 |         3 |       2 |         4
        1 |         3 |       2 |         5
        1 |         3 |       2 |         6
        1 |         3 |       2 |         7
        1 |         3 |       2 |         8
        1 |         3 |       2 |         9
        1 |         3 |       2 |        10
        1 |         3 |       3 |         1
        1 |         3 |       3 |         2
        1 |         3 |       3 |         3
        1 |         3 |       3 |         4
        1 |         3 |       3 |         5
        1 |         3 |       3 |         6
        1 |         3 |       3 |         7
        1 |         3 |       3 |         8
        1 |         3 |       3 |         9
        1 |         3 |       3 |        10
        1 |         3 |       4 |         1
        1 |         3 |       4 |         2
        1 |         3 |       4 |         3
        1 |         3 |       4 |         4
        1 |         3 |       4 |         5
        1 |         3 |       4 |         6
        1 |         3 |       4 |         7
        1 |         3 |       4 |         8
        1 |         3 |       4 |         9
        1 |         3 |       4 |        10
        1 |         3 |       5 |         1
        1 |         3 |       5 |         2
        1 |         3 |       5 |         3
        1 |         3 |       5 |         4
        1 |         3 |       5 |         5
        1 |         3 |       5 |         6
        1 |         3 |       5 |         7
        1 |         3 |       5 |         8
        1 |         3 |       5 |         9
        1 |         3 |       5 |        10
        1 |         3 |       6 |         1
        1 |         3 |       6 |         2
        1 |         3 |       6 |         3
        1 |         3 |       6 |         4
        1 |         3 |       6 |         5
        1 |         3 |       6 |         6
        1 |         3 |       6 |         7
        1 |         3 |       6 |         8
        1 |         3 |       6 |         9
        1 |         3 |       6 |        10
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
        1 |         3 |       7 |         6
        1 |         3 |       7 |         7
        1 |         3 |       7 |         8
        1 |         3 |       7 |         9
        1 |         3 |       7 |        10
        1 |         3 |       8 |         1
        1 |         3 |       8 |         2
        1 |         3 |       8 |         3
        1 |         3 |       8 |         4
        1 |         3 |       8 |         5
        1 |         3 |       8 |         6
        1 |         3 |       8 |         7
        1 |         3 |       8 |         8
        1 |         3 |       8 |         9
        1 |         3 |       8 |        10
        1 |         3 |       9 |         1
        1 |         3 |       9 |         2
        1 |         3 |       9 |         3
        1 |         3 |       9 |         4
        1 |         3 |       9 |         5
        1 |         3 |       9 |         6
        1 |         3 |       9 |         7
        1 |         3 |       9 |         8
        1 |         3 |       9 |         9
        1 |         3 |       9 |        10
        1 |         3 |      10 |         1
        1 |         3 |      10 |         2
        1 |         3 |      10 |         3
        1 |         3 |      10 |         4
        1 |         3 |      10 |         5
        1 |         3 |      10 |         6
        1 |         3 |      10 |         7
        1 |         3 |      10 |         8
        1 |         3 |      10 |         9
        1 |         3 |      10 |        10
(100 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

fetch backward 50 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      10 |         9
        1 |         3 |      10 |         8
        1 |         3 |      10 |         7
        1 |         3 |      10 |         6
        1 |         3 |      10 |         5
        1 |         3 |      10 |         4
        1 |         3 |      10 |         3
        1 |         3 |      10 |         2
        1 |         3 |      10 |         1
        1 |         3 |       9 |        10
        1 |         3 |       9 |         9
        1 |         3 |       9 |         8
        1 |         3 |       9 |         7
        1 |         3 |       9 |         6
        1 |         3 |       9 |         5
        1 |         3 |       9 |         4
        1 |         3 |       9 |         3
        1 |         3 |       9 |         2
        1 |         3 |       9 |         1
        1 |         3 |       8 |        10
        1 |         3 |       8 |         9
        1 |         3 |       8 |         8
        1 |         3 |       8 |         7
        1 |         3 |       8 |         6
        1 |         3 |       8 |         5
        1 |         3 |       8 |         4
        1 |         3 |       8 |         3
        1 |         3 |       8 |         2
        1 |         3 |       8 |         1
        1 |         3 |       7 |        10
        1 |         3 |       7 |         9
        1 |         3 |       7 |         8
        1 |         3 |       7 |         7
        1 |         3 |       7 |         6
        1 |         3 |       7 |         5
        1 |         3 |       7 |         4
        1 |         3 |       7 |         3
        1 |         3 |       7 |         2
        1 |         3 |       7 |         1
        1 |         3 |       6 |        10
        1 |         3 |       6 |         9
        1 |         3 |       6 |         8
        1 |         3 |       6 |         7
        1 |         3 |       6 |         6
        1 |         3 |       6 |         5
        1 |         3 |       6 |         4
        1 |         3 |       6 |         3
        1 |         3 |       6 |         2
        1 |         3 |       6 |         1
        1 |         3 |       5 |        10
(50 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch forward 25 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       6 |         1
        1 |         3 |       6 |         2
        1 |         3 |       6 |         3
        1 |         3 |       6 |         4
        1 |         3 |       6 |         5
        1 |         3 |       6 |         6
        1 |         3 |       6 |         7
        1 |         3 |       6 |         8
        1 |         3 |       6 |         9
        1 |         3 |       6 |        10
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
        1 |         3 |       7 |         6
        1 |         3 |       7 |         7
        1 |         3 |       7 |         8
        1 |         3 |       7 |         9
        1 |         3 |       7 |        10
        1 |         3 |       8 |         1
        1 |         3 |       8 |         2
        1 |         3 |       8 |         3
        1 |         3 |       8 |         4
        1 |         3 |       8 |         5
(25 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch backward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       8 |         4
        1 |         3 |       8 |         3
        1 |         3 |       8 |         2
        1 |         3 |       8 |         1
        1 |         3 |       7 |        10
        1 |         3 |       7 |         9
        1 |         3 |       7 |         8
        1 |         3 |       7 |         7
        1 |         3 |       7 |         6
        1 |         3 |       7 |         5
        1 |         3 |       7 |         4
        1 |         3 |       7 |         3
        1 |         3 |       7 |         2
        1 |         3 |       7 |         1
        1 |         3 |       6 |        10
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch forward 5 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       7 |         1
        1 |         3 |       7 |         2
        1 |         3 |       7 |         3
        1 |         3 |       7 |         4
        1 |         3 |       7 |         5
(5 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

-- Move to the end of the key space:
move forward 10000 in default_scroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
 98
(1 row)

-- See the last few rows there:
fetch backward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         5 |     150 |        10
        3 |         5 |     150 |         9
        3 |         5 |     150 |         8
        3 |         5 |     150 |         7
        3 |         5 |     150 |         6
        3 |         5 |     150 |         5
        3 |         5 |     150 |         4
        3 |         5 |     150 |         3
        3 |         5 |     150 |         2
        3 |         5 |     150 |         1
        3 |         5 |     149 |        10
        3 |         5 |     149 |         9
        3 |         5 |     149 |         8
        3 |         5 |     149 |         7
        3 |         5 |     149 |         6
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

-- Move back to the start of the key space:
move backward 10000 in default_scroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh  
-----
 100
(1 row)

-- See the first few rows there:
fetch forward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         1
        1 |         3 |       1 |         2
        1 |         3 |       1 |         3
        1 |         3 |       1 |         4
        1 |         3 |       1 |         5
        1 |         3 |       1 |         6
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       1 |        10
        1 |         3 |       2 |         1
        1 |         3 |       2 |         2
        1 |         3 |       2 |         3
        1 |         3 |       2 |         4
        1 |         3 |       2 |         5
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

/* default_scroll_cursor */ commit;
-- (November 23) Show EXPLAIN ANALYZE for cursor from transaction block (doing
-- better than this seems nontrivial):
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 151 buffer hits (matches original)
declare default_scroll_cursor cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
and orderid > 0 and orderid <= 150
order by district, warehouse, orderid, orderline;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..530.74 rows=8999 width=16) (actual rows=9000 loops=1)
   Index Cond: ((district = ANY ('{1,3}'::integer[])) AND (warehouse = ANY ('{3,4,5,6,7}'::integer[])) AND (orderid > 0) AND (orderid <= 150))
   Buffers: shared hit=151
(3 rows)

-- (November 23) Variant of "forces index scan to get cursor to truly change
-- directions in nbtree code", but with inequalities -- this time they have
-- much tighter bounds than prior variant.
--
-- The intention here is to NOT match the original, but rather to do far
-- fewer leaf page accesses because we can do several selective primitive
-- scans with these tighter inequality bounds.
--
-- This was the second test case added on thanksgiving -- this one had an
-- assertion failure related bug (confusion over start/end of primitive scan),
-- shown below next to the relevant statement.
--
-- Problem was that we didn't account for scan direction when scheduling a
-- primitive index scan.  So now _bt_steppage knows to forget about a schedule
-- primitive scan in the opposite/wrong direction, fixing the bug.
begin;
declare default_scroll_cursor cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
and orderid >= 42 and orderid <= 47
and orderline in (-500,5,7,8,9,500)
order by district, warehouse, orderid, orderline;
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
-- Constants here differ to earlier on:
fetch forward 10 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      42 |         5
        1 |         3 |      42 |         7
        1 |         3 |      42 |         8
        1 |         3 |      42 |         9
        1 |         3 |      43 |         5
        1 |         3 |      43 |         7
        1 |         3 |      43 |         8
        1 |         3 |      43 |         9
        1 |         3 |      44 |         5
        1 |         3 |      44 |         7
(10 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

-- This caused an assertion failure at one point, right at the top of _bt_checkkeys:
-- TRAP: failed Assert("!so->needPrimScan"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 2964, PID: 663861
fetch backward 20 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      44 |         5
        1 |         3 |      43 |         9
        1 |         3 |      43 |         8
        1 |         3 |      43 |         7
        1 |         3 |      43 |         5
        1 |         3 |      42 |         9
        1 |         3 |      42 |         8
        1 |         3 |      42 |         7
        1 |         3 |      42 |         5
(9 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch forward 5 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      42 |         5
        1 |         3 |      42 |         7
        1 |         3 |      42 |         8
        1 |         3 |      42 |         9
        1 |         3 |      43 |         5
(5 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

fetch backward 5 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      42 |         9
        1 |         3 |      42 |         8
        1 |         3 |      42 |         7
        1 |         3 |      42 |         5
(4 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch forward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      42 |         5
        1 |         3 |      42 |         7
        1 |         3 |      42 |         8
        1 |         3 |      42 |         9
        1 |         3 |      43 |         5
        1 |         3 |      43 |         7
        1 |         3 |      43 |         8
        1 |         3 |      43 |         9
        1 |         3 |      44 |         5
        1 |         3 |      44 |         7
        1 |         3 |      44 |         8
        1 |         3 |      44 |         9
        1 |         3 |      45 |         5
        1 |         3 |      45 |         7
        1 |         3 |      45 |         8
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

-- Move to the end of the key space:
move forward 10000 in default_scroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
 17
(1 row)

-- See the last few rows there:
fetch backward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         5 |      47 |         9
        3 |         5 |      47 |         8
        3 |         5 |      47 |         7
        3 |         5 |      47 |         5
        3 |         5 |      46 |         9
        3 |         5 |      46 |         8
        3 |         5 |      46 |         7
        3 |         5 |      46 |         5
        3 |         5 |      45 |         9
        3 |         5 |      45 |         8
        3 |         5 |      45 |         7
        3 |         5 |      45 |         5
        3 |         5 |      44 |         9
        3 |         5 |      44 |         8
        3 |         5 |      44 |         7
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  4
(1 row)

-- Move back to the start of the key space:
move backward 10000 in default_scroll_cursor;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
 16
(1 row)

-- See the first few rows there:
fetch forward 15 from default_scroll_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |      42 |         5
        1 |         3 |      42 |         7
        1 |         3 |      42 |         8
        1 |         3 |      42 |         9
        1 |         3 |      43 |         5
        1 |         3 |      43 |         7
        1 |         3 |      43 |         8
        1 |         3 |      43 |         9
        1 |         3 |      44 |         5
        1 |         3 |      44 |         7
        1 |         3 |      44 |         8
        1 |         3 |      44 |         9
        1 |         3 |      45 |         5
        1 |         3 |      45 |         7
        1 |         3 |      45 |         8
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

/* default_scroll_cursor */ commit;
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare default_scroll_cursor cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
and orderid >= 42 and orderid <= 47
and orderline in (-500,5,7,8,9,500)
order by district, warehouse, orderid, orderline;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..111.36 rows=144 width=16) (actual rows=144 loops=1)
   Index Cond: ((district = ANY ('{1,3}'::integer[])) AND (warehouse = ANY ('{3,4,5,6,7}'::integer[])) AND (orderid >= 42) AND (orderid <= 47) AND (orderline = ANY ('{-500,5,7,8,9,500}'::integer[])))
   Buffers: shared hit=27
(3 rows)

-- (November 24)
--
-- Day after thanksgiving and I notice that yesterday's test case has a lack
-- of test coverage for the case where we change from backwards to forwards
-- and cancel a pending backwards-directed primitive index scan (it only had
-- coverage for cancelling a forwards scan when we go backwards, which is
-- far easier hit, probably due to suffix truncation of
-- the high key).
--
-- Remedy the situation by adding coverage here.
begin;
declare cancel_backwards_prim_scan_changedir cursor for
select * from redescend_test
where district in (1, 3, 800) and warehouse in (1,2)
and orderid in (48, 50)
order by district, warehouse, orderid, orderline;
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
fetch forward 60 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         1 |      48 |         1
        1 |         1 |      48 |         2
        1 |         1 |      48 |         3
        1 |         1 |      48 |         4
        1 |         1 |      48 |         5
        1 |         1 |      48 |         6
        1 |         1 |      48 |         7
        1 |         1 |      48 |         8
        1 |         1 |      48 |         9
        1 |         1 |      48 |        10
        1 |         1 |      50 |         1
        1 |         1 |      50 |         2
        1 |         1 |      50 |         3
        1 |         1 |      50 |         4
        1 |         1 |      50 |         5
        1 |         1 |      50 |         6
        1 |         1 |      50 |         7
        1 |         1 |      50 |         8
        1 |         1 |      50 |         9
        1 |         1 |      50 |        10
        1 |         2 |      48 |         1
        1 |         2 |      48 |         2
        1 |         2 |      48 |         3
        1 |         2 |      48 |         4
        1 |         2 |      48 |         5
        1 |         2 |      48 |         6
        1 |         2 |      48 |         7
        1 |         2 |      48 |         8
        1 |         2 |      48 |         9
        1 |         2 |      48 |        10
        1 |         2 |      50 |         1
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
        3 |         1 |      48 |         5
        3 |         1 |      48 |         6
        3 |         1 |      48 |         7
        3 |         1 |      48 |         8
        3 |         1 |      48 |         9
        3 |         1 |      48 |        10
        3 |         1 |      50 |         1
        3 |         1 |      50 |         2
        3 |         1 |      50 |         3
        3 |         1 |      50 |         4
        3 |         1 |      50 |         5
        3 |         1 |      50 |         6
        3 |         1 |      50 |         7
        3 |         1 |      50 |         8
        3 |         1 |      50 |         9
        3 |         1 |      50 |        10
(60 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
 10
(1 row)

-- This sets up the backwards primitive scan that ends up getting cancelled
-- later:
fetch backward 29 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |      50 |         9
        3 |         1 |      50 |         8
        3 |         1 |      50 |         7
        3 |         1 |      50 |         6
        3 |         1 |      50 |         5
        3 |         1 |      50 |         4
        3 |         1 |      50 |         3
        3 |         1 |      50 |         2
        3 |         1 |      50 |         1
        3 |         1 |      48 |        10
        3 |         1 |      48 |         9
        3 |         1 |      48 |         8
        3 |         1 |      48 |         7
        3 |         1 |      48 |         6
        3 |         1 |      48 |         5
        3 |         1 |      48 |         4
        3 |         1 |      48 |         3
        3 |         1 |      48 |         2
        3 |         1 |      48 |         1
        1 |         2 |      50 |        10
        1 |         2 |      50 |         9
        1 |         2 |      50 |         8
        1 |         2 |      50 |         7
        1 |         2 |      50 |         6
        1 |         2 |      50 |         5
        1 |         2 |      50 |         4
        1 |         2 |      50 |         3
        1 |         2 |      50 |         2
        1 |         2 |      50 |         1
(29 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

-- This is the statement that actually cancels a pending primitive index scan
-- directed backward, since it goes forward at exactly the right/wrong time.
fetch forward 30 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
        3 |         1 |      48 |         5
        3 |         1 |      48 |         6
        3 |         1 |      48 |         7
        3 |         1 |      48 |         8
        3 |         1 |      48 |         9
        3 |         1 |      48 |        10
        3 |         1 |      50 |         1
        3 |         1 |      50 |         2
        3 |         1 |      50 |         3
        3 |         1 |      50 |         4
        3 |         1 |      50 |         5
        3 |         1 |      50 |         6
        3 |         1 |      50 |         7
        3 |         1 |      50 |         8
        3 |         1 |      50 |         9
        3 |         1 |      50 |        10
        3 |         2 |      48 |         1
(30 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  7
(1 row)

-- These are for good luck:
fetch backward 30 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |      50 |        10
        3 |         1 |      50 |         9
        3 |         1 |      50 |         8
        3 |         1 |      50 |         7
        3 |         1 |      50 |         6
        3 |         1 |      50 |         5
        3 |         1 |      50 |         4
        3 |         1 |      50 |         3
        3 |         1 |      50 |         2
        3 |         1 |      50 |         1
        3 |         1 |      48 |        10
        3 |         1 |      48 |         9
        3 |         1 |      48 |         8
        3 |         1 |      48 |         7
        3 |         1 |      48 |         6
        3 |         1 |      48 |         5
        3 |         1 |      48 |         4
        3 |         1 |      48 |         3
        3 |         1 |      48 |         2
        3 |         1 |      48 |         1
        1 |         2 |      50 |        10
        1 |         2 |      50 |         9
        1 |         2 |      50 |         8
        1 |         2 |      50 |         7
        1 |         2 |      50 |         6
        1 |         2 |      50 |         5
        1 |         2 |      50 |         4
        1 |         2 |      50 |         3
        1 |         2 |      50 |         2
        1 |         2 |      50 |         1
(30 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  7
(1 row)

fetch forward  31 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
        3 |         1 |      48 |         5
        3 |         1 |      48 |         6
        3 |         1 |      48 |         7
        3 |         1 |      48 |         8
        3 |         1 |      48 |         9
        3 |         1 |      48 |        10
        3 |         1 |      50 |         1
        3 |         1 |      50 |         2
        3 |         1 |      50 |         3
        3 |         1 |      50 |         4
        3 |         1 |      50 |         5
        3 |         1 |      50 |         6
        3 |         1 |      50 |         7
        3 |         1 |      50 |         8
        3 |         1 |      50 |         9
        3 |         1 |      50 |        10
        3 |         2 |      48 |         1
        3 |         2 |      48 |         2
(31 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  7
(1 row)

fetch backward 32 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         2 |      48 |         1
        3 |         1 |      50 |        10
        3 |         1 |      50 |         9
        3 |         1 |      50 |         8
        3 |         1 |      50 |         7
        3 |         1 |      50 |         6
        3 |         1 |      50 |         5
        3 |         1 |      50 |         4
        3 |         1 |      50 |         3
        3 |         1 |      50 |         2
        3 |         1 |      50 |         1
        3 |         1 |      48 |        10
        3 |         1 |      48 |         9
        3 |         1 |      48 |         8
        3 |         1 |      48 |         7
        3 |         1 |      48 |         6
        3 |         1 |      48 |         5
        3 |         1 |      48 |         4
        3 |         1 |      48 |         3
        3 |         1 |      48 |         2
        3 |         1 |      48 |         1
        1 |         2 |      50 |        10
        1 |         2 |      50 |         9
        1 |         2 |      50 |         8
        1 |         2 |      50 |         7
        1 |         2 |      50 |         6
        1 |         2 |      50 |         5
        1 |         2 |      50 |         4
        1 |         2 |      50 |         3
        1 |         2 |      50 |         2
        1 |         2 |      50 |         1
        1 |         2 |      48 |        10
(32 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  9
(1 row)

fetch forward  33 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         2 |      50 |         1
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
        3 |         1 |      48 |         5
        3 |         1 |      48 |         6
        3 |         1 |      48 |         7
        3 |         1 |      48 |         8
        3 |         1 |      48 |         9
        3 |         1 |      48 |        10
        3 |         1 |      50 |         1
        3 |         1 |      50 |         2
        3 |         1 |      50 |         3
        3 |         1 |      50 |         4
        3 |         1 |      50 |         5
        3 |         1 |      50 |         6
        3 |         1 |      50 |         7
        3 |         1 |      50 |         8
        3 |         1 |      50 |         9
        3 |         1 |      50 |        10
        3 |         2 |      48 |         1
        3 |         2 |      48 |         2
        3 |         2 |      48 |         3
(33 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  7
(1 row)

fetch backward 34 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         2 |      48 |         2
        3 |         2 |      48 |         1
        3 |         1 |      50 |        10
        3 |         1 |      50 |         9
        3 |         1 |      50 |         8
        3 |         1 |      50 |         7
        3 |         1 |      50 |         6
        3 |         1 |      50 |         5
        3 |         1 |      50 |         4
        3 |         1 |      50 |         3
        3 |         1 |      50 |         2
        3 |         1 |      50 |         1
        3 |         1 |      48 |        10
        3 |         1 |      48 |         9
        3 |         1 |      48 |         8
        3 |         1 |      48 |         7
        3 |         1 |      48 |         6
        3 |         1 |      48 |         5
        3 |         1 |      48 |         4
        3 |         1 |      48 |         3
        3 |         1 |      48 |         2
        3 |         1 |      48 |         1
        1 |         2 |      50 |        10
        1 |         2 |      50 |         9
        1 |         2 |      50 |         8
        1 |         2 |      50 |         7
        1 |         2 |      50 |         6
        1 |         2 |      50 |         5
        1 |         2 |      50 |         4
        1 |         2 |      50 |         3
        1 |         2 |      50 |         2
        1 |         2 |      50 |         1
        1 |         2 |      48 |        10
        1 |         2 |      48 |         9
(34 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  9
(1 row)

fetch forward  35 from cancel_backwards_prim_scan_changedir;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         2 |      48 |        10
        1 |         2 |      50 |         1
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
        3 |         1 |      48 |         5
        3 |         1 |      48 |         6
        3 |         1 |      48 |         7
        3 |         1 |      48 |         8
        3 |         1 |      48 |         9
        3 |         1 |      48 |        10
        3 |         1 |      50 |         1
        3 |         1 |      50 |         2
        3 |         1 |      50 |         3
        3 |         1 |      50 |         4
        3 |         1 |      50 |         5
        3 |         1 |      50 |         6
        3 |         1 |      50 |         7
        3 |         1 |      50 |         8
        3 |         1 |      50 |         9
        3 |         1 |      50 |        10
        3 |         2 |      48 |         1
        3 |         2 |      48 |         2
        3 |         2 |      48 |         3
        3 |         2 |      48 |         4
(35 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  7
(1 row)

/* cancel_backwards_prim_scan_changedir */ commit;
-- Show EXPLAIN ANALYZE for cursor from transaction block:
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare cancel_backwards_prim_scan_changedir cursor for
select * from redescend_test
where district in (1, 3, 800) and warehouse in (1,2)
and orderid in (48, 50)
order by district, warehouse, orderid, orderline;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..83.80 rows=80 width=16) (actual rows=80 loops=1)
   Index Cond: ((district = ANY ('{1,3,800}'::integer[])) AND (warehouse = ANY ('{1,2}'::integer[])) AND (orderid = ANY ('{48,50}'::integer[])))
   Buffers: shared hit=18
(3 rows)

-- (November 25)
--
-- Here we don't remember the scan's array keys before processing a page, only
-- after processing a page (which is implicit, it's just the scan's current
-- keys).  So when we move the scan backwards we think that the top-level scan
-- should terminate, when in reality it should jump backwards to the leaf page
-- that we last visited.
--
-- This is closely related to the November 24 test, but can fail independently
-- in some way that I don't have the time or patience to pin down right now.
set client_min_messages=error;
drop table if exists backup_wrong_tbl;
reset client_min_messages;
create unlogged table backup_wrong_tbl (district int4, warehouse int4, orderid int4, orderline int4);
create index backup_wrong_idx on backup_wrong_tbl (district, warehouse, orderid, orderline);
insert into backup_wrong_tbl
select district, warehouse, orderid, orderline
from
  generate_series(1, 3) district,
  generate_series(1, 2) warehouse,
  generate_series(1, 51) orderid,
  generate_series(1, 10) orderline;
-- prewarm
select count(*) from backup_wrong_tbl;
 count 
-------
  3060
(1 row)

vacuum analyze backup_wrong_tbl;
begin;
declare back_up_terminate_toplevel_wrong cursor for
select * from backup_wrong_tbl
where district in (1, 3) and warehouse in (1,2)
and orderid in (48, 50)
order by district, warehouse, orderid, orderline;
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
fetch forward 60 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         1 |      48 |         1
        1 |         1 |      48 |         2
        1 |         1 |      48 |         3
        1 |         1 |      48 |         4
        1 |         1 |      48 |         5
        1 |         1 |      48 |         6
        1 |         1 |      48 |         7
        1 |         1 |      48 |         8
        1 |         1 |      48 |         9
        1 |         1 |      48 |        10
        1 |         1 |      50 |         1
        1 |         1 |      50 |         2
        1 |         1 |      50 |         3
        1 |         1 |      50 |         4
        1 |         1 |      50 |         5
        1 |         1 |      50 |         6
        1 |         1 |      50 |         7
        1 |         1 |      50 |         8
        1 |         1 |      50 |         9
        1 |         1 |      50 |        10
        1 |         2 |      48 |         1
        1 |         2 |      48 |         2
        1 |         2 |      48 |         3
        1 |         2 |      48 |         4
        1 |         2 |      48 |         5
        1 |         2 |      48 |         6
        1 |         2 |      48 |         7
        1 |         2 |      48 |         8
        1 |         2 |      48 |         9
        1 |         2 |      48 |        10
        1 |         2 |      50 |         1
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
        3 |         1 |      48 |         5
        3 |         1 |      48 |         6
        3 |         1 |      48 |         7
        3 |         1 |      48 |         8
        3 |         1 |      48 |         9
        3 |         1 |      48 |        10
        3 |         1 |      50 |         1
        3 |         1 |      50 |         2
        3 |         1 |      50 |         3
        3 |         1 |      50 |         4
        3 |         1 |      50 |         5
        3 |         1 |      50 |         6
        3 |         1 |      50 |         7
        3 |         1 |      50 |         8
        3 |         1 |      50 |         9
        3 |         1 |      50 |        10
(60 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  7
(1 row)

fetch backward 29 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |      50 |         9
        3 |         1 |      50 |         8
        3 |         1 |      50 |         7
        3 |         1 |      50 |         6
        3 |         1 |      50 |         5
        3 |         1 |      50 |         4
        3 |         1 |      50 |         3
        3 |         1 |      50 |         2
        3 |         1 |      50 |         1
        3 |         1 |      48 |        10
        3 |         1 |      48 |         9
        3 |         1 |      48 |         8
        3 |         1 |      48 |         7
        3 |         1 |      48 |         6
        3 |         1 |      48 |         5
        3 |         1 |      48 |         4
        3 |         1 |      48 |         3
        3 |         1 |      48 |         2
        3 |         1 |      48 |         1
        1 |         2 |      50 |        10
        1 |         2 |      50 |         9
        1 |         2 |      50 |         8
        1 |         2 |      50 |         7
        1 |         2 |      50 |         6
        1 |         2 |      50 |         5
        1 |         2 |      50 |         4
        1 |         2 |      50 |         3
        1 |         2 |      50 |         2
        1 |         2 |      50 |         1
(29 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

fetch forward 12 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
(12 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

fetch backward 30 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |      48 |         2
        3 |         1 |      48 |         1
        1 |         2 |      50 |        10
        1 |         2 |      50 |         9
        1 |         2 |      50 |         8
        1 |         2 |      50 |         7
        1 |         2 |      50 |         6
        1 |         2 |      50 |         5
        1 |         2 |      50 |         4
        1 |         2 |      50 |         3
        1 |         2 |      50 |         2
        1 |         2 |      50 |         1
        1 |         2 |      48 |        10
        1 |         2 |      48 |         9
        1 |         2 |      48 |         8
        1 |         2 |      48 |         7
        1 |         2 |      48 |         6
        1 |         2 |      48 |         5
        1 |         2 |      48 |         4
        1 |         2 |      48 |         3
        1 |         2 |      48 |         2
        1 |         2 |      48 |         1
        1 |         1 |      50 |        10
        1 |         1 |      50 |         9
        1 |         1 |      50 |         8
        1 |         1 |      50 |         7
        1 |         1 |      50 |         6
        1 |         1 |      50 |         5
        1 |         1 |      50 |         4
        1 |         1 |      50 |         3
(30 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  5
(1 row)

fetch forward  31 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         1 |      50 |         4
        1 |         1 |      50 |         5
        1 |         1 |      50 |         6
        1 |         1 |      50 |         7
        1 |         1 |      50 |         8
        1 |         1 |      50 |         9
        1 |         1 |      50 |        10
        1 |         2 |      48 |         1
        1 |         2 |      48 |         2
        1 |         2 |      48 |         3
        1 |         2 |      48 |         4
        1 |         2 |      48 |         5
        1 |         2 |      48 |         6
        1 |         2 |      48 |         7
        1 |         2 |      48 |         8
        1 |         2 |      48 |         9
        1 |         2 |      48 |        10
        1 |         2 |      50 |         1
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
(31 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  5
(1 row)

fetch backward 32 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |      48 |         3
        3 |         1 |      48 |         2
        3 |         1 |      48 |         1
        1 |         2 |      50 |        10
        1 |         2 |      50 |         9
        1 |         2 |      50 |         8
        1 |         2 |      50 |         7
        1 |         2 |      50 |         6
        1 |         2 |      50 |         5
        1 |         2 |      50 |         4
        1 |         2 |      50 |         3
        1 |         2 |      50 |         2
        1 |         2 |      50 |         1
        1 |         2 |      48 |        10
        1 |         2 |      48 |         9
        1 |         2 |      48 |         8
        1 |         2 |      48 |         7
        1 |         2 |      48 |         6
        1 |         2 |      48 |         5
        1 |         2 |      48 |         4
        1 |         2 |      48 |         3
        1 |         2 |      48 |         2
        1 |         2 |      48 |         1
        1 |         1 |      50 |        10
        1 |         1 |      50 |         9
        1 |         1 |      50 |         8
        1 |         1 |      50 |         7
        1 |         1 |      50 |         6
        1 |         1 |      50 |         5
        1 |         1 |      50 |         4
        1 |         1 |      50 |         3
        1 |         1 |      50 |         2
(32 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  5
(1 row)

fetch forward  33 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         1 |      50 |         3
        1 |         1 |      50 |         4
        1 |         1 |      50 |         5
        1 |         1 |      50 |         6
        1 |         1 |      50 |         7
        1 |         1 |      50 |         8
        1 |         1 |      50 |         9
        1 |         1 |      50 |        10
        1 |         2 |      48 |         1
        1 |         2 |      48 |         2
        1 |         2 |      48 |         3
        1 |         2 |      48 |         4
        1 |         2 |      48 |         5
        1 |         2 |      48 |         6
        1 |         2 |      48 |         7
        1 |         2 |      48 |         8
        1 |         2 |      48 |         9
        1 |         2 |      48 |        10
        1 |         2 |      50 |         1
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
        3 |         1 |      48 |         5
(33 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  5
(1 row)

fetch backward 34 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |      48 |         4
        3 |         1 |      48 |         3
        3 |         1 |      48 |         2
        3 |         1 |      48 |         1
        1 |         2 |      50 |        10
        1 |         2 |      50 |         9
        1 |         2 |      50 |         8
        1 |         2 |      50 |         7
        1 |         2 |      50 |         6
        1 |         2 |      50 |         5
        1 |         2 |      50 |         4
        1 |         2 |      50 |         3
        1 |         2 |      50 |         2
        1 |         2 |      50 |         1
        1 |         2 |      48 |        10
        1 |         2 |      48 |         9
        1 |         2 |      48 |         8
        1 |         2 |      48 |         7
        1 |         2 |      48 |         6
        1 |         2 |      48 |         5
        1 |         2 |      48 |         4
        1 |         2 |      48 |         3
        1 |         2 |      48 |         2
        1 |         2 |      48 |         1
        1 |         1 |      50 |        10
        1 |         1 |      50 |         9
        1 |         1 |      50 |         8
        1 |         1 |      50 |         7
        1 |         1 |      50 |         6
        1 |         1 |      50 |         5
        1 |         1 |      50 |         4
        1 |         1 |      50 |         3
        1 |         1 |      50 |         2
        1 |         1 |      50 |         1
(34 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  5
(1 row)

fetch forward  35 from back_up_terminate_toplevel_wrong;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         1 |      50 |         2
        1 |         1 |      50 |         3
        1 |         1 |      50 |         4
        1 |         1 |      50 |         5
        1 |         1 |      50 |         6
        1 |         1 |      50 |         7
        1 |         1 |      50 |         8
        1 |         1 |      50 |         9
        1 |         1 |      50 |        10
        1 |         2 |      48 |         1
        1 |         2 |      48 |         2
        1 |         2 |      48 |         3
        1 |         2 |      48 |         4
        1 |         2 |      48 |         5
        1 |         2 |      48 |         6
        1 |         2 |      48 |         7
        1 |         2 |      48 |         8
        1 |         2 |      48 |         9
        1 |         2 |      48 |        10
        1 |         2 |      50 |         1
        1 |         2 |      50 |         2
        1 |         2 |      50 |         3
        1 |         2 |      50 |         4
        1 |         2 |      50 |         5
        1 |         2 |      50 |         6
        1 |         2 |      50 |         7
        1 |         2 |      50 |         8
        1 |         2 |      50 |         9
        1 |         2 |      50 |        10
        3 |         1 |      48 |         1
        3 |         1 |      48 |         2
        3 |         1 |      48 |         3
        3 |         1 |      48 |         4
        3 |         1 |      48 |         5
        3 |         1 |      48 |         6
(35 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('backup_wrong_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  5
(1 row)

/* back_up_terminate_toplevel_wrong */ commit;
-- Show EXPLAIN ANALYZE for cursor from transaction block:
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare back_up_terminate_toplevel_wrong cursor for
select * from backup_wrong_tbl
where district in (1, 3) and warehouse in (1,2)
and orderid in (48, 50)
order by district, warehouse, orderid, orderline;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using backup_wrong_idx on backup_wrong_tbl  (cost=0.28..47.44 rows=80 width=16) (actual rows=80 loops=1)
   Index Cond: ((district = ANY ('{1,3}'::integer[])) AND (warehouse = ANY ('{1,2}'::integer[])) AND (orderid = ANY ('{48,50}'::integer[])))
   Buffers: shared hit=18
(3 rows)

-- (November 25)
--
-- Case that led to an assertion failure in _bt_advance_array_keys, at the
-- point that it deals with inequalities required in the opposite direction
-- only.
begin;
declare inequalities_orderid cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
and orderid >= 1 and orderid <= 1000
and orderline in (-500,5,7,8,9,500)
order by district, warehouse, orderid, orderline;
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
fetch forward 10 from inequalities_orderid;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         5
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       2 |         5
        1 |         3 |       2 |         7
        1 |         3 |       2 |         8
        1 |         3 |       2 |         9
        1 |         3 |       3 |         5
        1 |         3 |       3 |         7
(10 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

fetch backward 20 from inequalities_orderid;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       3 |         5
        1 |         3 |       2 |         9
        1 |         3 |       2 |         8
        1 |         3 |       2 |         7
        1 |         3 |       2 |         5
        1 |         3 |       1 |         9
        1 |         3 |       1 |         8
        1 |         3 |       1 |         7
        1 |         3 |       1 |         5
(9 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

fetch forward 5 from inequalities_orderid;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         5
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       2 |         5
(5 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

fetch backward 5 from inequalities_orderid;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         9
        1 |         3 |       1 |         8
        1 |         3 |       1 |         7
        1 |         3 |       1 |         5
(4 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

fetch forward 15 from inequalities_orderid;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         5
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       2 |         5
        1 |         3 |       2 |         7
        1 |         3 |       2 |         8
        1 |         3 |       2 |         9
        1 |         3 |       3 |         5
        1 |         3 |       3 |         7
        1 |         3 |       3 |         8
        1 |         3 |       3 |         9
        1 |         3 |       4 |         5
        1 |         3 |       4 |         7
        1 |         3 |       4 |         8
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

move forward 10000 in inequalities_orderid;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
 99
(1 row)

-- "Fetch backward 15 from inequalities_orderid" Led to this assertion failure:
-- TRAP: failed Assert("opsktrig < first_nonrequired_ikey || first_nonrequired_ikey == -1"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 1993, PID: 900702
fetch backward 15 from inequalities_orderid;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         5 |     150 |         9
        3 |         5 |     150 |         8
        3 |         5 |     150 |         7
        3 |         5 |     150 |         5
        3 |         5 |     149 |         9
        3 |         5 |     149 |         8
        3 |         5 |     149 |         7
        3 |         5 |     149 |         5
        3 |         5 |     148 |         9
        3 |         5 |     148 |         8
        3 |         5 |     148 |         7
        3 |         5 |     148 |         5
        3 |         5 |     147 |         9
        3 |         5 |     147 |         8
        3 |         5 |     147 |         7
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

move backward 10000 in inequalities_orderid;
\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh  
-----
 100
(1 row)

fetch forward 15 from inequalities_orderid;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         3 |       1 |         5
        1 |         3 |       1 |         7
        1 |         3 |       1 |         8
        1 |         3 |       1 |         9
        1 |         3 |       2 |         5
        1 |         3 |       2 |         7
        1 |         3 |       2 |         8
        1 |         3 |       2 |         9
        1 |         3 |       3 |         5
        1 |         3 |       3 |         7
        1 |         3 |       3 |         8
        1 |         3 |       3 |         9
        1 |         3 |       4 |         5
        1 |         3 |       4 |         7
        1 |         3 |       4 |         8
(15 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('must_not_full_scan'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

/* inequalities_orderid */ commit;
-- Show EXPLAIN ANALYZE for cursor from transaction block:
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare inequalities_orderid cursor for
select * from redescend_test
where district in (1, 3) and warehouse in (3, 4, 5, 6, 7)
and orderid >= 1 and orderid <= 1000
and orderline in (-500,5,7,8,9,500)
order by district, warehouse, orderid, orderline;
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..482.94 rows=3600 width=16) (actual rows=3600 loops=1)
   Index Cond: ((district = ANY ('{1,3}'::integer[])) AND (warehouse = ANY ('{3,4,5,6,7}'::integer[])) AND (orderid >= 1) AND (orderid <= 1000) AND (orderline = ANY ('{-500,5,7,8,9,500}'::integer[])))
   Buffers: shared hit=151
(3 rows)

--
-- Proof that code path that starts a new primitive index scan when it detects
-- that we might be too far before the start of _bt_first-wise matches, by flippping
-- scan direction and recalling _bt_check_compare, was buggy.
--
-- (February 19)
--
-- Issue is that we need to reset lower-order non-required arrays after the
-- required unsatisfied inequality that's required in the opposite-to-scan
-- direction to the first element (for the current scan direction).
-- This is like an earlier November 19 "independently found a bug" test case,
-- except that it deletes stuff from index that masked the bug there:
delete from redescend_test
where district = 2
  and warehouse = 1
  and orderid = 1
  and orderline < 8;
vacuum (index_cleanup on) redescend_test;
-- Other than that it's the same as earlier test (same answer, even):
select *
from redescend_test
where
  district in (1, 2, 3)
  and warehouse >= 5
  and orderid >= 150
  and orderline in (6, 7, 8);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from redescend_test
where
  district in (1, 2, 3)
  and warehouse >= 5
  and orderid >= 150
  and orderline in (6, 7, 8);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid >= 150) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=9
(3 rows)

-- Repeat, deleting all the orderlines matching (2,1,1, *):
delete from redescend_test
where district = 2
  and warehouse = 1
  and orderid = 1;
vacuum (index_cleanup on) redescend_test;
-- Other than that it's the same as earlier test (same answer, even):
select *
from redescend_test
where
  district in (1, 2, 3)
  and warehouse >= 5
  and orderid >= 150
  and orderline in (6, 7, 8);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from redescend_test
where
  district in (1, 2, 3)
  and warehouse >= 5
  and orderid >= 150
  and orderline in (6, 7, 8);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=9 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid >= 150) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=9
(3 rows)

-- Backward scan variant (for good luck):
delete from redescend_test
where district = 2
  and warehouse = 5
  and orderid = 150
  and orderline > 6;
vacuum (index_cleanup on) redescend_test;
-- First backward scan
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=6 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse <= 1) AND (orderid <= 1) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=8
(3 rows)

delete from redescend_test
where district = 2
  and warehouse = 5
  and orderid = 150;
vacuum (index_cleanup on) redescend_test;
-- Second backward scan
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan on redescend_test  (cost=0.29..122.82 rows=6 width=16) (actual rows=6 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse <= 1) AND (orderid <= 1) AND (orderline = ANY ('{6,7,8}'::integer[])))
   Buffers: shared hit=8
(3 rows)

--
-- We must not get confused by NULLs, which can terminate the scan (by having
-- _bt_check_compare set continuesca=false) even when the inequality is
-- required in the opposite scan direction only.  (See commit 882368e8,
-- "Fix btree stop-at-nulls logic properly" for more context on this behavior).
--
-- (February 23)
--
-- In this test case we insert many irrelevant-to-scan NULLs, that fill pages
-- that our index scan had better not waste time on accessing:
insert into redescend_test
select district, NULL, NULL, NULL
from
  generate_series(1, 2) district,
  generate_series(1, 2000) want_2k_nulls_per_district;
--
-- (February 23)
--
-- Fix for this bug was to treat required-in-opposite-direction-only scan keys
-- that see _bt_check_compare trigger continuescan=false due to the NULL
-- special case get treated rather like any other case where _bt_check_compare
-- sets continuescan=false upon encountering a required scan key -- namely, we
-- now do "beyond_end_advance" advancement in the style of other non-array required
-- scan keys.
--
-- This created a new problem (regressing older tests), though: it made
-- earlier and longer established required-in-opposite-direction-only cases
-- start to scan way too many pages again.  So fix had to do a special
-- sktrig-opposite-dir test that considers starting a new primitive index scan
-- if finaltup is still < new array keys (according to _bt_tuple_before_array_skeys,
-- at least).
--
select *
from redescend_test
where
  district in (1, 2, 3)
  and warehouse >= 5
  and orderid >= 150;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         1
        1 |         5 |     150 |         2
        1 |         5 |     150 |         3
        1 |         5 |     150 |         4
        1 |         5 |     150 |         5
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        1 |         5 |     150 |         9
        1 |         5 |     150 |        10
        3 |         5 |     150 |         1
        3 |         5 |     150 |         2
        3 |         5 |     150 |         3
        3 |         5 |     150 |         4
        3 |         5 |     150 |         5
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
        3 |         5 |     150 |         9
        3 |         5 |     150 |        10
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from redescend_test
where
  district in (1, 2, 3)
  and warehouse >= 5
  and orderid >= 150;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..141.77 rows=24 width=16) (actual rows=20 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (warehouse >= 5) AND (orderid >= 150))
   Buffers: shared hit=8
(3 rows)

--
-- (February 23)
--
-- Same again, but with RowCompare at the end (just for good luck)
--
select *
from redescend_test
where
  district in (1, 2, 3)
  and (warehouse,orderid) >= (5,150);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         1
        1 |         5 |     150 |         2
        1 |         5 |     150 |         3
        1 |         5 |     150 |         4
        1 |         5 |     150 |         5
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        1 |         5 |     150 |         9
        1 |         5 |     150 |        10
        3 |         5 |     150 |         1
        3 |         5 |     150 |         2
        3 |         5 |     150 |         3
        3 |         5 |     150 |         4
        3 |         5 |     150 |         5
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
        3 |         5 |     150 |         9
        3 |         5 |     150 |        10
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from redescend_test
where
  district in (1, 2, 3)
  and (warehouse,orderid) >= (5,150);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..281.85 rows=3634 width=16) (actual rows=20 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) >= ROW(5, 150)))
   Buffers: shared hit=8
(3 rows)

--
-- (February 23)
--
-- Same again, but with non-required array at the end (just for good luck)
--
select *
from redescend_test
where
  district in (1, 2, 3)
  and (warehouse,orderid) >= (5,150)
  and orderline in (3, 6, 9);
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         3
        1 |         5 |     150 |         6
        1 |         5 |     150 |         9
        3 |         5 |     150 |         3
        3 |         5 |     150 |         6
        3 |         5 |     150 |         9
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from redescend_test
where
  district in (1, 2, 3)
  and (warehouse,orderid) >= (5,150)
  and orderline in (3, 6, 9);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan on redescend_test  (cost=0.29..257.61 rows=1090 width=16) (actual rows=6 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::integer[])) AND (ROW(warehouse, orderid) >= ROW(5, 150)) AND (orderline = ANY ('{3,6,9}'::integer[])))
   Buffers: shared hit=8
(3 rows)

reset work_mem;
reset enable_sort;
------------------------
-- DESC columns tests --
------------------------
set client_min_messages=error;
drop table if exists skippy_tbl_desc;
reset client_min_messages;
create unlogged table skippy_tbl_desc(
  bar int4
);
create index skippy_idx_desc on skippy_tbl_desc(bar desc);
insert into skippy_tbl_desc
select
  i
from
  generate_series(1, 500) i;
insert into skippy_tbl_desc
select
  555
from
  generate_series(1, 3000) i;
-- prewarm
select count(*) from skippy_tbl_desc;
 count 
-------
  3500
(1 row)

vacuum analyze skippy_tbl_desc;
-- Looks like this now:
--
-- ┌───┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬──────────────────────────────────┐
-- │ i │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │             highkey              │
-- ├───┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼──────────────────────────────────┤
-- │ 1 │     1 │     1 │  1,278 │      6 │          0 │     7 │     0 │                 0 │   1,115 │       312 │ (bar)=(555), (htid)=('(7,196)')  │
-- │ 2 │     7 │     1 │  1,278 │      7 │          0 │     7 │     0 │                 0 │   1,115 │       312 │ (bar)=(555), (htid)=('(13,118)') │
-- │ 3 │     8 │     1 │    444 │      3 │          0 │    41 │     0 │                 0 │      75 │     4,888 │ (bar)=(500)                      │
-- │ 4 │     6 │     1 │     50 │      2 │          0 │    51 │     0 │                 0 │      16 │     7,128 │ (bar)=(450)                      │
-- │ 5 │     5 │     1 │    204 │      1 │          0 │   205 │     0 │                 0 │      16 │     4,048 │ (bar)=(246)                      │
-- │ 6 │     4 │     1 │    204 │      2 │          0 │   205 │     0 │                 0 │      16 │     4,048 │ (bar)=(42)                       │
-- │ 7 │     2 │     1 │     42 │      1 │          0 │    42 │     0 │                 0 │      16 │     7,308 │ ∅                                │
-- └───┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴──────────────────────────────────┘
--
-----------------------------------------------------------------------
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Don't get confused by DESC condition with pivot tuple high key termination:
select count(*) from skippy_tbl_desc where bar in (500,555);
 count 
-------
  3001
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from skippy_tbl_desc where bar in (500,555);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=96.84..96.85 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=7
   ->  Bitmap Heap Scan on skippy_tbl_desc  (cost=35.83..89.34 rows=3001 width=0) (actual rows=3001 loops=1)
         Recheck Cond: (bar = ANY ('{500,555}'::integer[]))
         Buffers: shared hit=7
         ->  Bitmap Index Scan on skippy_idx_desc  (cost=0.00..35.08 rows=3001 width=0) (actual rows=3001 loops=1)
               Index Cond: (bar = ANY ('{500,555}'::integer[]))
               Buffers: shared hit=5
(8 rows)

-- Backwards scan variant (doesn't use high key at all):
-- This is a convenient point to verify that backwards scans terminate without
-- redescending when there are a bunch of non-existent low sorting values on
-- the leftmost page (a similar test for forward scans happens elsewhere).
set enable_sort=off;
select distinct bar from skippy_tbl_desc where bar in (500,555,556,557,558,559,600) order by bar asc;
 bar 
-----
 500
 555
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select distinct bar from skippy_tbl_desc where bar in (500,555,556,557,558,559,600) order by bar asc;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Unique  (cost=0.28..87.96 rows=501 width=4) (actual rows=2 loops=1)
   Buffers: shared hit=34
   ->  Index Scan Backward using skippy_idx_desc on skippy_tbl_desc  (cost=0.28..80.45 rows=3006 width=4) (actual rows=3001 loops=1)
         Disabled: true
         Index Cond: (bar = ANY ('{500,555,556,557,558,559,600}'::integer[]))
         Buffers: shared hit=34
(6 rows)

set enable_sort=on;
----------------
-- NULLs test --
----------------
set client_min_messages=error;
drop table if exists nulls_test;
reset client_min_messages;
create unlogged table nulls_test(
  a int,
  b int
);
create index nulls_test_idx on nulls_test(a nulls first, b);
insert into nulls_test
select
  j,
  case when i < 14 then
    0
  else
    1
  end
from
  generate_series(1, 14) i,
  generate_series(1, 400) j
order by
  j,
  i;
insert into nulls_test
select
  NULL,
  case when i < 14 then
    0
  else
    1
  end
from
  generate_series(1, 14) i,
  generate_series(1, 400) j
order by
  j,
  i;
vacuum analyze nulls_test;
-- Looks like this now:
--
-- ┌────┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬───────────────────────────────────────┐
-- │ i  │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │                highkey                │
-- ├────┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼───────────────────────────────────────┤
-- │  1 │     1 │     1 │  1,271 │      7 │          0 │     7 │     0 │                 0 │   1,116 │       304 │ (a, b)=(null, 0), (htid)=('(30,188)') │
-- │  2 │    11 │     1 │  1,271 │      7 │          0 │     7 │     0 │                 0 │   1,116 │       304 │ (a, b)=(null, 0), (htid)=('(36,201)') │
-- │  3 │    12 │     1 │  1,271 │      7 │          0 │     7 │     0 │                 0 │   1,116 │       304 │ (a, b)=(null, 0), (htid)=('(42,214)') │
-- │  4 │    13 │     1 │  1,271 │      8 │          0 │     7 │     0 │                 0 │   1,116 │       304 │ (a, b)=(null, 0), (htid)=('(49,1)')   │
-- │  5 │    14 │     1 │    116 │      1 │          0 │   117 │     0 │                 0 │      24 │     4,872 │ (a, b)=(null, 1)                      │
-- │  6 │    10 │     1 │    778 │     28 │          0 │   113 │     0 │                 0 │      57 │     1,192 │ (a, b)=(28)                           │
-- │  7 │     9 │     1 │    476 │      3 │          0 │    69 │     0 │                 0 │      55 │     4,048 │ (a, b)=(62)                           │
-- │  8 │     2 │     1 │    854 │      5 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(123)                          │
-- │  9 │     4 │     1 │    854 │      5 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(184)                          │
-- │ 10 │     5 │     1 │    854 │      5 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(245)                          │
-- │ 11 │     6 │     1 │    854 │      4 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(306)                          │
-- │ 12 │     7 │     1 │    854 │      5 │          0 │   123 │     0 │                 0 │      55 │       808 │ (a, b)=(367)                          │
-- │ 13 │     8 │     1 │    476 │      3 │          0 │    80 │     0 │                 0 │      49 │     3,908 │ ∅                                     │
-- └────┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴───────────────────────────────────────┘
--
-----------------------------------------------------------------------
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Just two buffer accesses here (one for root, the other for leaf page 14):
-- Note: provides coverage of "NULL < NOT_NULL" case
select count(*) from nulls_test where a is NULL and b in (1,2);
 count 
-------
   400
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from nulls_test where a is NULL and b in (1,2);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=64.67..64.68 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=4
   ->  Bitmap Heap Scan on nulls_test  (cost=8.67..63.67 rows=400 width=0) (actual rows=400 loops=1)
         Recheck Cond: ((a IS NULL) AND (b = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=4
         ->  Bitmap Index Scan on nulls_test_idx  (cost=0.00..8.57 rows=400 width=0) (actual rows=400 loops=1)
               Index Cond: ((a IS NULL) AND (b = ANY ('{1,2}'::integer[])))
               Buffers: shared hit=2
(8 rows)

-- Need 7 buffer accesses here (one for root, another 6 for pages 1, 11, 12,
-- 13, 14, and 10):
-- Note: provides coverage of "NULL < NOT_NULL" case
select count(*) from nulls_test where a is NULL and b in (0,1);
 count 
-------
  5600
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from nulls_test where a is NULL and b in (0,1); -- shouldn't be visiting 9, though
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=205.97..205.98 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=9
   ->  Bitmap Heap Scan on nulls_test  (cost=71.97..191.97 rows=5600 width=0) (actual rows=5600 loops=1)
         Recheck Cond: ((a IS NULL) AND (b = ANY ('{0,1}'::integer[])))
         Buffers: shared hit=9
         ->  Bitmap Index Scan on nulls_test_idx  (cost=0.00..70.57 rows=5600 width=0) (actual rows=5600 loops=1)
               Index Cond: ((a IS NULL) AND (b = ANY ('{0,1}'::integer[])))
               Buffers: shared hit=7
(8 rows)

-- On the other hand we'll only need 6 here (root, plus another 5 for pages 1,
-- 11, 13, and 14).
select count(*) from nulls_test where a is NULL and b in (-1, 0);
 count 
-------
  5200
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from nulls_test where a is NULL and b in (-1, 0); -- shouldn't be visiting 10, though
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=195.87..195.88 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=8
   ->  Bitmap Heap Scan on nulls_test  (cost=67.87..182.87 rows=5200 width=0) (actual rows=5200 loops=1)
         Recheck Cond: ((a IS NULL) AND (b = ANY ('{-1,0}'::integer[])))
         Buffers: shared hit=8
         ->  Bitmap Index Scan on nulls_test_idx  (cost=0.00..66.57 rows=5200 width=0) (actual rows=5200 loops=1)
               Index Cond: ((a IS NULL) AND (b = ANY ('{-1,0}'::integer[])))
               Buffers: shared hit=6
(8 rows)

-- NULLS FIRST, but a backwards scan:
-- Note: provides coverage of "NOT_NULL > NULL" case
set enable_bitmapscan to off;
set enable_indexonlyscan to on;
set enable_indexscan to off;
select * from nulls_test where a in (1,2) and b in (-1,-2) order by a desc nulls last, b desc;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_test where a in (1,2) and b in (-1,-2) order by a desc nulls last, b desc;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using nulls_test_idx on nulls_test  (cost=0.29..9.19 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = ANY ('{-1,-2}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=2
(5 rows)

-- More complicated variant:
--
-- XXX Incorrect commentary:
--
-- Note: (July 18) I initially overlooked a regression here, where backwards
-- scans would senselessly fail to skip several leaf pages (remember, it was
-- after I added emojis to debug log to make it easier to grasp the high level
-- structure with lots of output?).
--
-- I guess it's easier to overlook backwards scan issues, since you can't just
-- force a bitmap index scan to get index breakdown in EXPLAIN ANALYZE.
--
-- Note: (July 18) This is also an example of speculatively accessing the next
-- page during a backwards scan, while dealing with uncertainty about what's
-- on the next page.  Here we find some matches on the initial page we descend
-- onto, which encourages us to access its left sibling page -- which doesn't
-- work out.  If we didn't make this gamble then we'd only have 8 buffer
-- accesses instead of 9.  But it's an intelligent gamble that usually works
-- out (and works out in other test cases), so I say that this is worth it --
-- a bad speculation, but the cost of doing business.
--
-- XXX correction:
--
-- Update: (September 12) Well, that previous commentary was all wrong, and
-- likely written on autopilot just before leaving for NYC (the fact that this
-- was before I came up with the idea of using unlogged tables for better
-- insights into index page accesses in EXPLAIN ANALYZE output wouldn't have
-- helped, either).
--
-- In reality, this index should do 2 descents for two leaf pages, for a total
-- of 4 buffer accesses to the index itself, and 5 total (assuming one VM hit).
--
-- Update: (November 1) Recall that this test case went on to cause further
-- confusion in late October.  Today you figured out that this was really an
-- issue with _bt_binsrch_array_skey() not doing the right thing for backwards
-- scans, in that the progress of array key advancement wouldn't ratchet in
-- the scan direction (i.e. it was unlike forward scans once you actually
-- instrumented the binary searches themselves, even for the very simplest
-- cases with one page and two constants).
select * from nulls_test where a in (1,2,350,359,360) and b in (-1,-2,1) order by a desc nulls last, b desc;
  a  | b 
-----+---
 360 | 1
 359 | 1
 350 | 1
   2 | 1
   1 | 1
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_test where a in (1,2,350,359,360) and b in (-1,-2,1) order by a desc nulls last, b desc; -- 4 or 5 (depending on if you count the VM or not) buffer accesses
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using nulls_test_idx on nulls_test  (cost=0.29..11.53 rows=5 width=8) (actual rows=5 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{1,2,350,359,360}'::integer[])) AND (b = ANY ('{-1,-2,1}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=5
(5 rows)

-- These don't hit "NOT_NULL > NULL" path, so they're just for good luck:
select * from nulls_test where a in (368,369) and b in (-1,-2,1) order by a desc nulls last, b desc;
  a  | b 
-----+---
 369 | 1
 368 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_test where a in (368,369) and b in (-1,-2,1) order by a desc nulls last, b desc;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using nulls_test_idx on nulls_test  (cost=0.29..11.50 rows=2 width=8) (actual rows=2 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{368,369}'::integer[])) AND (b = ANY ('{-1,-2,1}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

-- Note: (September 4) This was the test case that was broken for some time,
-- unbeknownst to you.  You only figured this out when work on binary search
-- in arrays (the difficult work of getting the code to stop rescanning the
-- same tuple multiple times) was well underway.  Slightly unpleasant to learn
-- that I'd missed this earlier.
--
-- Here we have to visit leaf pages 7 and 8 (plus the root) because (since
-- this is a backwards scan) there's no way we can be sure that page 7 doesn't
-- have a tuple "(367, *)".  Of course the high key of page 7 would let us
-- know that, but we're coming from the right sibling to the left, so that's
-- not available (we could also choose to remember info from internal pages,
-- but seems not to be worth it to me)
--
-- XXX UPDATE (December 3): This changed (two extra buffer hits) when you changed
-- finaltup rules to insist on exact match.
select * from nulls_test where a in (367,368) and b in (-1,-2,1) order by a desc nulls last, b desc;
  a  | b 
-----+---
 368 | 1
 367 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_test where a in (367,368) and b in (-1,-2,1) order by a desc nulls last, b desc;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using nulls_test_idx on nulls_test  (cost=0.29..11.50 rows=2 width=8) (actual rows=2 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{367,368}'::integer[])) AND (b = ANY ('{-1,-2,1}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=6
(5 rows)

-- XXX UPDATE (December 3): This also changed (two extra buffer hit) when you changed
-- finaltup rules to insist on exact match.
select * from nulls_test where a in (366,367) and b in (-1,-2,1) order by a desc nulls last, b desc;
  a  | b 
-----+---
 367 | 1
 366 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_test where a in (366,367) and b in (-1,-2,1) order by a desc nulls last, b desc;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using nulls_test_idx on nulls_test  (cost=0.29..11.50 rows=2 width=8) (actual rows=2 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{366,367}'::integer[])) AND (b = ANY ('{-1,-2,1}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=6
(5 rows)

-- XXX UPDATE (December 3): This one stayed the same, though.
select * from nulls_test where a in (365,366) and b in (-1,-2,1) order by a desc nulls last, b desc;
  a  | b 
-----+---
 366 | 1
 365 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_test where a in (365,366) and b in (-1,-2,1) order by a desc nulls last, b desc;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using nulls_test_idx on nulls_test  (cost=0.29..11.50 rows=2 width=8) (actual rows=2 loops=1)
   Disabled: true
   Index Cond: ((a = ANY ('{365,366}'::integer[])) AND (b = ANY ('{-1,-2,1}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=3
(5 rows)

----------------------------------------
-- Basic "NULL != NULL" code coverage --
----------------------------------------
set client_min_messages=error;
drop table if exists coverage_null_compare_nonequal;
reset client_min_messages;
create unlogged table coverage_null_compare_nonequal(a int4, b int4);
create index coverage_null_compare_nonequal_idx on coverage_null_compare_nonequal (a, b nulls first);
insert into coverage_null_compare_nonequal select i from generate_series(1,3) i;
insert into coverage_null_compare_nonequal select null from generate_series(1,2000);
-- Looks like this now:
--
-- ┌───┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬─────────────────────────────────────────┐
-- │ i │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │                 highkey                 │
-- ├───┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼─────────────────────────────────────────┤
-- │ 1 │     1 │     1 │      3 │      1 │          0 │     4 │     0 │                 0 │      22 │     8,044 │ (a, b)=(null)                           │
-- │ 2 │     2 │     1 │  1,319 │      5 │          0 │     7 │     0 │                 0 │   1,150 │        64 │ (a, b)=(null, null), (htid)=('(4,159)') │
-- │ 3 │     4 │     1 │    681 │      3 │          0 │   276 │     0 │                 0 │      24 │       180 │ ∅                                       │
-- └───┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴─────────────────────────────────────────┘
--
-----------------------------------------------------------------------
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Hits the path that needs at least some coverage:
-- Note: provides coverage of "NOT_NULL < NULL" case
select * from coverage_null_compare_nonequal where a in (1,2,3);
 a | b 
---+---
 1 |  
 2 |  
 3 |  
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from coverage_null_compare_nonequal where a in (1,2,3);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on coverage_null_compare_nonequal  (cost=4.82..15.29 rows=34 width=8) (actual rows=3 loops=1)
   Recheck Cond: (a = ANY ('{1,2,3}'::integer[]))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on coverage_null_compare_nonequal_idx  (cost=0.00..4.81 rows=34 width=0) (actual rows=3 loops=1)
         Index Cond: (a = ANY ('{1,2,3}'::integer[]))
         Buffers: shared hit=2
(7 rows)

---------------------------------------------------------
-- required-same-direction IS NOT NULL confusion tests --
---------------------------------------------------------
set client_min_messages=error;
drop table if exists scankey_confusion;
reset client_min_messages;
create unlogged table scankey_confusion(
  a int,
  b int,
  c int
);
create index scankey_confusion_idx on scankey_confusion(a, b, c);
insert into scankey_confusion select 1, NULL, 3 from generate_series(1,1500);
insert into scankey_confusion select 0, NULL, 0;
-- looks like this now:
--
-- ┌───┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬────────────────────────────────────────────┐
-- │ i │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │                  highkey                   │
-- ├───┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼────────────────────────────────────────────┤
-- │ 1 │     1 │     1 │  1,272 │      7 │          0 │     8 │     0 │                 0 │     980 │       276 │ (a, b, c)=(1, null, 3), (htid)=('(5,141)') │
-- │ 2 │     2 │     1 │    229 │      2 │          0 │   229 │     0 │                 0 │      24 │     1,736 │ ∅                                          │
-- └───┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴────────────────────────────────────────────┘
--
-----------------------------------------------------------------------
-- Make sure that (a, b)=(1, null), (htid)=('(5,141)') high key will be compared by
-- insertion scan key function if we have a regression and allow
-- SK_BT_REQFWD-less scankeys to be used again:
delete from scankey_confusion where a = 1 and b is null;
vacuum scankey_confusion;
-- Now that we've done that delete + VACUUM, index looks like this (XXX a little misleading):
--
-- ┌───┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬────────────────────────────────────────────┐
-- │ i │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │                  highkey                   │
-- ├───┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼────────────────────────────────────────────┤
-- │ 1 │     1 │     1 │      1 │      1 │          0 │     2 │     0 │                 0 │      28 │     8,084 │ (a, b, c)=(1, null, 3), (htid)=('(5,141)') │
-- └───┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴────────────────────────────────────────────┘
--
-- XXX: This is misleading.  Rightmost page not shown due to this case borking
-- :leafkeyspace query, but it is still there.  Just for context, here's
-- :rootitems at this same point in the test:
--
-- ┌────────────┬──────────┬─────────┬───────┬──────┬────────────────────────┬──────┬─────────┬──────┐
-- │ itemoffset │   ctid   │ itemlen │ nulls │ vars │          data          │ dead │  htid   │ tids │
-- ├────────────┼──────────┼─────────┼───────┼──────┼────────────────────────┼──────┼─────────┼──────┤
-- │          1 │ (1,0)    │       8 │ f     │ f    │ (a, b, c)=()           │ ∅    │ ∅       │ ∅    │
-- │          2 │ (2,4099) │      32 │ t     │ f    │ (a, b, c)=(1, null, 3) │ ∅    │ (5,141) │ ∅    │
-- └────────────┴──────────┴─────────┴───────┴──────┴────────────────────────┴──────┴─────────┴──────┘
-- Main, original "scankey_confusion" test:
--
-- Try to make the implementation confused about same-direction-required IS NOT NULL inequality
--
-- (September 7) XXX:  This gets 3 buffer hits, instead of 2, as before
-- binary search on tuple stuff was in.  I think that that might be due to the
-- fact that one of the search-type scan keys isn't required by the scan.
-- We can maybe do better here, but let's not worry about it just yet.
--
-- (September 11) XXX: Yeah, I think that that's all it is.  It's probably an
-- example of a more general problem, though.  I think that any combination of
-- a inequality strategy scan key that's required.  So anything that looks
-- roughly like this + a high key comparison could be a problem
-- (SK_SEARCHNOTNULL is not relevant, SK_BT_REQFWD-only + high key is relevant):
--
-- _bt_preprocess_keys: output inkeys[1]: [ flags: [SK_ISNULL, SK_SEARCHNOTNULL, SK_BT_REQFWD]
--
-- Basically this happens because the second call to _bt_check_compare() is
-- (somewhat suspiciously) not allowed to set continuescan=false, no matter
-- what, in the case where _bt_advance_array_keys_locally() said that the
-- tuple has keys that equal all of the corresponding current array elements.
--
-- What's so special about BTEqualStrategyNumber, anyway? The only special
-- thing about them is the need to suppress continuescan=false when we're
-- too early (per _bt_first and _bt_checkkeys/_bt_check_compare comments).
--
-- (September 14) UPDATE: Yeah, this is now fixed once again -- now we go back
-- to not being confused about inequalities.  Recall that this happened when
-- you figured out (or more like stumbled upon) a way to not have to veto what the
-- second call to _bt_check_compare says about "continuescan" -- the call at
-- the end of _bt_checkkeys (after _bt_checkkeys has found matching equality/array
-- keys, leaving only the possibility of continuescan=false being set due to
-- required inequality type keys).
--
-- XXX UPDATE: (November 11) Actually, this was wrong.  I think that I do need
-- to suppress continuescan=false set by the second call to _bt_check_compare
-- after all.  See "don't accept continuescan=false during second call to
-- _bt_check_compare" bug test case, below.
--
-- XXX UPDATE: (November 16) Actually, the original idea (that we only need
-- two buffer hits for this original query) was correct, but became conflated
-- with the aforementioned correctness issue of November 11.
--
-- Here's whats really going on here: we need to make _bt_advance_array_keys
-- call itself recursively to deal with a tuple that has two required scan
-- keys that become unsatisfied at the same time: the array on "a", and the
-- inequality on "b" (IS NOT NULL is required in only one direction, sort of
-- like 'WHERE b < NULL").  If we don't realize that it's both at the same
-- time during within the same tuple/call, we won't notice the second
-- inequality right away.
--
-- AFAICT allowing this really wouldn't be harmful, but it would mean that
-- this case would only terminate having read both of the leaf pages (leftmost
-- and rightmost leaf pages).  More importantly, not handling this precisely
-- would add an awkward caveat to the promise that _bt_advance_array_keys
-- makes about advancing the array keys to the maximum extent that's known to
-- be possible based on the scan's current tuple.  The recursive call thing is
-- kinda ugly, but right now I judge that it's less ugly than not having it.
--
-- Note: Here the recursive call to _bt_advance_array_keys happens on tuple:
-- (a, b)=(0, null)
--
-- XXX UPDATE (February 18): See also, related test case
-- equal_inequal_nonrequired, which is a more complicated scenario involving
-- the recusive call to _bt_advance_array_keys
select * from scankey_confusion where a in (-1,0,1) and b is not null;
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from scankey_confusion where a in (-1,0,1) and b is not null; -- Just 2 buffer hits (root + leftmost leaf)
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on scankey_confusion  (cost=4.52..6.53 rows=1 width=12) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NOT NULL))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on scankey_confusion_idx  (cost=0.00..4.52 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NOT NULL))
         Buffers: shared hit=2
(6 rows)

-- This "is null" variant of the original provides a useful contrast, because
-- it really does need 3 buffer hits:
select * from scankey_confusion where a in (-1,0,1) and b is null;
 a | b | c 
---+---+---
 0 |   | 0
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from scankey_confusion where a in (-1,0,1) and b is null; -- 3 buffer hits (root and both leaf pages)
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on scankey_confusion  (cost=4.52..6.53 rows=1 width=12) (actual rows=1 loops=1)
   Recheck Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NULL))
   Heap Blocks: exact=1
   Buffers: shared hit=4
   ->  Bitmap Index Scan on scankey_confusion_idx  (cost=0.00..4.52 rows=1 width=0) (actual rows=1 loops=1)
         Index Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NULL))
         Buffers: shared hit=3
(7 rows)

-- This one should only need rightmost page (along with root):
select * from scankey_confusion where a in (2,3,4,5) and b is null;
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from scankey_confusion where a in (2,3,4,5) and b is null; -- Just 2 buffer hits (root + rightmost leaf)
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on scankey_confusion  (cost=4.52..6.54 rows=1 width=12) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{2,3,4,5}'::integer[])) AND (b IS NULL))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on scankey_confusion_idx  (cost=0.00..4.52 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{2,3,4,5}'::integer[])) AND (b IS NULL))
         Buffers: shared hit=2
(6 rows)

-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Original:
select * from scankey_confusion where a in (-1,0,1) and b is not null;
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from scankey_confusion where a in (-1,0,1) and b is not null; -- Just 2 buffer hits (root + leftmost leaf)
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan using scankey_confusion_idx on scankey_confusion  (cost=0.25..6.53 rows=1 width=12) (actual rows=0 loops=1)
   Index Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NOT NULL))
   Buffers: shared hit=2
(3 rows)

-- This "is null" variant of the original provides a useful contrast, because
-- it really does need 3 buffer hits:
select * from scankey_confusion where a in (-1,0,1) and b is null;
 a | b | c 
---+---+---
 0 |   | 0
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from scankey_confusion where a in (-1,0,1) and b is null; -- 3 buffer hits (root and both leaf pages)
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan using scankey_confusion_idx on scankey_confusion  (cost=0.25..6.53 rows=1 width=12) (actual rows=1 loops=1)
   Index Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NULL))
   Buffers: shared hit=4
(3 rows)

-- This one should only need rightmost page (along with root):
select * from scankey_confusion where a in (2,3,4,5) and b is null;
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from scankey_confusion where a in (2,3,4,5) and b is null; -- Just 2 buffer hits (root + rightmost leaf)
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan using scankey_confusion_idx on scankey_confusion  (cost=0.25..6.53 rows=1 width=12) (actual rows=0 loops=1)
   Index Cond: ((a = ANY ('{2,3,4,5}'::integer[])) AND (b IS NULL))
   Buffers: shared hit=2
(3 rows)

-- (November 11) "don't accept continuescan=false during second call to
-- _bt_check_compare" bug test case:
--
-- UPDATE (November 16) Note: Here the recursive call to
-- _bt_advance_array_keys happens on tuple:
--
-- (a, b)=(0, null)
--
-- IOW, it's the same tuple as the one we saw back with our "original" test
-- case, though this time the immediate outcome isn't terminating the
-- top-level scan -- making sure that the scan continues at that point instead
-- is what we set out to verify with this test case.
insert into scankey_confusion select 1, 1, 1; -- tuple goes on right edge of leftmost page, matches quals below
-- Quals match tuples that straddle leftmost and rightmost pages (all leaf
-- pages in index):
select * from scankey_confusion where a in (-1,0,1) and b is not null;
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 index buffer hits + 1 heap buffer hit
select * from scankey_confusion where a in (-1,0,1) and b is not null;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan using scankey_confusion_idx on scankey_confusion  (cost=0.25..6.53 rows=1 width=12) (actual rows=1 loops=1)
   Index Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NOT NULL))
   Buffers: shared hit=3
(3 rows)

-- Shouldn't matter if we have a satisfiable extra non-required array on c:
select * from scankey_confusion where a in (-1,0,1) and b is not null and c in (0,1,2);
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 index buffer hits + 1 heap buffer hit
select * from scankey_confusion where a in (-1,0,1) and b is not null and c in (0,1,2);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan using scankey_confusion_idx on scankey_confusion  (cost=0.25..6.54 rows=1 width=12) (actual rows=1 loops=1)
   Index Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NOT NULL) AND (c = ANY ('{0,1,2}'::integer[])))
   Buffers: shared hit=3
(3 rows)

-- Still shouldn't matter if we have a satisfiable extra non-required array on c:
select * from scankey_confusion where a in (-1,0,1) and b is not null and c in (0,1,2,50);
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 index buffer hits + 1 heap buffer hit
select * from scankey_confusion where a in (-1,0,1) and b is not null and c in (0,1,2,50);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan using scankey_confusion_idx on scankey_confusion  (cost=0.25..6.54 rows=1 width=12) (actual rows=1 loops=1)
   Index Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NOT NULL) AND (c = ANY ('{0,1,2,50}'::integer[])))
   Buffers: shared hit=3
(3 rows)

-- Plus even a non-satisfiable c array scan key shouldn't change number of
-- blocks hit in index (still 2, though no heap hit this time):
select * from scankey_confusion where a in (-1,0,1) and b is not null and c in (-55,-54, 40);
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 index buffer hits + 0 heap buffer hits
select * from scankey_confusion where a in (-1,0,1) and b is not null and c in (-55,-54, 40);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan using scankey_confusion_idx on scankey_confusion  (cost=0.25..6.54 rows=1 width=12) (actual rows=0 loops=1)
   Index Cond: ((a = ANY ('{-1,0,1}'::integer[])) AND (b IS NOT NULL) AND (c = ANY ('{-55,-54,40}'::integer[])))
   Buffers: shared hit=2
(3 rows)

-----------------------------------------
-- equal_inequal_nonrequired test case --
-----------------------------------------
-- (February 18)
--
-- Don't get confused with a mix of equality, inequality, and non-required
-- array -- this is a fancy version of scankey_confusion inequality.
--
-- This is another more complicated scenario involving
-- the recusive call to _bt_advance_array_keys.  It tests one aspect of the
-- logic becoming confused in the presence of a mix of required equality, required
-- inequality, and non-required array equality -- specifically, when they all
-- happen to change within one single call to _bt_advance_array_keys, for one
-- tuple only.
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
set client_min_messages=error;
drop table if exists equal_inequal_nonrequired;
reset client_min_messages;
-- Index has to have very wide tuples, to make it easy to defeat suffix
-- truncation:
create unlogged table equal_inequal_nonrequired(equal int4, inequal int4, nonrequired int4, filler text);
alter table plain_equal_inequal_nonrequired set (autovacuum_enabled=off);
ERROR:  relation "plain_equal_inequal_nonrequired" does not exist
alter table equal_inequal_nonrequired alter column filler set storage plain;
create index plain_equal_inequal_nonrequired on equal_inequal_nonrequired(equal, inequal, nonrequired, filler);
-- Make sure storage of index is as expected (no TOAST compression):
select attrelid::regclass, attname, atttypid, attstorage
from pg_attribute
where attrelid::regclass::text = 'plain_equal_inequal_nonrequired';
            attrelid             |   attname   | atttypid | attstorage 
---------------------------------+-------------+----------+------------
 plain_equal_inequal_nonrequired | equal       |       23 | p
 plain_equal_inequal_nonrequired | inequal     |       23 | p
 plain_equal_inequal_nonrequired | nonrequired |       23 | p
 plain_equal_inequal_nonrequired | filler      |       25 | p
(4 rows)

-- Bulk insert:
insert into equal_inequal_nonrequired
select
  42,
  i % 5,
  i,
  repeat(chr(ascii('0')), 2500)
from
  generate_series(1, 20) i;
-- Now delete a much smaller tuple (no filler) that's going to be the one the
-- query returns from end of first page (page at blkno 1):
insert into equal_inequal_nonrequired
select
  41,
  -1,
  -1;
-- Delete other tuples in blkno 1:
delete from equal_inequal_nonrequired
where equal = 42
  and inequal = 0
  and nonrequired < 15;
-- Make sure the deleted tuples are gone from index:
vacuum equal_inequal_nonrequired;
-- Should see this now (:leafkeyspace not :rootitems shown in comments, just
-- for the extra detail):
--
-- pg@regression:5432 [131412]=# :leafkeyspace
--┌───┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬───────────────────────────────────────────────────┐
--│ i │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │                      highkey                      │
--├───┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼───────────────────────────────────────────────────┤
--│ 1 │     1 │     1 │      1 │      1 │          0 │     2 │     0 │                 0 │      28 │     8,084 │ (equal, inequal, nonrequired, filler)=(42, 0, 15) │
--│ 2 │     7 │     1 │      3 │      3 │          0 │     4 │     0 │                 0 │   1,902 │       524 │ (equal, inequal, nonrequired, filler)=(42, 1, 6)  │
--│ 3 │     4 │     1 │      3 │      3 │          0 │     4 │     0 │                 0 │   1,900 │       532 │ (equal, inequal, nonrequired, filler)=(42, 2)     │
--│ 4 │     6 │     1 │      2 │      2 │          0 │     3 │     0 │                 0 │   1,693 │     3,056 │ (equal, inequal, nonrequired, filler)=(42, 2, 12) │
--│ 5 │     8 │     1 │      2 │      2 │          0 │     3 │     0 │                 0 │   1,690 │     3,064 │ (equal, inequal, nonrequired, filler)=(42, 3)     │
--│ 6 │     2 │     1 │      2 │      2 │          0 │     3 │     0 │                 0 │   1,693 │     3,056 │ (equal, inequal, nonrequired, filler)=(42, 3, 13) │
--│ 7 │     9 │     1 │      2 │      2 │          0 │     3 │     0 │                 0 │   1,690 │     3,064 │ (equal, inequal, nonrequired, filler)=(42, 4)     │
--│ 8 │     5 │     1 │      2 │      2 │          0 │     3 │     0 │                 0 │   1,693 │     3,056 │ (equal, inequal, nonrequired, filler)=(42, 4, 14) │
--│ 9 │    10 │     1 │      2 │      2 │          0 │     2 │     0 │                 0 │   2,528 │     3,084 │ ∅                                                 │
--└───┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴───────────────────────────────────────────────────┘
--(9 rows)
-- This is :rootitems, just to avoid test regressions:
select itemoffset, ctid, itemlen, nulls from bt_page_items('plain_equal_inequal_nonrequired',
  (select fastroot::int4 from bt_metap('plain_equal_inequal_nonrequired')));
 itemoffset |  ctid  | itemlen | nulls 
------------+--------+---------+-------
          1 | (1,0)  |       8 | f
          2 | (7,3)  |      24 | f
          3 | (4,3)  |      24 | f
          4 | (6,2)  |      16 | f
          5 | (8,3)  |      24 | f
          6 | (2,2)  |      16 | f
          7 | (9,3)  |      24 | f
          8 | (5,2)  |      16 | f
          9 | (10,3) |      24 | f
(9 rows)

-- Returns (41 ,-1, -1) tuple that we just inserted on its own (right before the
-- DELETE + VACUUM):
select *
from
  equal_inequal_nonrequired
where
  equal in (41, 42)
  and inequal < 0
  and nonrequired in (-1, 55, 56);
 equal | inequal | nonrequired | filler 
-------+---------+-------------+--------
    41 |      -1 |          -1 | 
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- Two index buffer accesses (for root and one leaf) expected
select *
from
  equal_inequal_nonrequired
where
  equal in (41, 42)
  and inequal < 0
  and nonrequired in (-1, 55, 56);
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on equal_inequal_nonrequired  (cost=4.55..6.57 rows=1 width=44) (actual rows=1 loops=1)
   Recheck Cond: ((equal = ANY ('{41,42}'::integer[])) AND (inequal < 0) AND (nonrequired = ANY ('{-1,55,56}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on plain_equal_inequal_nonrequired  (cost=0.00..4.55 rows=1 width=0) (actual rows=1 loops=1)
         Index Cond: ((equal = ANY ('{41,42}'::integer[])) AND (inequal < 0) AND (nonrequired = ANY ('{-1,55,56}'::integer[])))
         Buffers: shared hit=2
(7 rows)

-- Buggy continuescan=true behavior version of the patch just before bug was
-- fixed:
/*
_bt_readpage: 🍀  1 with 2 offsets/tuples (leftsib 0, rightsib 7) ➡️
 _bt_readpage first: (equal, inequal, nonrequired, filler)=(41, -1, -1, null), 0x7fc801bdafb8, from non-pivot offnum 2 TID (6,3) started page
  _bt_checkkeys: comparing (equal, inequal, nonrequired, filler)=(41, -1, -1, null) with TID (6,3), 0x7fc801bdafb8
                 final result is true
  _bt_checkkeys: comparing (equal, inequal, nonrequired, filler)=(42, 0, 15) with TID -inf, 0x7fc801bdafd8
   ikey 0/sk_attno 1: (sk_argument 41) result: false, with continuescan=0
_bt_advance_array_keys, pivot tuple: (equal, inequal, nonrequired, filler)=(42, 0, 15), 0x7fc801bdafd8
  numberOfKeys: 3
  - sk_attno: 1, cur_elem 0/1, val: 41 [NULLS LAST, ASC]
  - sk_attno: 3, cur_elem 0/2, val: -1 [NULLS LAST, ASC]
   _bt_binsrch_array_skey: searching for item 42, cur_elem: 0 (val 41), low_elem 0, high_elem 1, num_elems: 2
                           found item 42 at elem offset 1
   _bt_binsrch_array_skey: searching for item 15, cur_elem: 0 (val 18446744073709551615), low_elem 0, high_elem 2, num_elems: 3
                           found item 55 at elem offset 1
  + sk_attno: 1, cur_elem 1/1, val: 42 [NULLS LAST, ASC]
  + sk_attno: 3, cur_elem 1/2, val: 55 [NULLS LAST, ASC]
  _bt_advance_array_keys: all_required_or_array_satisfied is 0
 _bt_readpage final: (equal, inequal, nonrequired, filler)=(42, 0, 15), 0x7fc801bdafd8, continuescan high key check did not set so->currPos.moreRight=false ➡️  🟢
 _bt_readpage stats: currPos.firstItem: 0, currPos.lastItem: 0, nmatching: 1 ✅
_bt_first: returning offnum 2 TID (6,3)
_bt_readpage: 🍀  7 with 4 offsets/tuples (leftsib 1, rightsib 4) ➡️   <--- Wonky, this leaf page access is superfluous

*** SNIP wasted leaf page access for next sibling page not shown ****
*/
-- The fix for this issue involved making sure that _bt_advance_array_keys
-- didn't skip its recheck of the tuple (meaning its call to _bt_check_compare)
-- due only to an unsatisfied non-required array key that it detected
-- (detected by not finding a matching array element for that non-required
-- scan key array).
--
-- The buggy case involved:
--
-- 1. Needing to call _bt_advance_array_keys to advance the required array on
--    "equal" att.  Finding a match (advancing the array) for "equal" happens
--    while finding an exact match.
-- 2. Skipping over the required inequality on "inequal" att.
-- 3. Needing to find a match for non-required array scan key for
--    "nonrequired" att.  Finding a match for "nonrequired" fails.
--
-- This sets us up for trouble, because buggy code thought that the recheck
-- call to _bt_check_compare wasn't necessary due to point 3 above.  That
-- meant that there was no possible way that we could detect point 2 above in
-- second pass over tuple (with recursive call to _bt_advance_array_keys).
--
-- How can there be a second pass over the tuple if there is no second call to
-- _bt_check_compare that allows us to notice the inequality missed in
-- _bt_checkkeys's original (pre-_bt_advance_array_keys) call to
-- _bt_check_compare?  Point 2 can only be detected by seeing the second call
-- to _bt_check_compare set continuescan=false, and working backwards from that.
--
-- (February 25)
--
-- This test case is concerned with not confusing Korotkov's continuescan
-- precheck mechanism when we gamble and assume that -inf truncated attributes suggest
-- matches on the very next page.  (See also: next test case, keys_ahead test.)
select equal, inequal, nonrequired
from equal_inequal_nonrequired
where
  equal = 42
  and inequal in (1, 2)
  and nonrequired = 17;
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |          17
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select equal, inequal, nonrequired
from equal_inequal_nonrequired
where
  equal = 42
  and inequal in (1, 2)
  and nonrequired = 17;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on equal_inequal_nonrequired  (cost=4.55..6.57 rows=1 width=12) (actual rows=1 loops=1)
   Recheck Cond: ((equal = 42) AND (inequal = ANY ('{1,2}'::integer[])) AND (nonrequired = 17))
   Heap Blocks: exact=1
   Buffers: shared hit=6
   ->  Bitmap Index Scan on plain_equal_inequal_nonrequired  (cost=0.00..4.55 rows=1 width=0) (actual rows=1 loops=1)
         Index Cond: ((equal = 42) AND (inequal = ANY ('{1,2}'::integer[])) AND (nonrequired = 17))
         Buffers: shared hit=5
(7 rows)

-- (March 15) This is like the original, but uses a cursor
--
-- Test case expanded upon to help with simplify handling of
-- scan-changes-direction changes within code such as _bt_steppage and
-- _bt_readnextpage
set work_mem = 64;
set enable_sort = off;
begin;
declare korotkov_scroll_cursor cursor for
select equal, inequal, nonrequired
from equal_inequal_nonrequired
where
  equal = 42
  and inequal in (1, 2)
  and nonrequired = 17
order by equal, inequal, nonrequired;
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
\set old_blocks_hit :cur_blocks_hit
fetch forward 1 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |          17
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh; -- 5 index hits, matches original
 bh 
----
  5
(1 row)

fetch forward 1 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
(0 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh; -- 0 index hits (past end of matches)
 bh 
----
  0
(1 row)

fetch backward 1 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |          17
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh; -- 2 index hits
 bh 
----
  2
(1 row)

fetch backward 270 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
(0 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh; -- 2 index hits
 bh 
----
  2
(1 row)

fetch forward 1 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |          17
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh; -- 5 index hits (back to where we started)
 bh 
----
  5
(1 row)

/* korotkov_scroll_cursor */ commit;
reset work_mem;
reset enable_sort;
-- (March 15) Variant of February 25 test case, that somehow now fails on
-- current version of the patch
select equal, inequal, nonrequired
from equal_inequal_nonrequired
where
  equal = 42
  and inequal in (1, 2, 6, 7)
  and nonrequired in (7, 17);
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |           7
    42 |       2 |          17
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select equal, inequal, nonrequired
from equal_inequal_nonrequired
where
  equal = 42
  and inequal in (1, 2, 6, 7)
  and nonrequired in (7, 17);
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on equal_inequal_nonrequired  (cost=9.10..11.12 rows=1 width=12) (actual rows=2 loops=1)
   Recheck Cond: ((equal = 42) AND (inequal = ANY ('{1,2,6,7}'::integer[])) AND (nonrequired = ANY ('{7,17}'::integer[])))
   Heap Blocks: exact=2
   Buffers: shared hit=9
   ->  Bitmap Index Scan on plain_equal_inequal_nonrequired  (cost=0.00..9.10 rows=1 width=0) (actual rows=2 loops=1)
         Index Cond: ((equal = 42) AND (inequal = ANY ('{1,2,6,7}'::integer[])) AND (nonrequired = ANY ('{7,17}'::integer[])))
         Buffers: shared hit=7
(7 rows)

-- (March 15) This is like the original cursor, but uses the new query variant
set work_mem = 64;
set enable_sort = off;
begin;
declare korotkov_scroll_cursor cursor for
select equal, inequal, nonrequired
from equal_inequal_nonrequired
where
  equal = 42
  and inequal in (1, 2, 6, 7)
  and nonrequired in (7, 17)
order by equal, inequal, nonrequired;
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
\set old_blocks_hit :cur_blocks_hit
fetch forward 1 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |           7
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

fetch forward 1 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |          17
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

fetch backward 1 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |           7
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  1
(1 row)

fetch backward 270 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
(0 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  2
(1 row)

fetch forward 1 from korotkov_scroll_cursor;
 equal | inequal | nonrequired 
-------+---------+-------------
    42 |       2 |           7
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('plain_equal_inequal_nonrequired'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  3
(1 row)

/* korotkov_scroll_cursor */ commit;
reset work_mem;
reset enable_sort;
--------------------------
-- keys_ahead test case --
--------------------------
--
-- (February 25)
--
-- This test case is concerned with not failing to cut our losses on the very
-- next page when we gamble and assume that -inf truncated attributes suggest
-- matches on the very next page.
--
-- When we get to the very next page and see that we guessed wrong, we must
-- cut our losses at that point -- we mustn't vainly plow on through other
-- leaf pages that come after that one.
set client_min_messages=error;
drop table if exists keys_ahead;
reset client_min_messages;
create unlogged table keys_ahead(a int4, b int4);
-- "Fillfactor 50" to make sure we get a truncated high key "(a, b)=(2)"
create index keys_ahead_idx on keys_ahead (a, b) with (fillfactor=50);
insert into keys_ahead
select i, j
  from generate_series(1, 2) i, generate_series(1, 2000) j
-- "order by hashint4(j)" to make sure we get a truncated high key "(a, b)=(2)"
order by hashint4(j);
vacuum analyze keys_ahead;
-- Now index looks like this:
/*
pg@regression:5432 [665720]=# :leafkeyspace
┌────┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬──────────────────┐
│ i  │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │     highkey      │
├────┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼──────────────────┤
│  1 │     1 │     1 │    261 │     18 │          0 │   262 │     0 │                 0 │      16 │     2,908 │ (a, b)=(1, 262)  │
│  2 │    11 │     1 │    270 │     18 │          0 │   271 │     0 │                 0 │      16 │     2,728 │ (a, b)=(1, 532)  │
│  3 │     6 │     1 │    237 │     18 │          0 │   238 │     0 │                 0 │      16 │     3,388 │ (a, b)=(1, 769)  │
│  4 │    16 │     1 │    252 │     18 │          0 │   253 │     0 │                 0 │      16 │     3,088 │ (a, b)=(1, 1021) │
│  5 │     4 │     1 │    251 │     18 │          0 │   252 │     0 │                 0 │      16 │     3,108 │ (a, b)=(1, 1272) │
│  6 │    14 │     1 │    242 │     18 │          0 │   243 │     0 │                 0 │      16 │     3,288 │ (a, b)=(1, 1514) │
│  7 │     8 │     1 │    245 │     18 │          0 │   246 │     0 │                 0 │      16 │     3,228 │ (a, b)=(1, 1759) │
│  8 │    13 │     1 │    242 │     18 │          0 │   243 │     0 │                 0 │      16 │     3,288 │ (a, b)=(2)       │  <--- shouldn't skip here (gamble instead)
│  9 │     2 │     1 │    261 │     18 │          0 │   262 │     0 │                 0 │      16 │     2,908 │ (a, b)=(2, 262)  │  <--- But we should be cutting our losses here...
│ 10 │    10 │     1 │    270 │     18 │          0 │   271 │     0 │                 0 │      16 │     2,728 │ (a, b)=(2, 532)  │
│ 11 │     7 │     1 │    237 │     18 │          0 │   238 │     0 │                 0 │      16 │     3,388 │ (a, b)=(2, 769)  │
│ 12 │    17 │     1 │    251 │     18 │          0 │   252 │     0 │                 0 │      16 │     3,108 │ (a, b)=(2, 1020) │
│ 13 │     5 │     1 │    251 │     18 │          0 │   252 │     0 │                 0 │      16 │     3,108 │ (a, b)=(2, 1271) │
│ 14 │    15 │     1 │    238 │     18 │          0 │   239 │     0 │                 0 │      16 │     3,368 │ (a, b)=(2, 1509) │
│ 15 │     9 │     1 │    243 │     18 │          0 │   244 │     0 │                 0 │      16 │     3,268 │ (a, b)=(2, 1752) │
│ 16 │    12 │     1 │    249 │     18 │          0 │   249 │     0 │                 0 │      16 │     3,168 │ ∅                │  <--- ...and then skipping to here without scanning all those other pages
└────┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴──────────────────┘
(16 rows)
*/
-- This is :rootitems, just to avoid test regressions:
select itemoffset, ctid, itemlen, nulls from bt_page_items('keys_ahead_idx',
  (select fastroot::int4 from bt_metap('keys_ahead_idx')));
 itemoffset |  ctid  | itemlen | nulls 
------------+--------+---------+-------
          1 | (1,0)  |       8 | f
          2 | (11,2) |      16 | f
          3 | (6,2)  |      16 | f
          4 | (16,2) |      16 | f
          5 | (4,2)  |      16 | f
          6 | (14,2) |      16 | f
          7 | (8,2)  |      16 | f
          8 | (13,2) |      16 | f
          9 | (2,1)  |      16 | f
         10 | (10,2) |      16 | f
         11 | (7,2)  |      16 | f
         12 | (17,2) |      16 | f
         13 | (5,2)  |      16 | f
         14 | (15,2) |      16 | f
         15 | (9,2)  |      16 | f
         16 | (12,2) |      16 | f
(16 rows)

-- 5 index hits because we descend once (root), access leaf page (13), gamble and waste
-- an access (2) but notice and redescend (root again), then finally touch
-- rightmost leaf page (12)
select *
  from keys_ahead
where
  a in (1, 2)
  and b = 1999;
 a |  b   
---+------
 2 | 1999
 1 | 1999
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 5 index hits
select *
  from keys_ahead
where
  a in (1, 2)
  and b = 1999;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.58..7.94 rows=2 width=8) (actual rows=2 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = 1999))
   Heap Blocks: exact=1
   Buffers: shared hit=6
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.58 rows=2 width=0) (actual rows=2 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = 1999))
         Buffers: shared hit=5
(7 rows)

-- Same again, but now it's lower matching b value of 1990:
-- (Somewhat surprisingly, this variant independently remained broken after
-- the original was fixed)
select *
  from keys_ahead
where
  a in (1, 2)
  and b = 1990;
 a |  b   
---+------
 2 | 1990
 1 | 1990
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 5 index hits
select *
  from keys_ahead
where
  a in (1, 2)
  and b = 1990;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.58..7.94 rows=2 width=8) (actual rows=2 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = 1990))
   Heap Blocks: exact=1
   Buffers: shared hit=6
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.58 rows=2 width=0) (actual rows=2 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = 1990))
         Buffers: shared hit=5
(7 rows)

-- Same again, but now it's final matching b value of 2000:
select *
  from keys_ahead
where
  a in (1, 2)
  and b = 2000;
 a |  b   
---+------
 2 | 2000
 1 | 2000
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 5 index hits
select *
  from keys_ahead
where
  a in (1, 2)
  and b = 2000;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.58..7.94 rows=2 width=8) (actual rows=2 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = 2000))
   Heap Blocks: exact=1
   Buffers: shared hit=6
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.58 rows=2 width=0) (actual rows=2 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = 2000))
         Buffers: shared hit=5
(7 rows)

-- Same again, but now it's non-matching b value of 2001:
select *
  from keys_ahead
where
  a in (1, 2)
  and b = 2001;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 5 index hits
select *
  from keys_ahead
where
  a in (1, 2)
  and b = 2001;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.58..7.94 rows=2 width=8) (actual rows=0 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = 2001))
   Buffers: shared hit=5
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.58 rows=2 width=0) (actual rows=0 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b = 2001))
         Buffers: shared hit=5
(6 rows)

-- Same again, but > instead of = on truncated "b" attribute:
select *
  from keys_ahead
where
  a in (1, 2)
  and b > 1999;
 a |  b   
---+------
 2 | 2000
 1 | 2000
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
  from keys_ahead
where
  a in (1, 2)
  and b > 1999;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.58..7.94 rows=2 width=8) (actual rows=2 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b > 1999))
   Heap Blocks: exact=1
   Buffers: shared hit=6
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.58 rows=2 width=0) (actual rows=2 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b > 1999))
         Buffers: shared hit=5
(7 rows)

-- Same again, but >= instead of = on truncated "b" attribute:
select *
  from keys_ahead
where
  a in (1, 2)
  and b >= 1999;
 a |  b   
---+------
 2 | 1999
 1 | 1999
 2 | 2000
 1 | 2000
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
  from keys_ahead
where
  a in (1, 2)
  and b >= 1999;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.60..10.78 rows=4 width=8) (actual rows=4 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b >= 1999))
   Heap Blocks: exact=2
   Buffers: shared hit=7
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.60 rows=4 width=0) (actual rows=4 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b >= 1999))
         Buffers: shared hit=5
(7 rows)

-- Same again, but > instead of = on truncated "b" attribute (sort of):
select *
  from keys_ahead
where
  a in (1, 2)
  and b > 1990 and b < 1999;
 a |  b   
---+------
 2 | 1994
 1 | 1994
 2 | 1998
 1 | 1998
 2 | 1995
 1 | 1995
 1 | 1997
 2 | 1997
 1 | 1992
 2 | 1992
 1 | 1993
 2 | 1993
 2 | 1996
 1 | 1996
 2 | 1991
 1 | 1991
(16 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
  from keys_ahead
where
  a in (1, 2)
  and b > 1990 and b < 1999;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.76..19.25 rows=16 width=8) (actual rows=16 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b > 1990) AND (b < 1999))
   Heap Blocks: exact=6
   Buffers: shared hit=11
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.76 rows=16 width=0) (actual rows=16 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b > 1990) AND (b < 1999))
         Buffers: shared hit=5
(7 rows)

-- Same again, but < uses value higher than any real value:
select *
  from keys_ahead
where
  a in (1, 2)
  and b > 1990 and b < 2005;
 a |  b   
---+------
 2 | 1994
 1 | 1994
 2 | 1998
 1 | 1998
 2 | 1995
 1 | 1995
 2 | 1999
 1 | 1999
 1 | 1997
 2 | 1997
 2 | 2000
 1 | 2000
 1 | 1992
 2 | 1992
 1 | 1993
 2 | 1993
 2 | 1996
 1 | 1996
 2 | 1991
 1 | 1991
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
  from keys_ahead
where
  a in (1, 2)
  and b > 1990 and b < 2005;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.81..20.12 rows=20 width=8) (actual rows=20 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b > 1990) AND (b < 2005))
   Heap Blocks: exact=6
   Buffers: shared hit=11
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.81 rows=20 width=0) (actual rows=20 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b > 1990) AND (b < 2005))
         Buffers: shared hit=5
(7 rows)

-- Same again, but >= instead of = on truncated "b" attribute (sort of):
select *
  from keys_ahead
where
  a in (1, 2)
  and b >= 1990 and b <= 1999;
 a |  b   
---+------
 2 | 1990
 1 | 1990
 2 | 1994
 1 | 1994
 2 | 1998
 1 | 1998
 2 | 1995
 1 | 1995
 2 | 1999
 1 | 1999
 1 | 1997
 2 | 1997
 1 | 1992
 2 | 1992
 1 | 1993
 2 | 1993
 2 | 1996
 1 | 1996
 2 | 1991
 1 | 1991
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
  from keys_ahead
where
  a in (1, 2)
  and b >= 1990 and b <= 1999;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.81..20.12 rows=20 width=8) (actual rows=20 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b >= 1990) AND (b <= 1999))
   Heap Blocks: exact=7
   Buffers: shared hit=12
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.81 rows=20 width=0) (actual rows=20 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b >= 1990) AND (b <= 1999))
         Buffers: shared hit=5
(7 rows)

-- Same again, but <= uses value higher than any real value:
select *
  from keys_ahead
where
  a in (1, 2)
  and b >= 1990 and b <= 2005;
 a |  b   
---+------
 2 | 1990
 1 | 1990
 2 | 1994
 1 | 1994
 2 | 1998
 1 | 1998
 2 | 1995
 1 | 1995
 2 | 1999
 1 | 1999
 1 | 1997
 2 | 1997
 2 | 2000
 1 | 2000
 1 | 1992
 2 | 1992
 1 | 1993
 2 | 1993
 2 | 1996
 1 | 1996
 2 | 1991
 1 | 1991
(22 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
  from keys_ahead
where
  a in (1, 2)
  and b >= 1990 and b <= 2005;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on keys_ahead  (cost=4.84..20.88 rows=22 width=8) (actual rows=22 loops=1)
   Recheck Cond: ((a = ANY ('{1,2}'::integer[])) AND (b >= 1990) AND (b <= 2005))
   Heap Blocks: exact=7
   Buffers: shared hit=12
   ->  Bitmap Index Scan on keys_ahead_idx  (cost=0.00..4.83 rows=22 width=0) (actual rows=22 loops=1)
         Index Cond: ((a = ANY ('{1,2}'::integer[])) AND (b >= 1990) AND (b <= 2005))
         Buffers: shared hit=5
(7 rows)

-------------------------------------------------------------------------------------------------------
-- Don't be too conservative about disabling optimization with low order column lacking SK_BT_REQFWD --
-------------------------------------------------------------------------------------------------------
set client_min_messages=error;
drop table if exists dont_be_too_conservative;
reset client_min_messages;
create unlogged table dont_be_too_conservative(
  a int,
  b int,
  c int
);
create index dont_be_too_conservative_idx on dont_be_too_conservative(a, b, c);
insert into dont_be_too_conservative select i, i, i from generate_series(1,500) i;
vacuum analyze dont_be_too_conservative;
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Here the column c is in search type scan key, but isn't a SK_BT_REQFWD
-- column:
select * from dont_be_too_conservative where a in (2,3,4,5,6,7,8) and c = 7;
 a | b | c 
---+---+---
 7 | 7 | 7
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from dont_be_too_conservative where a in (2,3,4,5,6,7,8) and c = 7; -- just 2 buffer hits
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on dont_be_too_conservative  (cost=4.63..6.65 rows=1 width=12) (actual rows=1 loops=1)
   Recheck Cond: ((a = ANY ('{2,3,4,5,6,7,8}'::integer[])) AND (c = 7))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on dont_be_too_conservative_idx  (cost=0.00..4.62 rows=1 width=0) (actual rows=1 loops=1)
         Index Cond: ((a = ANY ('{2,3,4,5,6,7,8}'::integer[])) AND (c = 7))
         Buffers: shared hit=2
(7 rows)

----------------------------------------------
-- Don't get confused by NULLs FIRST column --
----------------------------------------------
set client_min_messages=error;
drop table if exists nulls_first;
reset client_min_messages;
create unlogged table nulls_first(
  district int4,
  warehouse int4,
  orderid int4,
  anotherorderid int4,
  orderline int4
);
create index nulls_first_idx on nulls_first(district, warehouse, orderid nulls first, anotherorderid, orderline);
insert into nulls_first
select district, warehouse, NULL, orderid, orderline
from
  generate_series(1, 3) district,
  generate_series(1, 5) warehouse,
  generate_series(1, 15) orderid,
  generate_series(1, 10) orderline
order by
district, warehouse, orderid, orderline;
-- prewarm
select count(*) from nulls_first;
 count 
-------
  2250
(1 row)

vacuum analyze nulls_first;
-- looks like this now:
--
-- ┌────┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬────────────────────────────────────────────────────────────────────────────┐
-- │ i  │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │                                  highkey                                   │
-- ├────┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼────────────────────────────────────────────────────────────────────────────┤
-- │  1 │     1 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      32 │       912 │ (district, warehouse, orderid, anotherorderid, orderline)=(1, 2, null, 6)  │
-- │  2 │     2 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      32 │       912 │ (district, warehouse, orderid, anotherorderid, orderline)=(1, 3, null, 11) │
-- │  3 │     4 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      31 │       928 │ (district, warehouse, orderid, anotherorderid, orderline)=(1, 5)           │
-- │  4 │     5 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      32 │       912 │ (district, warehouse, orderid, anotherorderid, orderline)=(2, 1, null, 6)  │
-- │  5 │     6 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      32 │       912 │ (district, warehouse, orderid, anotherorderid, orderline)=(2, 2, null, 11) │
-- │  6 │     7 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      31 │       928 │ (district, warehouse, orderid, anotherorderid, orderline)=(2, 4)           │
-- │  7 │     8 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      32 │       912 │ (district, warehouse, orderid, anotherorderid, orderline)=(2, 5, null, 6)  │
-- │  8 │     9 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      32 │       912 │ (district, warehouse, orderid, anotherorderid, orderline)=(3, 1, null, 11) │
-- │  9 │    10 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      31 │       928 │ (district, warehouse, orderid, anotherorderid, orderline)=(3, 3)           │
-- │ 10 │    11 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      32 │       912 │ (district, warehouse, orderid, anotherorderid, orderline)=(3, 4, null, 6)  │
-- │ 11 │    12 │     1 │    200 │      2 │          0 │   201 │     0 │                 0 │      32 │       912 │ (district, warehouse, orderid, anotherorderid, orderline)=(3, 5, null, 11) │
-- │ 12 │    13 │     1 │     50 │      2 │          0 │    50 │     0 │                 0 │      32 │     6,348 │ ∅                                                                          │
-- └────┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴────────────────────────────────────────────────────────────────────────────┘
--
-----------------------------------------------------------------------
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
select ctid, * from nulls_first
where
  district = 1
  and warehouse = 3
  and orderid is null
  and anotherorderid in (9, 10)
  and orderline in (8, 9, 10, 11);
  ctid  | district | warehouse | orderid | anotherorderid | orderline 
--------+----------+-----------+---------+----------------+-----------
 (2,18) |        1 |         3 |         |              9 |         8
 (2,19) |        1 |         3 |         |              9 |         9
 (2,20) |        1 |         3 |         |              9 |        10
 (2,28) |        1 |         3 |         |             10 |         8
 (2,29) |        1 |         3 |         |             10 |         9
 (2,30) |        1 |         3 |         |             10 |        10
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from nulls_first
where
  district = 1
  and warehouse = 3
  and orderid is null
  and anotherorderid in (9, 10)
  and orderline in (8, 9, 10, 11);
                                                                                    QUERY PLAN                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=11.49..18.52 rows=6 width=26) (actual rows=6 loops=1)
   Recheck Cond: ((district = 1) AND (warehouse = 3) AND (orderid IS NULL) AND (anotherorderid = ANY ('{9,10}'::integer[])) AND (orderline = ANY ('{8,9,10,11}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..11.49 rows=6 width=0) (actual rows=6 loops=1)
         Index Cond: ((district = 1) AND (warehouse = 3) AND (orderid IS NULL) AND (anotherorderid = ANY ('{9,10}'::integer[])) AND (orderline = ANY ('{8,9,10,11}'::integer[])))
         Buffers: shared hit=2
(7 rows)

-- Now try IS NOT NULL variant:
select ctid, * from nulls_first
where
  district = 1
  and warehouse = 3
  and orderid is not null
  and anotherorderid in (9, 10)
  and orderline in (8, 9, 10, 11);
 ctid | district | warehouse | orderid | anotherorderid | orderline 
------+----------+-----------+---------+----------------+-----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from nulls_first
where
  district = 1
  and warehouse = 3
  and orderid is not null
  and anotherorderid in (9, 10)
  and orderline in (8, 9, 10, 11);
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=2.30..4.32 rows=1 width=26) (actual rows=0 loops=1)
   Recheck Cond: ((district = 1) AND (warehouse = 3) AND (orderid IS NOT NULL) AND (anotherorderid = ANY ('{9,10}'::integer[])) AND (orderline = ANY ('{8,9,10,11}'::integer[])))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..2.30 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((district = 1) AND (warehouse = 3) AND (orderid IS NOT NULL) AND (anotherorderid = ANY ('{9,10}'::integer[])) AND (orderline = ANY ('{8,9,10,11}'::integer[])))
         Buffers: shared hit=2
(6 rows)

select ctid, * from nulls_first where district = 1 and warehouse = 5 and orderid is null and anotherorderid in (11,12) and orderline in (8, 9, 10, 11);
  ctid   | district | warehouse | orderid | anotherorderid | orderline 
---------+----------+-----------+---------+----------------+-----------
 (3,153) |        1 |         5 |         |             11 |         8
 (3,154) |        1 |         5 |         |             11 |         9
 (3,155) |        1 |         5 |         |             11 |        10
 (3,163) |        1 |         5 |         |             12 |         8
 (3,164) |        1 |         5 |         |             12 |         9
 (3,165) |        1 |         5 |         |             12 |        10
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from nulls_first where district = 1 and warehouse = 5 and orderid is null and anotherorderid in (11,12) and orderline in (8, 9, 10, 11);
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=11.49..18.52 rows=6 width=26) (actual rows=6 loops=1)
   Recheck Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NULL) AND (anotherorderid = ANY ('{11,12}'::integer[])) AND (orderline = ANY ('{8,9,10,11}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..11.49 rows=6 width=0) (actual rows=6 loops=1)
         Index Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NULL) AND (anotherorderid = ANY ('{11,12}'::integer[])) AND (orderline = ANY ('{8,9,10,11}'::integer[])))
         Buffers: shared hit=2
(7 rows)

select ctid, * from nulls_first where district = 1 and warehouse = 5 and orderid is not null and anotherorderid in (11,12) and orderline in (8, 9, 10, 11);
 ctid | district | warehouse | orderid | anotherorderid | orderline 
------+----------+-----------+---------+----------------+-----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from nulls_first where district = 1 and warehouse = 5 and orderid is not null and anotherorderid in (11,12) and orderline in (8, 9, 10, 11);
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=2.30..4.32 rows=1 width=26) (actual rows=0 loops=1)
   Recheck Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NOT NULL) AND (anotherorderid = ANY ('{11,12}'::integer[])) AND (orderline = ANY ('{8,9,10,11}'::integer[])))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..2.30 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NOT NULL) AND (anotherorderid = ANY ('{11,12}'::integer[])) AND (orderline = ANY ('{8,9,10,11}'::integer[])))
         Buffers: shared hit=2
(6 rows)

-- RowCompare variant -- detects unsafe mixing of RowCompareExpr clauses with
-- ScalarArrayOpExr caluses
--
-- We want to exercise plans with a combination of RowCompareExpr and ScalarArrayOpExr.
select ctid, * from nulls_first where (district, warehouse) >= (3,3) and orderid is null and anotherorderid = any ('{1,2}');
   ctid   | district | warehouse | orderid | anotherorderid | orderline 
----------+----------+-----------+---------+----------------+-----------
 (9,136)  |        3 |         3 |         |              1 |         1
 (9,137)  |        3 |         3 |         |              1 |         2
 (9,138)  |        3 |         3 |         |              1 |         3
 (9,139)  |        3 |         3 |         |              1 |         4
 (9,140)  |        3 |         3 |         |              1 |         5
 (9,141)  |        3 |         3 |         |              1 |         6
 (9,142)  |        3 |         3 |         |              1 |         7
 (9,143)  |        3 |         3 |         |              1 |         8
 (9,144)  |        3 |         3 |         |              1 |         9
 (9,145)  |        3 |         3 |         |              1 |        10
 (9,146)  |        3 |         3 |         |              2 |         1
 (9,147)  |        3 |         3 |         |              2 |         2
 (9,148)  |        3 |         3 |         |              2 |         3
 (9,149)  |        3 |         3 |         |              2 |         4
 (9,150)  |        3 |         3 |         |              2 |         5
 (9,151)  |        3 |         3 |         |              2 |         6
 (9,152)  |        3 |         3 |         |              2 |         7
 (9,153)  |        3 |         3 |         |              2 |         8
 (9,154)  |        3 |         3 |         |              2 |         9
 (9,155)  |        3 |         3 |         |              2 |        10
 (10,101) |        3 |         4 |         |              1 |         1
 (10,102) |        3 |         4 |         |              1 |         2
 (10,103) |        3 |         4 |         |              1 |         3
 (10,104) |        3 |         4 |         |              1 |         4
 (10,105) |        3 |         4 |         |              1 |         5
 (10,106) |        3 |         4 |         |              1 |         6
 (10,107) |        3 |         4 |         |              1 |         7
 (10,108) |        3 |         4 |         |              1 |         8
 (10,109) |        3 |         4 |         |              1 |         9
 (10,110) |        3 |         4 |         |              1 |        10
 (10,111) |        3 |         4 |         |              2 |         1
 (10,112) |        3 |         4 |         |              2 |         2
 (10,113) |        3 |         4 |         |              2 |         3
 (10,114) |        3 |         4 |         |              2 |         4
 (10,115) |        3 |         4 |         |              2 |         5
 (10,116) |        3 |         4 |         |              2 |         6
 (10,117) |        3 |         4 |         |              2 |         7
 (10,118) |        3 |         4 |         |              2 |         8
 (10,119) |        3 |         4 |         |              2 |         9
 (10,120) |        3 |         4 |         |              2 |        10
 (11,66)  |        3 |         5 |         |              1 |         1
 (11,67)  |        3 |         5 |         |              1 |         2
 (11,68)  |        3 |         5 |         |              1 |         3
 (11,69)  |        3 |         5 |         |              1 |         4
 (11,70)  |        3 |         5 |         |              1 |         5
 (11,71)  |        3 |         5 |         |              1 |         6
 (11,72)  |        3 |         5 |         |              1 |         7
 (11,73)  |        3 |         5 |         |              1 |         8
 (11,74)  |        3 |         5 |         |              1 |         9
 (11,75)  |        3 |         5 |         |              1 |        10
 (11,76)  |        3 |         5 |         |              2 |         1
 (11,77)  |        3 |         5 |         |              2 |         2
 (11,78)  |        3 |         5 |         |              2 |         3
 (11,79)  |        3 |         5 |         |              2 |         4
 (11,80)  |        3 |         5 |         |              2 |         5
 (11,81)  |        3 |         5 |         |              2 |         6
 (11,82)  |        3 |         5 |         |              2 |         7
 (11,83)  |        3 |         5 |         |              2 |         8
 (11,84)  |        3 |         5 |         |              2 |         9
 (11,85)  |        3 |         5 |         |              2 |        10
(60 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from nulls_first where (district, warehouse) >= (3,3) and orderid is null and anotherorderid = any ('{1,2}');
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=19.68..34.43 rows=100 width=26) (actual rows=60 loops=1)
   Recheck Cond: ((ROW(district, warehouse) >= ROW(3, 3)) AND (orderid IS NULL) AND (anotherorderid = ANY ('{1,2}'::integer[])))
   Heap Blocks: exact=3
   Buffers: shared hit=7
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..19.66 rows=100 width=0) (actual rows=60 loops=1)
         Index Cond: ((ROW(district, warehouse) >= ROW(3, 3)) AND (orderid IS NULL) AND (anotherorderid = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=4
(7 rows)

-- The same row constructor syntax works automatically (this doesn't even appear
-- as a RowCompare clause in the optimizer):
select ctid, * from nulls_first where (district, warehouse) = (3,3) and orderid is null and anotherorderid =  any ('{1,2}');
  ctid   | district | warehouse | orderid | anotherorderid | orderline 
---------+----------+-----------+---------+----------------+-----------
 (9,136) |        3 |         3 |         |              1 |         1
 (9,137) |        3 |         3 |         |              1 |         2
 (9,138) |        3 |         3 |         |              1 |         3
 (9,139) |        3 |         3 |         |              1 |         4
 (9,140) |        3 |         3 |         |              1 |         5
 (9,141) |        3 |         3 |         |              1 |         6
 (9,142) |        3 |         3 |         |              1 |         7
 (9,143) |        3 |         3 |         |              1 |         8
 (9,144) |        3 |         3 |         |              1 |         9
 (9,145) |        3 |         3 |         |              1 |        10
 (9,146) |        3 |         3 |         |              2 |         1
 (9,147) |        3 |         3 |         |              2 |         2
 (9,148) |        3 |         3 |         |              2 |         3
 (9,149) |        3 |         3 |         |              2 |         4
 (9,150) |        3 |         3 |         |              2 |         5
 (9,151) |        3 |         3 |         |              2 |         6
 (9,152) |        3 |         3 |         |              2 |         7
 (9,153) |        3 |         3 |         |              2 |         8
 (9,154) |        3 |         3 |         |              2 |         9
 (9,155) |        3 |         3 |         |              2 |        10
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, * from nulls_first where (district, warehouse) = (3,3) and orderid is null and anotherorderid =  any ('{1,2}');
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=4.86..17.69 rows=20 width=26) (actual rows=20 loops=1)
   Recheck Cond: ((district = 3) AND (warehouse = 3) AND (orderid IS NULL) AND (anotherorderid = ANY ('{1,2}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..4.86 rows=20 width=0) (actual rows=20 loops=1)
         Index Cond: ((district = 3) AND (warehouse = 3) AND (orderid IS NULL) AND (anotherorderid = ANY ('{1,2}'::integer[])))
         Buffers: shared hit=2
(7 rows)

-- (September 8) Here we show a distilled case that demonstrates the need for
-- an opclass support function 1 (ORDER function) for every column that's
-- BTEqualStrategyNumber -- not just those that are SK_SEARCHARRAY array keys.
-- Recall that this was surprisingly unlikely to break queries.
--
-- If you remove the required comparator and just skip over relevant scan
-- keys when checking if a tuple needs to advance the array keys, you'll find
-- that this query apparently works as expected:
--
-- (November 22) UPDATE:
-- XXX Not really true anymore, as of recent versions of the patch (those
-- after v7) which can get by using _bt_check_compare/the = operator most of
-- the time -- just not all the time.  (This is an indirect consequence of
-- having more worked out handling of required inequality scan keys.)
select ctid, *
from nulls_first
where district = 1
  and warehouse = 5
  and orderid is null
  and anotherorderid = any ('{6}')
  and orderline = any ('{-5,500}');
 ctid | district | warehouse | orderid | anotherorderid | orderline 
------+----------+-----------+---------+----------------+-----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, *
from nulls_first
where district = 1
  and warehouse = 5
  and orderid is null
  and anotherorderid = any ('{6}')
  and orderline = any ('{-5,500}');
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=4.60..6.61 rows=1 width=26) (actual rows=0 loops=1)
   Recheck Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NULL) AND (anotherorderid = ANY ('{6}'::integer[])) AND (orderline = ANY ('{-5,500}'::integer[])))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..4.59 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NULL) AND (anotherorderid = ANY ('{6}'::integer[])) AND (orderline = ANY ('{-5,500}'::integer[])))
         Buffers: shared hit=2
(6 rows)

-- OTOH this very similar query fails:
select ctid, *
from nulls_first
where district = 1
  and warehouse = 5
  and orderid is null
  and anotherorderid = any ('{7}')
  and orderline = any ('{-5,500}');
 ctid | district | warehouse | orderid | anotherorderid | orderline 
------+----------+-----------+---------+----------------+-----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, *
from nulls_first
where district = 1
  and warehouse = 5
  and orderid is null
  and anotherorderid = any ('{7}')
  and orderline = any ('{-5,500}');
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=4.60..6.61 rows=1 width=26) (actual rows=0 loops=1)
   Recheck Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NULL) AND (anotherorderid = ANY ('{7}'::integer[])) AND (orderline = ANY ('{-5,500}'::integer[])))
   Buffers: shared hit=2
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..4.59 rows=1 width=0) (actual rows=0 loops=1)
         Index Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NULL) AND (anotherorderid = ANY ('{7}'::integer[])) AND (orderline = ANY ('{-5,500}'::integer[])))
         Buffers: shared hit=2
(6 rows)

-- The actual reason why the first query "succeeds" is that the page high key
-- for the relevant leaf page (block 5) looks like this:
--
-- (district, warehouse, orderid, anotherorderid, orderline)=(2, 1, null, 6)
--
-- So the only reason why the first variant would "succeed" was because
-- an "anotherorderid" of 6 made the high key seem to be within the bounds of
-- the array keys for the first query, but not the second query.  The second
-- query would repeat its access to page 5 because the state machine had the
-- wrong idea about our progress in the key space.
--
-- An additional complicating factor here is the interaction with suffix
-- truncation.  This variant of the failing query lacks "orderline = any
-- ('{-5,500}')", but is otherwise identical -- and so it always worked as
-- expected, even with the bug present:
select ctid, *
from nulls_first
where district = 1
  and warehouse = 5
  and orderid is null
  and anotherorderid = any ('{7}');
  ctid   | district | warehouse | orderid | anotherorderid | orderline 
---------+----------+-----------+---------+----------------+-----------
 (3,106) |        1 |         5 |         |              7 |         1
 (3,107) |        1 |         5 |         |              7 |         2
 (3,108) |        1 |         5 |         |              7 |         3
 (3,109) |        1 |         5 |         |              7 |         4
 (3,110) |        1 |         5 |         |              7 |         5
 (3,111) |        1 |         5 |         |              7 |         6
 (3,112) |        1 |         5 |         |              7 |         7
 (3,113) |        1 |         5 |         |              7 |         8
 (3,114) |        1 |         5 |         |              7 |         9
 (3,115) |        1 |         5 |         |              7 |        10
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select ctid, *
from nulls_first
where district = 1
  and warehouse = 5
  and orderid is null
  and anotherorderid = any ('{7}');
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on nulls_first  (cost=2.43..12.32 rows=10 width=26) (actual rows=10 loops=1)
   Recheck Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NULL) AND (anotherorderid = ANY ('{7}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on nulls_first_idx  (cost=0.00..2.43 rows=10 width=0) (actual rows=10 loops=1)
         Index Cond: ((district = 1) AND (warehouse = 5) AND (orderid IS NULL) AND (anotherorderid = ANY ('{7}'::integer[])))
         Buffers: shared hit=2
(7 rows)

--------------------------------------------------
-- Mark/restore ScalarArrayOpExr coverage tests --
--------------------------------------------------
set client_min_messages=error;
drop table if exists mark_restore_join_table1;
drop table if exists mark_restore_join_table2;
reset client_min_messages;
set enable_nestloop to 0;
set enable_hashjoin to 0;
set enable_sort to 0;
set enable_material to 0;
create unlogged table mark_restore_join_table1 (a int, b int);
create unlogged table mark_restore_join_table2 (a int, b int);
create index table1_idx on mark_restore_join_table1 (a) where a % 1000 = 1;
create index table2_idx on mark_restore_join_table2 (a) where a % 1000 = 1;
-- (July 13) Original regression tests had only 2 rows, I want more:
insert into mark_restore_join_table1 select 1, i from generate_series(1, 20) i;
insert into mark_restore_join_table2 select 1, i from generate_series(1, 20) i;
vacuum analyze mark_restore_join_table1;
vacuum analyze mark_restore_join_table2;
-- Bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Exercise array keys mark/restore B-Tree code
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, * from
  mark_restore_join_table1 j1
  inner join mark_restore_join_table2 j2 on j1.a = j2.a and j1.b = j2.b
where
  j1.a % 1000 = 1 and j2.a % 1000 = 1 and j2.a = any (array[1]);
 j1_ctid | j2_ctid | a | b  | a | b  
---------+---------+---+----+---+----
 (0,1)   | (0,1)   | 1 |  1 | 1 |  1
 (0,2)   | (0,2)   | 1 |  2 | 1 |  2
 (0,3)   | (0,3)   | 1 |  3 | 1 |  3
 (0,4)   | (0,4)   | 1 |  4 | 1 |  4
 (0,5)   | (0,5)   | 1 |  5 | 1 |  5
 (0,6)   | (0,6)   | 1 |  6 | 1 |  6
 (0,7)   | (0,7)   | 1 |  7 | 1 |  7
 (0,8)   | (0,8)   | 1 |  8 | 1 |  8
 (0,9)   | (0,9)   | 1 |  9 | 1 |  9
 (0,10)  | (0,10)  | 1 | 10 | 1 | 10
 (0,11)  | (0,11)  | 1 | 11 | 1 | 11
 (0,12)  | (0,12)  | 1 | 12 | 1 | 12
 (0,13)  | (0,13)  | 1 | 13 | 1 | 13
 (0,14)  | (0,14)  | 1 | 14 | 1 | 14
 (0,15)  | (0,15)  | 1 | 15 | 1 | 15
 (0,16)  | (0,16)  | 1 | 16 | 1 | 16
 (0,17)  | (0,17)  | 1 | 17 | 1 | 17
 (0,18)  | (0,18)  | 1 | 18 | 1 | 18
 (0,19)  | (0,19)  | 1 | 19 | 1 | 19
 (0,20)  | (0,20)  | 1 | 20 | 1 | 20
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, * from
  mark_restore_join_table1 j1
  inner join mark_restore_join_table2 j2 on j1.a = j2.a and j1.b = j2.b
where
  j1.a % 1000 = 1 and j2.a % 1000 = 1 and j2.a = any (array[1]);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=4.29..8.33 rows=1 width=28) (actual rows=20 loops=1)
   Disabled: true
   Join Filter: ((j2.a = j1.a) AND (j2.b = j1.b))
   Rows Removed by Join Filter: 380
   Buffers: shared hit=42
   ->  Bitmap Heap Scan on mark_restore_join_table1 j1  (cost=2.14..4.16 rows=1 width=14) (actual rows=20 loops=1)
         Recheck Cond: ((a % 1000) = 1)
         Heap Blocks: exact=1
         Buffers: shared hit=2
         ->  Bitmap Index Scan on table1_idx  (cost=0.00..2.14 rows=1 width=0) (actual rows=20 loops=1)
               Buffers: shared hit=1
   ->  Bitmap Heap Scan on mark_restore_join_table2 j2  (cost=2.15..4.16 rows=1 width=14) (actual rows=20 loops=20)
         Recheck Cond: ((a = ANY ('{1}'::integer[])) AND ((a % 1000) = 1))
         Heap Blocks: exact=20
         Buffers: shared hit=40
         ->  Bitmap Index Scan on table2_idx  (cost=0.00..2.15 rows=1 width=0) (actual rows=20 loops=20)
               Index Cond: (a = ANY ('{1}'::integer[]))
               Buffers: shared hit=20
(18 rows)

-- Exercise array keys "find extreme element" B-Tree code
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, * from
  mark_restore_join_table1 j1
  inner join mark_restore_join_table2 j2 on j1.a = j2.a and j1.b = j2.b
where
  j1.a % 1000 = 1 and j2.a % 1000 = 1 and j2.a >= any (array[1, 5]);
 j1_ctid | j2_ctid | a | b  | a | b  
---------+---------+---+----+---+----
 (0,1)   | (0,1)   | 1 |  1 | 1 |  1
 (0,2)   | (0,2)   | 1 |  2 | 1 |  2
 (0,3)   | (0,3)   | 1 |  3 | 1 |  3
 (0,4)   | (0,4)   | 1 |  4 | 1 |  4
 (0,5)   | (0,5)   | 1 |  5 | 1 |  5
 (0,6)   | (0,6)   | 1 |  6 | 1 |  6
 (0,7)   | (0,7)   | 1 |  7 | 1 |  7
 (0,8)   | (0,8)   | 1 |  8 | 1 |  8
 (0,9)   | (0,9)   | 1 |  9 | 1 |  9
 (0,10)  | (0,10)  | 1 | 10 | 1 | 10
 (0,11)  | (0,11)  | 1 | 11 | 1 | 11
 (0,12)  | (0,12)  | 1 | 12 | 1 | 12
 (0,13)  | (0,13)  | 1 | 13 | 1 | 13
 (0,14)  | (0,14)  | 1 | 14 | 1 | 14
 (0,15)  | (0,15)  | 1 | 15 | 1 | 15
 (0,16)  | (0,16)  | 1 | 16 | 1 | 16
 (0,17)  | (0,17)  | 1 | 17 | 1 | 17
 (0,18)  | (0,18)  | 1 | 18 | 1 | 18
 (0,19)  | (0,19)  | 1 | 19 | 1 | 19
 (0,20)  | (0,20)  | 1 | 20 | 1 | 20
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, * from
  mark_restore_join_table1 j1
  inner join mark_restore_join_table2 j2 on j1.a = j2.a and j1.b = j2.b
where
  j1.a % 1000 = 1 and j2.a % 1000 = 1 and j2.a >= any (array[1, 5]);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=4.29..8.34 rows=1 width=28) (actual rows=20 loops=1)
   Disabled: true
   Join Filter: ((j2.a = j1.a) AND (j2.b = j1.b))
   Rows Removed by Join Filter: 380
   Buffers: shared hit=42
   ->  Bitmap Heap Scan on mark_restore_join_table1 j1  (cost=2.14..4.16 rows=1 width=14) (actual rows=20 loops=1)
         Recheck Cond: ((a % 1000) = 1)
         Heap Blocks: exact=1
         Buffers: shared hit=2
         ->  Bitmap Index Scan on table1_idx  (cost=0.00..2.14 rows=1 width=0) (actual rows=20 loops=1)
               Buffers: shared hit=1
   ->  Bitmap Heap Scan on mark_restore_join_table2 j2  (cost=2.15..4.16 rows=1 width=14) (actual rows=20 loops=20)
         Recheck Cond: ((a >= ANY ('{1,5}'::integer[])) AND ((a % 1000) = 1))
         Heap Blocks: exact=20
         Buffers: shared hit=40
         ->  Bitmap Index Scan on table2_idx  (cost=0.00..2.15 rows=1 width=0) (actual rows=20 loops=20)
               Index Cond: (a >= ANY ('{1,5}'::integer[]))
               Buffers: shared hit=20
(18 rows)

-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Exercise array keys mark/restore B-Tree code
-- As above
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, * from
  mark_restore_join_table1 j1
  inner join mark_restore_join_table2 j2 on j1.a = j2.a and j1.b = j2.b
where
  j1.a % 1000 = 1 and j2.a % 1000 = 1 and j2.a = any (array[1]);
 j1_ctid | j2_ctid | a | b  | a | b  
---------+---------+---+----+---+----
 (0,1)   | (0,1)   | 1 |  1 | 1 |  1
 (0,2)   | (0,2)   | 1 |  2 | 1 |  2
 (0,3)   | (0,3)   | 1 |  3 | 1 |  3
 (0,4)   | (0,4)   | 1 |  4 | 1 |  4
 (0,5)   | (0,5)   | 1 |  5 | 1 |  5
 (0,6)   | (0,6)   | 1 |  6 | 1 |  6
 (0,7)   | (0,7)   | 1 |  7 | 1 |  7
 (0,8)   | (0,8)   | 1 |  8 | 1 |  8
 (0,9)   | (0,9)   | 1 |  9 | 1 |  9
 (0,10)  | (0,10)  | 1 | 10 | 1 | 10
 (0,11)  | (0,11)  | 1 | 11 | 1 | 11
 (0,12)  | (0,12)  | 1 | 12 | 1 | 12
 (0,13)  | (0,13)  | 1 | 13 | 1 | 13
 (0,14)  | (0,14)  | 1 | 14 | 1 | 14
 (0,15)  | (0,15)  | 1 | 15 | 1 | 15
 (0,16)  | (0,16)  | 1 | 16 | 1 | 16
 (0,17)  | (0,17)  | 1 | 17 | 1 | 17
 (0,18)  | (0,18)  | 1 | 18 | 1 | 18
 (0,19)  | (0,19)  | 1 | 19 | 1 | 19
 (0,20)  | (0,20)  | 1 | 20 | 1 | 20
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, * from
  mark_restore_join_table1 j1
  inner join mark_restore_join_table2 j2 on j1.a = j2.a and j1.b = j2.b
where
  j1.a % 1000 = 1 and j2.a % 1000 = 1 and j2.a = any (array[1]);
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.28..8.32 rows=1 width=28) (actual rows=20 loops=1)
   Merge Cond: (j1.a = j2.a)
   Join Filter: (j2.b = j1.b)
   Rows Removed by Join Filter: 380
   Buffers: shared hit=23
   ->  Index Scan using table1_idx on mark_restore_join_table1 j1  (cost=0.14..4.15 rows=1 width=14) (actual rows=20 loops=1)
         Buffers: shared hit=2
   ->  Index Scan using table2_idx on mark_restore_join_table2 j2  (cost=0.14..4.16 rows=1 width=14) (actual rows=381 loops=1)
         Index Cond: (a = ANY ('{1}'::integer[]))
         Buffers: shared hit=21
(10 rows)

-- Exercise array keys "find extreme element" B-Tree code
-- As above
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, * from
  mark_restore_join_table1 j1
  inner join mark_restore_join_table2 j2 on j1.a = j2.a and j1.b = j2.b
where
  j1.a % 1000 = 1 and j2.a % 1000 = 1 and j2.a >= any (array[1, 5]);
 j1_ctid | j2_ctid | a | b  | a | b  
---------+---------+---+----+---+----
 (0,1)   | (0,1)   | 1 |  1 | 1 |  1
 (0,2)   | (0,2)   | 1 |  2 | 1 |  2
 (0,3)   | (0,3)   | 1 |  3 | 1 |  3
 (0,4)   | (0,4)   | 1 |  4 | 1 |  4
 (0,5)   | (0,5)   | 1 |  5 | 1 |  5
 (0,6)   | (0,6)   | 1 |  6 | 1 |  6
 (0,7)   | (0,7)   | 1 |  7 | 1 |  7
 (0,8)   | (0,8)   | 1 |  8 | 1 |  8
 (0,9)   | (0,9)   | 1 |  9 | 1 |  9
 (0,10)  | (0,10)  | 1 | 10 | 1 | 10
 (0,11)  | (0,11)  | 1 | 11 | 1 | 11
 (0,12)  | (0,12)  | 1 | 12 | 1 | 12
 (0,13)  | (0,13)  | 1 | 13 | 1 | 13
 (0,14)  | (0,14)  | 1 | 14 | 1 | 14
 (0,15)  | (0,15)  | 1 | 15 | 1 | 15
 (0,16)  | (0,16)  | 1 | 16 | 1 | 16
 (0,17)  | (0,17)  | 1 | 17 | 1 | 17
 (0,18)  | (0,18)  | 1 | 18 | 1 | 18
 (0,19)  | (0,19)  | 1 | 19 | 1 | 19
 (0,20)  | (0,20)  | 1 | 20 | 1 | 20
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, * from
  mark_restore_join_table1 j1
  inner join mark_restore_join_table2 j2 on j1.a = j2.a and j1.b = j2.b
where
  j1.a % 1000 = 1 and j2.a % 1000 = 1 and j2.a >= any (array[1, 5]);
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.28..8.32 rows=1 width=28) (actual rows=20 loops=1)
   Merge Cond: (j1.a = j2.a)
   Join Filter: (j2.b = j1.b)
   Rows Removed by Join Filter: 380
   Buffers: shared hit=23
   ->  Index Scan using table1_idx on mark_restore_join_table1 j1  (cost=0.14..4.15 rows=1 width=14) (actual rows=20 loops=1)
         Buffers: shared hit=2
   ->  Index Scan using table2_idx on mark_restore_join_table2 j2  (cost=0.14..4.16 rows=1 width=14) (actual rows=381 loops=1)
         Index Cond: (a >= ANY ('{1,5}'::integer[]))
         Buffers: shared hit=21
(10 rows)

-- (September 22)
-- Test case that caused assertion failure related to not
-- having the right place in the scan for a merge join, in respect of
-- non-array equality-type scan keys.
set client_min_messages=error;
drop table if exists mark_restore_self_join;
reset client_min_messages;
create unlogged table mark_restore_self_join (a int, b int);
create index on mark_restore_self_join(a, b);
insert into mark_restore_self_join select 1, i from generate_series(1, 20) i;
vacuum analyze mark_restore_self_join;
-- Original:
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, *
from
  mark_restore_self_join j1
    inner join
  mark_restore_self_join j2 on j1.a = j2.a
where j2.a = any (array[-1, 0, 1, 2, 3]) and j2.b = 5;
 j1_ctid | j2_ctid | a | b  | a | b 
---------+---------+---+----+---+---
 (0,1)   | (0,5)   | 1 |  1 | 1 | 5
 (0,2)   | (0,5)   | 1 |  2 | 1 | 5
 (0,3)   | (0,5)   | 1 |  3 | 1 | 5
 (0,4)   | (0,5)   | 1 |  4 | 1 | 5
 (0,5)   | (0,5)   | 1 |  5 | 1 | 5
 (0,6)   | (0,5)   | 1 |  6 | 1 | 5
 (0,7)   | (0,5)   | 1 |  7 | 1 | 5
 (0,8)   | (0,5)   | 1 |  8 | 1 | 5
 (0,9)   | (0,5)   | 1 |  9 | 1 | 5
 (0,10)  | (0,5)   | 1 | 10 | 1 | 5
 (0,11)  | (0,5)   | 1 | 11 | 1 | 5
 (0,12)  | (0,5)   | 1 | 12 | 1 | 5
 (0,13)  | (0,5)   | 1 | 13 | 1 | 5
 (0,14)  | (0,5)   | 1 | 14 | 1 | 5
 (0,15)  | (0,5)   | 1 | 15 | 1 | 5
 (0,16)  | (0,5)   | 1 | 16 | 1 | 5
 (0,17)  | (0,5)   | 1 | 17 | 1 | 5
 (0,18)  | (0,5)   | 1 | 18 | 1 | 5
 (0,19)  | (0,5)   | 1 | 19 | 1 | 5
 (0,20)  | (0,5)   | 1 | 20 | 1 | 5
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, *
from
  mark_restore_self_join j1
    inner join
  mark_restore_self_join j2 on j1.a = j2.a
where j2.a = any (array[-1, 0, 1, 2, 3]) and j2.b = 5;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.28..10.85 rows=20 width=28) (actual rows=20 loops=1)
   Merge Cond: (j2.a = j1.a)
   Buffers: shared hit=4
   ->  Index Scan using mark_restore_self_join_a_b_idx on mark_restore_self_join j2  (cost=0.14..4.16 rows=1 width=14) (actual rows=1 loops=1)
         Index Cond: ((a = ANY ('{-1,0,1,2,3}'::integer[])) AND (b = 5))
         Buffers: shared hit=2
   ->  Index Scan using mark_restore_self_join_a_b_idx on mark_restore_self_join j1  (cost=0.14..6.44 rows=20 width=14) (actual rows=20 loops=1)
         Buffers: shared hit=2
(8 rows)

-- Same query, but now a nestloop join:
--
-- (March 4) This variant was buggy following merge of _bt_preprocess_keys and
-- _bt_preprocess_array_keys, though it might have been a preexisiting issue
-- (coincided with getting serious about testing nestloop joins).
--
-- XXX UPDATE: Derp, this was due to a simple lack of rigor here (should have
-- been testing both scan keys from the pair being considered):
/*
--- a/src/backend/access/nbtree/nbtutils.c
+++ b/src/backend/access/nbtree/nbtutils.c
@@ -2694,7 +2694,8 @@ _bt_preprocess_keys(IndexScanDesc scan, ScanDirection dir)
             if (j == (BTEqualStrategyNumber - 1) &&
-                (xform[j].skey->sk_flags & SK_SEARCHARRAY) &&
+                ((xform[j].skey->sk_flags & SK_SEARCHARRAY) ||
+                 (cur->sk_flags & SK_SEARCHARRAY)) &&
                 !(cur->sk_flags & SK_SEARCHNULL))
             {
*/
set enable_mergejoin to off;
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, *
from
  mark_restore_self_join j1
    inner join
  mark_restore_self_join j2 on j1.a = j2.a
where j2.a = any (array[-1, 0, 1, 2, 3]) and j2.b = 5;
 j1_ctid | j2_ctid | a | b  | a | b 
---------+---------+---+----+---+---
 (0,1)   | (0,5)   | 1 |  1 | 1 | 5
 (0,2)   | (0,5)   | 1 |  2 | 1 | 5
 (0,3)   | (0,5)   | 1 |  3 | 1 | 5
 (0,4)   | (0,5)   | 1 |  4 | 1 | 5
 (0,5)   | (0,5)   | 1 |  5 | 1 | 5
 (0,6)   | (0,5)   | 1 |  6 | 1 | 5
 (0,7)   | (0,5)   | 1 |  7 | 1 | 5
 (0,8)   | (0,5)   | 1 |  8 | 1 | 5
 (0,9)   | (0,5)   | 1 |  9 | 1 | 5
 (0,10)  | (0,5)   | 1 | 10 | 1 | 5
 (0,11)  | (0,5)   | 1 | 11 | 1 | 5
 (0,12)  | (0,5)   | 1 | 12 | 1 | 5
 (0,13)  | (0,5)   | 1 | 13 | 1 | 5
 (0,14)  | (0,5)   | 1 | 14 | 1 | 5
 (0,15)  | (0,5)   | 1 | 15 | 1 | 5
 (0,16)  | (0,5)   | 1 | 16 | 1 | 5
 (0,17)  | (0,5)   | 1 | 17 | 1 | 5
 (0,18)  | (0,5)   | 1 | 18 | 1 | 5
 (0,19)  | (0,5)   | 1 | 19 | 1 | 5
 (0,20)  | (0,5)   | 1 | 20 | 1 | 5
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select j1.ctid as j1_ctid, j2.ctid as j2_ctid, *
from
  mark_restore_self_join j1
    inner join
  mark_restore_self_join j2 on j1.a = j2.a
where j2.a = any (array[-1, 0, 1, 2, 3]) and j2.b = 5;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.29..7.83 rows=20 width=28) (actual rows=20 loops=1)
   Disabled: true
   Buffers: shared hit=4
   ->  Index Scan using mark_restore_self_join_a_b_idx on mark_restore_self_join j1  (cost=0.14..6.44 rows=20 width=14) (actual rows=20 loops=1)
         Buffers: shared hit=2
   ->  Memoize  (cost=0.15..0.47 rows=1 width=14) (actual rows=1 loops=20)
         Cache Key: j1.a
         Cache Mode: logical
         Hits: 19  Misses: 1  Evictions: 0  Overflows: 0  Memory Usage: 1kB
         Buffers: shared hit=2
         ->  Index Scan using mark_restore_self_join_a_b_idx on mark_restore_self_join j2  (cost=0.14..0.46 rows=1 width=14) (actual rows=1 loops=1)
               Index Cond: ((a = j1.a) AND (a = ANY ('{-1,0,1,2,3}'::integer[])) AND (b = 5))
               Buffers: shared hit=2
(13 rows)

set enable_mergejoin to on;
-- (September 24) Repro for mark/restore bug affecting HEAD and all back branches
-- Per https://postgr.es/m/CAH2-WzkgP3DDRJxw6DgjCxo-cu-DKrvjEv_ArkP2ctBJatDCYg@mail.gmail.com
set client_min_messages=error;
drop table if exists amber_small;
drop table if exists amber_big;
reset client_min_messages;
create unlogged table amber_small
(
  a integer,
  b integer
);
create unlogged table amber_big
(
  a integer,
  b integer
);
insert into amber_big select 1,  2 from generate_series(1,1024);
insert into amber_big select 1,  3 from generate_series(1,1024);
insert into amber_big select 1,  5 from generate_series(1,1024);
insert into amber_big select 1,  6 from generate_series(1,1024);
insert into amber_big select 1,  7 from generate_series(1,1024);
insert into amber_big select 1,  8 from generate_series(1,1024);
insert into amber_big select 1, 10 from generate_series(1,1024);
insert into amber_big select 1, 12 from generate_series(1,1024);
insert into amber_big select 1, 13 from generate_series(1,1024);
insert into amber_big select 1, 15 from generate_series(1,1024);
insert into amber_big select 1, 17 from generate_series(1,1024);
insert into amber_big select 1, 19 from generate_series(1,1024);
insert into amber_small select 1,  1 from generate_series(1,8);
insert into amber_small select 1,  2 from generate_series(1,8);
insert into amber_small select 1,  3 from generate_series(1,8);
insert into amber_small select 1,  4 from generate_series(1,8);
insert into amber_small select 1,  5 from generate_series(1,8);
insert into amber_small select 1,  9 from generate_series(1,8);
insert into amber_small select 1, 10 from generate_series(1,8);
insert into amber_small select 1, 11 from generate_series(1,8);
insert into amber_small select 1, 12 from generate_series(1,8);
insert into amber_small select 1, 14 from generate_series(1,8);
insert into amber_small select 1, 17 from generate_series(1,8);
insert into amber_small select 1, 18 from generate_series(1,8);
insert into amber_small select 1, 19 from generate_series(1,8);
create index amber_big_idx on amber_big (a, b);
create index amber_small_idx on amber_small (a, b);
vacuum analyze amber_small;
vacuum analyze amber_big;
-- Original
select count(*), small.a small_a
from
  amber_small small
    inner join
  amber_big big
    on small.a = big.a and small.b = big.b
where small.a in (1, 3) and big.a in (1, 3)
group by small_a order by small_a;
 count | small_a 
-------+---------
 57344 |       1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*), small.a small_a
from
  amber_small small
    inner join
  amber_big big
    on small.a = big.a and small.b = big.b
where small.a in (1, 3) and big.a in (1, 3)
group by small_a order by small_a;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.43..2625.42 rows=1 width=12) (actual rows=1 loops=1)
   Group Key: small.a
   Buffers: shared hit=377
   ->  Merge Join  (cost=0.43..2338.69 rows=57344 width=4) (actual rows=57344 loops=1)
         Merge Cond: ((small.a = big.a) AND (small.b = big.b))
         Buffers: shared hit=377
         ->  Index Scan using amber_small_idx on amber_small small  (cost=0.14..7.96 rows=104 width=8) (actual rows=104 loops=1)
               Index Cond: (a = ANY ('{1,3}'::integer[]))
               Buffers: shared hit=2
         ->  Index Scan using amber_big_idx on amber_big big  (cost=0.29..315.24 rows=12288 width=8) (actual rows=62457 loops=1)
               Index Cond: (a = ANY ('{1,3}'::integer[]))
               Buffers: shared hit=375
(12 rows)

-- Same again, but this time it's a nestloop join:
--
-- (March 4) This variant was buggy following merge of _bt_preprocess_keys and
-- _bt_preprocess_array_keys, though it might have been a preexisiting issue
-- (coincided with getting serious about testing nestloop joins).
--
-- XXX UPDATE: This bug was a very recent regression from
-- March 2 or March 3, directly tied to the aforementioned merging of code
-- from _bt_preprocess_keys and _bt_preprocess_array_keys.  Basically,
-- the offset in array->scan_key was confused in some way, something to do
-- with not correctly remapping from input scan key offsets to output scan key
-- offsets in the presence of redundant/contradictory scan keys.
set enable_mergejoin to off;
select count(*), small.a small_a
from
  amber_small small
    inner join
  amber_big big
    on small.a = big.a and small.b = big.b
where small.a in (1, 3) and big.a in (1, 3)
group by small_a order by small_a;
 count | small_a 
-------+---------
 57344 |       1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*), small.a small_a
from
  amber_small small
    inner join
  amber_big big
    on small.a = big.a and small.b = big.b
where small.a in (1, 3) and big.a in (1, 3)
group by small_a order by small_a;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.44..1970.36 rows=1 width=12) (actual rows=1 loops=1)
   Group Key: small.a
   Buffers: shared hit=72
   ->  Nested Loop  (cost=0.44..1683.63 rows=57344 width=4) (actual rows=57344 loops=1)
         Disabled: true
         Buffers: shared hit=72
         ->  Index Scan using amber_small_idx on amber_small small  (cost=0.14..7.96 rows=104 width=8) (actual rows=104 loops=1)
               Index Cond: (a = ANY ('{1,3}'::integer[]))
               Buffers: shared hit=2
         ->  Memoize  (cost=0.30..24.93 rows=1024 width=8) (actual rows=551 loops=104)
               Cache Key: small.a, small.b
               Cache Mode: logical
               Hits: 91  Misses: 13  Evictions: 0  Overflows: 0  Memory Usage: 281kB
               Buffers: shared hit=70
               ->  Index Scan using amber_big_idx on amber_big big  (cost=0.29..24.92 rows=1024 width=8) (actual rows=551 loops=13)
                     Index Cond: ((a = small.a) AND (a = ANY ('{1,3}'::integer[])) AND (b = small.b))
                     Buffers: shared hit=70
(17 rows)

set enable_mergejoin to on;
-- (November 29)
--
-- Reveal bug in mark/restore processing that's related to November 25 test
-- case, except it involves mark/restore rather than changing the scan
-- direction
set client_min_messages=error;
drop table if exists outer_table;
drop table if exists restore_buggy_primscan_table;
reset client_min_messages;
create unlogged table outer_table                  (a int, b int);
create unlogged table restore_buggy_primscan_table (x int, y int);
-- Disable deduplication because uniform sized tuples helped with repro
-- (leaving this on is now unnecessary but can't hurt):
create index buggy_idx on restore_buggy_primscan_table (x, y) with (deduplicate_items=off);
-- Originally I didn't even have an index on outer_table, but found that sort
-- node produced unstable output depending on whether build was debug or not:
create index avoid_sort on outer_table (a, b);
insert into outer_table                  select 1, b_vals from generate_series(1006, 1580) b_vals;
insert into restore_buggy_primscan_table select 1, x_vals from generate_series(1006, 1580) x_vals;
-- "9" is the bare minimum number of tuples that'll repro:
insert into outer_table                  select 1, 1370 from generate_series(1, 9) j;
insert into restore_buggy_primscan_table select 1, 1371 from generate_series(1, 9) j;
insert into restore_buggy_primscan_table select 1, 1380 from generate_series(1, 9) j;
vacuum analyze outer_table;
vacuum analyze restore_buggy_primscan_table;
prepare restore_buggy_primscan_qry as
select count(*), o.a, o.b
  from
    outer_table o
  inner join
    restore_buggy_primscan_table bug
  on o.a = bug.x and o.b = bug.y
where
  bug.x = 1 and
  bug.y = any(array[(select array_agg(i) from generate_series(1370, 1390) i where i % 10 = 0)])
group by o.a, o.b;
execute restore_buggy_primscan_qry;
 count | a |  b   
-------+---+------
    10 | 1 | 1370
    10 | 1 | 1380
     1 | 1 | 1390
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute restore_buggy_primscan_qry;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.88..33.94 rows=10 width=16) (actual rows=3 loops=1)
   Group Key: o.b
   Buffers: shared hit=32
   InitPlan 1
     ->  Aggregate  (cost=0.32..0.33 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..0.32 rows=1 width=4) (actual rows=3 loops=1)
                 Filter: ((i % 10) = 0)
                 Rows Removed by Filter: 18
   ->  Merge Join  (cost=0.55..33.45 rows=10 width=8) (actual rows=21 loops=1)
         Merge Cond: (o.b = bug.y)
         Buffers: shared hit=32
         ->  Index Scan using avoid_sort on outer_table o  (cost=0.28..23.37 rows=584 width=8) (actual rows=395 loops=1)
               Index Cond: (a = 1)
               Buffers: shared hit=7
         ->  Index Scan using buggy_idx on restore_buggy_primscan_table bug  (cost=0.28..8.50 rows=10 width=8) (actual rows=21 loops=1)
               Index Cond: ((x = 1) AND (y = ANY (ARRAY[(InitPlan 1).col1])))
               Buffers: shared hit=25
(17 rows)

deallocate restore_buggy_primscan_qry;
-- (Jun 6 2024)
--
-- Same again, but using skip scan this time.
prepare skip_restore_buggy_primscan_qry as
select count(*), o.a, o.b
  from
    outer_table o
  inner join
    restore_buggy_primscan_table bug
  on o.a = bug.x and o.b = bug.y
where
  bug.y = any(array[(select array_agg(i) from generate_series(1370, 1390) i where i % 10 = 0)])
group by o.a, o.b;
execute skip_restore_buggy_primscan_qry;
 count | a |  b   
-------+---+------
    10 | 1 | 1370
    10 | 1 | 1380
     1 | 1 | 1390
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute skip_restore_buggy_primscan_qry;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.88..42.06 rows=10 width=16) (actual rows=3 loops=1)
   Group Key: o.a, o.b
   Buffers: shared hit=31
   InitPlan 1
     ->  Aggregate  (cost=0.32..0.33 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..0.32 rows=1 width=4) (actual rows=3 loops=1)
                 Filter: ((i % 10) = 0)
                 Rows Removed by Filter: 18
   ->  Merge Join  (cost=0.55..41.55 rows=10 width=8) (actual rows=21 loops=1)
         Merge Cond: ((o.a = bug.x) AND (o.b = bug.y))
         Buffers: shared hit=31
         ->  Index Scan using avoid_sort on outer_table o  (cost=0.28..21.91 rows=584 width=8) (actual rows=395 loops=1)
               Buffers: shared hit=7
         ->  Index Scan using buggy_idx on restore_buggy_primscan_table bug  (cost=0.28..16.57 rows=10 width=8) (actual rows=21 loops=1)
               Index Cond: (y = ANY (ARRAY[(InitPlan 1).col1]))
               Buffers: shared hit=24
(16 rows)

-- (Jun 6 2024)
--
-- Fill with tuples match original "x=1" tuples, but with "x=0" and "x=2"
-- (i.e. enclose original "x=1" tuples so we have to do some skipping).
insert into outer_table                  select 0, b_vals from generate_series(1006, 1580) b_vals;
insert into restore_buggy_primscan_table select 0, x_vals from generate_series(1006, 1580) x_vals;
insert into outer_table                  select 0, 1370 from generate_series(1, 9) j;
insert into restore_buggy_primscan_table select 0, 1371 from generate_series(1, 9) j;
insert into restore_buggy_primscan_table select 0, 1380 from generate_series(1, 9) j;
insert into outer_table                  select 2, b_vals from generate_series(1006, 1580) b_vals;
insert into restore_buggy_primscan_table select 2, x_vals from generate_series(1006, 1580) x_vals;
insert into outer_table                  select 2, 1370 from generate_series(1, 9) j;
insert into restore_buggy_primscan_table select 2, 1371 from generate_series(1, 9) j;
insert into restore_buggy_primscan_table select 2, 1380 from generate_series(1, 9) j;
execute skip_restore_buggy_primscan_qry;
 count | a |  b   
-------+---+------
    10 | 0 | 1370
    10 | 0 | 1380
     1 | 0 | 1390
    10 | 1 | 1370
    10 | 1 | 1380
     1 | 1 | 1390
    10 | 2 | 1370
    10 | 2 | 1380
     1 | 2 | 1390
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute skip_restore_buggy_primscan_qry;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.88..42.06 rows=10 width=16) (actual rows=9 loops=1)
   Group Key: o.a, o.b
   Buffers: shared hit=83
   InitPlan 1
     ->  Aggregate  (cost=0.32..0.33 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..0.32 rows=1 width=4) (actual rows=3 loops=1)
                 Filter: ((i % 10) = 0)
                 Rows Removed by Filter: 18
   ->  Merge Join  (cost=0.55..41.55 rows=10 width=8) (actual rows=63 loops=1)
         Merge Cond: ((o.a = bug.x) AND (o.b = bug.y))
         Buffers: shared hit=83
         ->  Index Scan using avoid_sort on outer_table o  (cost=0.28..21.91 rows=584 width=8) (actual rows=1563 loops=1)
               Buffers: shared hit=22
         ->  Index Scan using buggy_idx on restore_buggy_primscan_table bug  (cost=0.28..16.57 rows=10 width=8) (actual rows=63 loops=1)
               Index Cond: (y = ANY (ARRAY[(InitPlan 1).col1]))
               Buffers: shared hit=61
(16 rows)

deallocate skip_restore_buggy_primscan_qry;
-- (November 30)
--
-- Get test coverage for when so->needPrimScan is set at the point of calling
-- _bt_restore_array_keys().  This is handled like the case where the scan
-- direction changes "within" a page, relying on code from _bt_readnextpage().
set client_min_messages=error;
drop table if exists outer_tab;
drop table if exists primscanmarkcov_table;
reset client_min_messages;
create unlogged table outer_tab(
  a int,
  b int
);
create index outer_tab_idx on outer_tab(a, b) with (deduplicate_items = off);
create unlogged table primscanmarkcov_table(
  a int,
  b int
);
create index interesting_coverage_idx on primscanmarkcov_table(a, b) with (deduplicate_items = off);
insert into outer_tab             select 1, i from generate_series(1530, 1780) i;
insert into primscanmarkcov_table select 1, i from generate_series(1530, 1780) i;
insert into outer_tab             select 1, 1550 from generate_series(1, 200) i;
insert into primscanmarkcov_table select 1, 1551 from generate_series(1, 200) i;
vacuum analyze outer_tab;
vacuum analyze primscanmarkcov_table ;
prepare merge_join_qry as
with range_ints as ( select i from generate_series(1530, 1780) i)
select
  count(*), buggy.a, buggy.b from
outer_tab o
  inner join
primscanmarkcov_table buggy
  on o.a = buggy.a and o.b = buggy.b
where
  o.a = 1     and     o.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])  and
  buggy.a = 1 and buggy.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])
group by buggy.a, buggy.b
order by buggy.a, buggy.b;
execute merge_join_qry;
 count | a |  b   
-------+---+------
   201 | 1 | 1550
     1 | 1 | 1600
     1 | 1 | 1650
     1 | 1 | 1700
     1 | 1 | 1750
(5 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) <-- Disable sept 28 2024
-- execute merge_join_qry;
deallocate merge_join_qry;
-- (Jun 6 2024)
--
-- Fill with tuples match original "x=1" tuples, but with "x=0" and "x=2"
-- (i.e. enclose original "x=1" tuples so we have to do some skipping).
insert into outer_tab             select 0, i from generate_series(1530, 1780) i;
insert into primscanmarkcov_table select 0, i from generate_series(1530, 1780) i;
insert into outer_tab             select 0, 1550 from generate_series(1, 200) i;
insert into primscanmarkcov_table select 0, 1551 from generate_series(1, 200) i;
insert into outer_tab             select 2, i from generate_series(1530, 1780) i;
insert into primscanmarkcov_table select 2, i from generate_series(1530, 1780) i;
insert into outer_tab             select 2, 1550 from generate_series(1, 200) i;
insert into primscanmarkcov_table select 2, 1551 from generate_series(1, 200) i;
vacuum analyze outer_tab;
vacuum analyze primscanmarkcov_table ;
prepare skip_merge_join_qry as
with range_ints as ( select i from generate_series(1530, 1780) i)
select
  count(*), buggy.a, buggy.b from
outer_tab o
  inner join
primscanmarkcov_table buggy
  on o.a = buggy.a and o.b = buggy.b
where
  o.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])  and
  buggy.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])
group by buggy.a, buggy.b
order by buggy.a, buggy.b;
execute skip_merge_join_qry;
 count | a |  b   
-------+---+------
   201 | 0 | 1550
     1 | 0 | 1600
     1 | 0 | 1650
     1 | 0 | 1700
     1 | 0 | 1750
   201 | 1 | 1550
     1 | 1 | 1600
     1 | 1 | 1650
     1 | 1 | 1700
     1 | 1 | 1750
   201 | 2 | 1550
     1 | 2 | 1600
     1 | 2 | 1650
     1 | 2 | 1700
     1 | 2 | 1750
(15 rows)

-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
-- execute skip_merge_join_qry;
deallocate skip_merge_join_qry;
-- (March 18)
--
-- Try to make a merge join go backwards with a cursor +
-- restore_buggy_primscan_qry query
-- Index-only scan (makes picture vs master clearer than a plain index scan
-- for these merge join tests):
set enable_bitmapscan to off;
set enable_indexonlyscan to on;
set enable_indexscan to off;
set work_mem = 64;
set cursor_tuple_fraction = 0.0001;
begin;
-- XXX (November 6 2024) Disable EXPLAIN ANALYZE output to suppress test
-- flappiness due to "Storage: Memory  Maximum Storage: 26kB" variations
-- across debug and release builds.
--
-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
-- declare restore_buggy_primscan_qry_cursor cursor for
-- with range_ints as ( select i from generate_series(1530, 1780) i)
-- select
--   buggy.a, buggy.b from
-- outer_tab o
--   inner join
-- primscanmarkcov_table buggy
--   on o.a = buggy.a and o.b = buggy.b
-- where
--   o.a = 1     and     o.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])  and
--   buggy.a = 1 and buggy.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])
-- order by buggy.a, buggy.b;
declare restore_buggy_primscan_qry_cursor cursor for
with range_ints as ( select i from generate_series(1530, 1780) i)
select
  buggy.a, buggy.b from
outer_tab o
  inner join
primscanmarkcov_table buggy
  on o.a = buggy.a and o.b = buggy.b
where
  o.a = 1     and     o.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])  and
  buggy.a = 1 and buggy.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])
order by buggy.a, buggy.b;
select pg_stat_get_xact_blocks_hit('buggy_idx'::regclass) as cur_blocks_hit \gset
\set old_blocks_hit :cur_blocks_hit
-- Show one row matching (a,b)=(1, 1550):
fetch forward 1 from restore_buggy_primscan_qry_cursor;
 a |  b   
---+------
 1 | 1550
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('buggy_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

-- Skip all later such rows (201 total, so skip 200):
move forward 200 in restore_buggy_primscan_qry_cursor;
-- Show one row matching (a,b)=(1, 1600):
fetch forward 1 from restore_buggy_primscan_qry_cursor;
 a |  b   
---+------
 1 | 1600
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('buggy_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

-- Show one row matching (a,b)=(1, 1650):
fetch forward 1 from restore_buggy_primscan_qry_cursor;
 a |  b   
---+------
 1 | 1650
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('buggy_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

-- Show one row matching (a,b)=(1, 1700):
fetch forward 1 from restore_buggy_primscan_qry_cursor;
 a |  b   
---+------
 1 | 1700
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('buggy_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

-- Show one row matching (a,b)=(1, 1750):
fetch forward 1 from restore_buggy_primscan_qry_cursor;
 a |  b   
---+------
 1 | 1750
(1 row)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('buggy_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

-- No more rows to show:
fetch forward 1 from restore_buggy_primscan_qry_cursor;
 a | b 
---+---
(0 rows)

\set old_blocks_hit :cur_blocks_hit
select pg_stat_get_xact_blocks_hit('buggy_idx'::regclass) as cur_blocks_hit \gset
select :cur_blocks_hit - :old_blocks_hit bh;
 bh 
----
  0
(1 row)

fetch backward 1 from restore_buggy_primscan_qry_cursor;
ERROR:  cursor can only scan forward
HINT:  Declare it with SCROLL option to enable backward scan.
/* restore_buggy_primscan_qry_cursor */ commit;
reset work_mem;
set enable_mergejoin = off;
set enable_memoize = off;
set enable_nestloop = on;
-- Now do nestloopjoin_qry, which is exactly the same queru as merge_join_qry,
-- but has a nestloop plan
--
-- (March 4) This variant was buggy following merge of _bt_preprocess_keys and
-- _bt_preprocess_array_keys, though it might have been a preexisiting issue
-- (coincided with getting serious about testing nestloop joins).
--
-- XXX UPDATE: Derp, this was due to a simple lack of rigor here (should have
-- been testing both scan keys from the pair being considered):
/*
--- a/src/backend/access/nbtree/nbtutils.c
+++ b/src/backend/access/nbtree/nbtutils.c
@@ -2694,7 +2694,8 @@ _bt_preprocess_keys(IndexScanDesc scan, ScanDirection dir)
             if (j == (BTEqualStrategyNumber - 1) &&
-                (xform[j].skey->sk_flags & SK_SEARCHARRAY) &&
+                ((xform[j].skey->sk_flags & SK_SEARCHARRAY) ||
+                 (cur->sk_flags & SK_SEARCHARRAY)) &&
                 !(cur->sk_flags & SK_SEARCHNULL))
             {
*/
prepare nestloopjoin_qry as
with range_ints as ( select i from generate_series(1530, 1780) i)
select
  count(*), buggy.a, buggy.b from
outer_tab o
  inner join
primscanmarkcov_table buggy
  on o.a = buggy.a and o.b = buggy.b
where
  o.a = 1     and     o.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])  and
  buggy.a = 1 and buggy.b = any (array[(select array_agg(i) from range_ints where i % 50 = 0)])
group by buggy.a, buggy.b
order by buggy.a, buggy.b;
execute nestloopjoin_qry;
 count | a |  b   
-------+---+------
   201 | 1 | 1550
     1 | 1 | 1600
     1 | 1 | 1650
     1 | 1 | 1700
     1 | 1 | 1750
(5 rows)

-- XXX (November 6 2024) Disable EXPLAIN ANALYZE output to suppress test
-- flappiness due to "Storage: Memory  Maximum Storage: 26kB" variations
-- across debug and release builds.
-- EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
-- execute nestloopjoin_qry;
deallocate nestloopjoin_qry;
-- (November 30)
--
-- Get test coverage for when so->needPrimScan is set at the point of calling
-- _bt_restore_array_keys() for backwards scans.  More or less comparable to
-- the last test.
set client_min_messages=error;
drop table if exists backwards_prim_outer_table;
drop table if exists backwards_restore_buggy_primscan_table;
reset client_min_messages;
create unlogged table backwards_prim_outer_table             (a int, b int);
create unlogged table backwards_restore_buggy_primscan_table (x int, y int);
create index backward_prim_buggy_idx  on backwards_restore_buggy_primscan_table (x, y) with (deduplicate_items=off);
create index backwards_prim_drive_idx on backwards_prim_outer_table             (a, b) with (deduplicate_items=off);
insert into backwards_prim_outer_table                  select 0, 1360;
insert into backwards_prim_outer_table                  select 1, b_vals from generate_series(1012, 1406) b_vals where b_vals % 10 = 0;
insert into backwards_prim_outer_table                  select 1, 1370;
vacuum analyze backwards_prim_outer_table; -- Be tidy
-- Fill up "backwards_prim_drive_idx" index with 396 items, just about fitting
-- onto its only page, which is a root leaf page:
insert into backwards_restore_buggy_primscan_table select 0, 1360;
insert into backwards_restore_buggy_primscan_table select 1, x_vals from generate_series(1012, 1406) x_vals;
-- Now cause two page splits, leaving 4 leaf pages in total:
insert into backwards_restore_buggy_primscan_table select 1, 1370 from generate_series(1,250) i;
vacuum analyze backwards_restore_buggy_primscan_table; -- Be tidy
-- Now buggy index looks like this:
--
-- ┌───┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬──────────────────┐
-- │ i │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │     highkey      │
-- ├───┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼──────────────────┤
-- │ 1 │     1 │     1 │    203 │      1 │          0 │   204 │     0 │                 0 │      16 │     4,068 │ (x, y)=(1, 1214) │
-- │ 2 │     4 │     1 │    156 │      2 │          0 │   157 │     0 │                 0 │      16 │     5,008 │ (x, y)=(1, 1370) │
-- │ 3 │     5 │     1 │    251 │      2 │          0 │   252 │     0 │                 0 │      16 │     3,108 │ (x, y)=(1, 1371) │
-- │ 4 │     2 │     1 │     36 │      1 │          0 │    36 │     0 │                 0 │      16 │     7,428 │ ∅                │
-- └───┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴──────────────────┘
set enable_mergejoin=on;
set enable_nestloop=off;
prepare backwards_prim_confusion_qry as
select count(*), o.a, o.b
  from
    backwards_prim_outer_table o
  inner join
    backwards_restore_buggy_primscan_table bug
  on o.a = bug.x and o.b = bug.y
where
  bug.x in (0, 1) and
  bug.y = any(array[(select array_agg(i) from generate_series(1360, 1370) i where i % 10 = 0)])
group by o.a, o.b
order by o.a desc, o.b desc;
-- These are marks are restores seen for this query (this instrumentation is from
-- commit 4e24c585 on branch saop-dynamic-skip-v7.17):
--
-- WARNING:  marking   markPos.currPage: 4294967295, markPos.nextPage: 4294967295, currPos.currPage: 5, currPos.nextPage: 2
-- WARNING:  marking:  attno: 1, cur_elem/mark_elem: 1 (value 1)
-- WARNING:  marking:  attno: 2, cur_elem/mark_elem: 1 (value 1370)
-- WARNING:  restoring markPos.currPage: 5, markPos.nextPage: 2, currPos.currPage: 4, currPos.nextPage: 5
-- WARNING:            attno: 1, cur_elem: 0 (value 0), mark_elem: 1 (value 1)
--
-- (No more interesting mark and restores for this query, the reset omitted
-- for brevity)
execute backwards_prim_confusion_qry;
 count | a |  b   
-------+---+------
   502 | 1 | 1370
     1 | 1 | 1360
     1 | 0 | 1360
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute backwards_prim_confusion_qry;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.60..10.45 rows=13 width=16) (actual rows=3 loops=1)
   Group Key: o.a, o.b
   Buffers: shared hit=9
   InitPlan 1
     ->  Aggregate  (cost=0.17..0.18 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series i  (cost=0.00..0.17 rows=1 width=4) (actual rows=2 loops=1)
                 Filter: ((i % 10) = 0)
                 Rows Removed by Filter: 9
   ->  Merge Join  (cost=0.42..10.04 rows=13 width=8) (actual rows=504 loops=1)
         Merge Cond: ((o.a = bug.x) AND (o.b = bug.y))
         Buffers: shared hit=9
         ->  Index Only Scan Backward using backwards_prim_drive_idx on backwards_prim_outer_table o  (cost=0.14..4.75 rows=41 width=8) (actual rows=41 loops=1)
               Disabled: true
               Heap Fetches: 0
               Buffers: shared hit=2
         ->  Index Only Scan Backward using backward_prim_buggy_idx on backwards_restore_buggy_primscan_table bug  (cost=0.28..4.87 rows=16 width=8) (actual rows=504 loops=1)
               Disabled: true
               Index Cond: ((x = ANY ('{0,1}'::integer[])) AND (y = ANY (ARRAY[(InitPlan 1).col1])))
               Heap Fetches: 0
               Buffers: shared hit=7
(20 rows)

deallocate backwards_prim_confusion_qry;
reset enable_nestloop;
reset enable_mergejoin;
reset enable_hashjoin;
reset enable_sort;
reset enable_material;
----------------------------------------------------------------------------------------------
-- One duplicate value per leaf page must not visit too many extra leaf pages speculatively --
----------------------------------------------------------------------------------------------
set client_min_messages=error;
drop table if exists duplicate_test;
reset client_min_messages;
create unlogged table duplicate_test(dup int4);
create index on duplicate_test (dup);
insert into duplicate_test
select val from generate_series(1, 18) val,
                generate_series(1,1000) dups_per_val;
vacuum analyze duplicate_test; -- Be tidy
-- Index-only scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to on;
set enable_indexscan to off;
-- (December 3)
--
-- Use every third leaf page (not every second) here, so that we don't
-- conflate a waste leaf page visit with a repeat root page visit.
--
-- Recall how with "i % 2 = 0"/every-second-page-and-value, we'll visit the next leaf
-- page incorrectly, but then correctly repeat the same gamble and "win" the
-- second time.  We don't want to confuse that case for a "draw" against the
-- master branch -- the extra leaf pages are actually more expensive than repeat
-- root page accessed.  Making it every third page avoids that problem,
-- painting a clear picture.
--
-- This test is per https://postgr.es/m/CAH2-WzmtV7XEWxf_rP1pw=vyDjGLi__zGOy6Me5MovR3e1kfdg@mail.gmail.com
select count(*), dup from duplicate_test
where dup = any (array[( select array_agg(val) from generate_series(1, 20) val where val % 3 = 0)])
group by dup order by dup;
 count | dup 
-------+-----
  1000 |   3
  1000 |   6
  1000 |   9
  1000 |  12
  1000 |  15
  1000 |  18
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*), dup from duplicate_test
where dup = any (array[( select array_agg(val) from generate_series(1, 20) val where val % 3 = 0)])
group by dup order by dup;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.60..200.87 rows=18 width=12) (actual rows=6 loops=1)
   Group Key: duplicate_test.dup
   Buffers: shared hit=13
   InitPlan 1
     ->  Aggregate  (cost=0.31..0.32 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series val  (cost=0.00..0.30 rows=1 width=4) (actual rows=6 loops=1)
                 Filter: ((val % 3) = 0)
                 Rows Removed by Filter: 14
   ->  Index Only Scan using duplicate_test_dup_idx on duplicate_test  (cost=0.29..161.18 rows=7837 width=4) (actual rows=6000 loops=1)
         Disabled: true
         Index Cond: (dup = ANY (ARRAY[(InitPlan 1).col1]))
         Heap Fetches: 0
         Buffers: shared hit=13
(13 rows)

-- But we should still be able to avoid every additional index descents after
-- the first, once the query has all constants from the index, which are
-- gapless (high key always finds an exact match for untruncated attributes,
-- so we're good):
select count(*), dup from duplicate_test
where dup = any (array[( select array_agg(val) from generate_series(1, 40) val)])
group by dup order by dup;
 count | dup 
-------+-----
  1000 |   1
  1000 |   2
  1000 |   3
  1000 |   4
  1000 |   5
  1000 |   6
  1000 |   7
  1000 |   8
  1000 |   9
  1000 |  10
  1000 |  11
  1000 |  12
  1000 |  13
  1000 |  14
  1000 |  15
  1000 |  16
  1000 |  17
  1000 |  18
(18 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 20 hits vs 81 on master
select count(*), dup from duplicate_test
where dup = any (array[( select array_agg(val) from generate_series(1, 40) val)])
group by dup order by dup;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.80..201.06 rows=18 width=12) (actual rows=18 loops=1)
   Group Key: duplicate_test.dup
   Buffers: shared hit=20
   InitPlan 1
     ->  Aggregate  (cost=0.51..0.52 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series val  (cost=0.00..0.40 rows=40 width=4) (actual rows=40 loops=1)
   ->  Index Only Scan using duplicate_test_dup_idx on duplicate_test  (cost=0.29..161.18 rows=7837 width=4) (actual rows=18000 loops=1)
         Disabled: true
         Index Cond: (dup = ANY (ARRAY[(InitPlan 1).col1]))
         Heap Fetches: 0
         Buffers: shared hit=20
(11 rows)

-- (March 9)
--
-- Make sure that we can manage with a mix of different operators when
-- determining redundancy of array keys.
--
-- Goal here is to render both of the inequalities as redundant in a way that
-- leaves array without either its lower or its higher elements, like so:
/*
_bt_preprocess_keys:  inkeys[0]: [ flags: [SK_SEARCHARRAY], attno: 1 func OID: 65 ]
_bt_preprocess_keys:  inkeys[1]: [ flags: [], attno: 1 func OID: 147 ]
_bt_preprocess_keys:  inkeys[2]: [ flags: [], attno: 1 func OID: 66 ]
_bt_preprocess_keys: outkeys[0]: [ flags: [SK_SEARCHARRAY, SK_BT_REQFWD, SK_BT_REQBKWD], attno: 1 func OID: 65 ]
_bt_preprocess_keys: scan->numberOfKeys is 3, so->numberOfKeys on output is 1
*/
select count(*), dup from duplicate_test
where dup = any (array[( select array_agg(val) from generate_series(1, 40) val)])
and dup > 8 and dup < 11
group by dup order by dup;
 count | dup 
-------+-----
  1000 |   9
  1000 |  10
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 4 hits (include one vm hit)
select count(*), dup from duplicate_test
where dup = any (array[( select array_agg(val) from generate_series(1, 40) val)])
and dup > 8 and dup < 11
group by dup order by dup;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.80..38.62 rows=18 width=12) (actual rows=2 loops=1)
   Group Key: duplicate_test.dup
   Buffers: shared hit=4
   InitPlan 1
     ->  Aggregate  (cost=0.51..0.52 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series val  (cost=0.00..0.40 rows=40 width=4) (actual rows=40 loops=1)
   ->  Index Only Scan using duplicate_test_dup_idx on duplicate_test  (cost=0.29..33.57 rows=871 width=4) (actual rows=2000 loops=1)
         Disabled: true
         Index Cond: ((dup = ANY (ARRAY[(InitPlan 1).col1])) AND (dup > 8) AND (dup < 11))
         Heap Fetches: 0
         Buffers: shared hit=4
(11 rows)

-- Variant #1 (changes the order, not the true meaning):
select count(*), dup from duplicate_test
where
dup > 8 and
dup = any(array[( select array_agg(val) from generate_series(1, 40) val)]) and
dup < 11
group by dup order by dup;
 count | dup 
-------+-----
  1000 |   9
  1000 |  10
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 4 hits (include one vm hit)
select count(*), dup from duplicate_test
where
dup > 8 and
dup = any(array[( select array_agg(val) from generate_series(1, 40) val)]) and
dup < 11
group by dup order by dup;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.80..38.62 rows=18 width=12) (actual rows=2 loops=1)
   Group Key: duplicate_test.dup
   Buffers: shared hit=4
   InitPlan 1
     ->  Aggregate  (cost=0.51..0.52 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series val  (cost=0.00..0.40 rows=40 width=4) (actual rows=40 loops=1)
   ->  Index Only Scan using duplicate_test_dup_idx on duplicate_test  (cost=0.29..33.57 rows=871 width=4) (actual rows=2000 loops=1)
         Disabled: true
         Index Cond: ((dup > 8) AND (dup = ANY (ARRAY[(InitPlan 1).col1])) AND (dup < 11))
         Heap Fetches: 0
         Buffers: shared hit=4
(11 rows)

-- Variant #2 (changes the order, not the true meaning):
select count(*), dup from duplicate_test
where
dup > 8 and
dup < 11 and
dup = any(array[( select array_agg(val) from generate_series(1, 40) val)])
group by dup order by dup;
 count | dup 
-------+-----
  1000 |   9
  1000 |  10
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 4 hits (include one vm hit)
select count(*), dup from duplicate_test
where
dup > 8 and
dup < 11 and
dup = any(array[( select array_agg(val) from generate_series(1, 40) val)])
group by dup order by dup;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.80..38.62 rows=18 width=12) (actual rows=2 loops=1)
   Group Key: duplicate_test.dup
   Buffers: shared hit=4
   InitPlan 1
     ->  Aggregate  (cost=0.51..0.52 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series val  (cost=0.00..0.40 rows=40 width=4) (actual rows=40 loops=1)
   ->  Index Only Scan using duplicate_test_dup_idx on duplicate_test  (cost=0.29..33.57 rows=871 width=4) (actual rows=2000 loops=1)
         Disabled: true
         Index Cond: ((dup > 8) AND (dup < 11) AND (dup = ANY (ARRAY[(InitPlan 1).col1])))
         Heap Fetches: 0
         Buffers: shared hit=4
(11 rows)

-- Variant #3 (changes the order, not the true meaning):
select count(*), dup from duplicate_test
where
dup < 11 and
dup > 8 and
dup = any(array[( select array_agg(val) from generate_series(1, 40) val)])
group by dup order by dup;
 count | dup 
-------+-----
  1000 |   9
  1000 |  10
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 4 hits (include one vm hit)
select count(*), dup from duplicate_test
where
dup < 11 and
dup > 8 and
dup = any(array[( select array_agg(val) from generate_series(1, 40) val)])
group by dup order by dup;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.80..38.62 rows=18 width=12) (actual rows=2 loops=1)
   Group Key: duplicate_test.dup
   Buffers: shared hit=4
   InitPlan 1
     ->  Aggregate  (cost=0.51..0.52 rows=1 width=32) (actual rows=1 loops=1)
           ->  Function Scan on generate_series val  (cost=0.00..0.40 rows=40 width=4) (actual rows=40 loops=1)
   ->  Index Only Scan using duplicate_test_dup_idx on duplicate_test  (cost=0.29..33.57 rows=871 width=4) (actual rows=2000 loops=1)
         Disabled: true
         Index Cond: ((dup < 11) AND (dup > 8) AND (dup = ANY (ARRAY[(InitPlan 1).col1])))
         Heap Fetches: 0
         Buffers: shared hit=4
(11 rows)

--
-- (January 17)
--
-- Matthias assertion test case
set client_min_messages=error;
drop table if exists test_matthias_assert;
reset client_min_messages;
create unlogged table test_matthias_assert as
select i a, i b, i c from generate_series(1, 1000) i;
create index on test_matthias_assert(a, b, c);
vacuum analyze test_matthias_assert; -- be tidy
-- This was the assertion failure:
--
-- TRAP: failed Assert("!foundRequiredOppositeDirOnly"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 1408, PID: 30438
-- 0   postgres                            0x0000000100e0fb74 ExceptionalCondition + 236
-- 1   postgres                            0x00000001006c45d8 _bt_advance_array_keys + 1024
-- 2   postgres                            0x00000001006c37c0 _bt_checkkeys + 716
-- 3   postgres                            0x00000001006b7720 _bt_readpage + 1232
select count(*) from test_matthias_assert
where a = any ('{1,2,3}') and b > 1 and c > 1
and b = any ('{1,2,3}');
 count 
-------
     2
(1 row)

explain (analyze, buffers, timing off, summary off)
select count(*) from test_matthias_assert
where a = any ('{1,2,3}') and b > 1 and c > 1
and b = any ('{1,2,3}');
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=4.59..4.60 rows=1 width=8) (actual rows=1 loops=1)
   Buffers: shared hit=3
   ->  Index Only Scan using test_matthias_assert_a_b_c_idx on test_matthias_assert  (cost=0.28..4.59 rows=1 width=0) (actual rows=2 loops=1)
         Disabled: true
         Index Cond: ((a = ANY ('{1,2,3}'::integer[])) AND (b > 1) AND (b = ANY ('{1,2,3}'::integer[])) AND (c > 1))
         Heap Fetches: 0
         Buffers: shared hit=3
(7 rows)

--
-- (January 17)
--
-- Matthias test case for cross-type opfamily where redundant
set client_min_messages=error;
drop table if exists test_matthias_type_opclass_redundant;
reset client_min_messages;
create unlogged table test_matthias_type_opclass_redundant as
select generate_series(1, 10000, 1::bigint) num;
create index on test_matthias_type_opclass_redundant(num); /* bigint typed */
vacuum analyze test_matthias_type_opclass_redundant; -- be tidy
--
-- Qual might be broken due to application of smallint compare operator on int
-- values that do equal mod 2^16, but do not equal in their own type
--
select num from test_matthias_type_opclass_redundant
where num = any ('{1}'::smallint[])
  and num = any ('{1}'::int[])
  and num = any ('{65537}'::int[]);
 num 
-----
(0 rows)

explain (analyze, buffers, timing off, summary off)
select num from test_matthias_type_opclass_redundant
where num = any ('{1}'::smallint[])
  and num = any ('{1}'::int[])
  and num = any ('{65537}'::int[]);
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using test_matthias_type_opclass_redundant_num_idx on test_matthias_type_opclass_redundant  (cost=0.29..2.31 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((num = ANY ('{1}'::smallint[])) AND (num = ANY ('{1}'::integer[])) AND (num = ANY ('{65537}'::integer[])))
   Heap Fetches: 0
(4 rows)

-- Variant 1 (for good luck)
select num from test_matthias_type_opclass_redundant
where num = any ('{1}'::int[])
  and num = any ('{1}'::smallint[])
  and num = any ('{65537}'::int[]);
 num 
-----
(0 rows)

explain (analyze, buffers, timing off, summary off)
select num from test_matthias_type_opclass_redundant
where num = any ('{1}'::int[])
  and num = any ('{1}'::smallint[])
  and num = any ('{65537}'::int[]);
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using test_matthias_type_opclass_redundant_num_idx on test_matthias_type_opclass_redundant  (cost=0.29..2.31 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((num = ANY ('{1}'::integer[])) AND (num = ANY ('{1}'::smallint[])) AND (num = ANY ('{65537}'::integer[])))
   Heap Fetches: 0
(4 rows)

-- Variant 2 (for good luck)
select num from test_matthias_type_opclass_redundant
where num = any ('{65537}'::int[])
  and num = any ('{1}'::smallint[])
  and num = any ('{1}'::int[]);
 num 
-----
(0 rows)

explain (analyze, buffers, timing off, summary off)
select num from test_matthias_type_opclass_redundant
where num = any ('{65537}'::int[])
  and num = any ('{1}'::smallint[])
  and num = any ('{1}'::int[]);
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using test_matthias_type_opclass_redundant_num_idx on test_matthias_type_opclass_redundant  (cost=0.29..2.31 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((num = ANY ('{65537}'::integer[])) AND (num = ANY ('{1}'::smallint[])) AND (num = ANY ('{1}'::integer[])))
   Heap Fetches: 0
(4 rows)

-- (February 1) Assertion failure within _bt_preprocess_keys:
--
-- 2024-02-01 08:39:04.230 PST [15721][client backend] [[unknown]][3/2357:0] LOCATION:  PerformAuthentication, postinit.c:299
-- TRAP: failed Assert("(xform[j].skey->sk_flags & SK_SEARCHARRAY) == 0"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 2587, PID: 15721
-- 0   postgres                            0x0000000103367f78 ExceptionalCondition + 236
-- 1   postgres                            0x0000000102c14cb4 _bt_preprocess_keys + 2724
prepare assert_failure_preprocess as
select num from test_matthias_type_opclass_redundant
where num = any ('{65537}'::int[])
  and num >= any ('{1}'::smallint[])
  and num >= any ('{1}'::int[]);
execute assert_failure_preprocess;
 num 
-----
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute assert_failure_preprocess;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using test_matthias_type_opclass_redundant_num_idx on test_matthias_type_opclass_redundant  (cost=0.29..2.31 rows=1 width=8) (actual rows=0 loops=1)
   Disabled: true
   Index Cond: ((num = ANY ('{65537}'::integer[])) AND (num >= ANY ('{1}'::smallint[])) AND (num >= ANY ('{1}'::integer[])))
   Heap Fetches: 0
   Buffers: shared hit=2
(5 rows)

deallocate assert_failure_preprocess;
--------------------
-- Opfamily tests --
--------------------
set client_min_messages=error;
drop table if exists opfamily_test;
drop operator family if exists test_family using btree cascade;
drop function if exists my_int2_sort(int2,int2) cascade;
drop function if exists my_int4_sort(int4,int4) cascade;
drop function if exists my_int8_sort(int8,int8) cascade;
drop function if exists my_int8_int2_sort(int8,int2) cascade;
drop function if exists my_int8_int4_sort(int8,int4) cascade;
drop function if exists my_int4_int8_sort(int4,int8) cascade;
reset client_min_messages;
-- Same-type procs:
create function my_int2_sort(int2,int2) returns int language sql
  as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
create function my_int4_sort(int4,int4) returns int language sql
  as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
create function my_int8_sort(int8,int8) returns int language sql
  as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
-- Cross type procs (note that index will be int8):
create function my_int8_int2_sort(int8,int2) returns int language sql
  as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
create function my_int8_int4_sort(int8,int4) returns int language sql
  as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
create function my_int4_int8_sort(int4,int8) returns int language sql
  as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$;
create operator family test_family using btree;
create operator class test_int2_ops for type int2 using btree family test_family as
  operator 1 < (int2,int2),
  operator 2 <= (int2,int2),
  operator 3 = (int2,int2),
  operator 4 >= (int2,int2),
  operator 5 > (int2,int2),
  function 1 my_int2_sort(int2,int2);
  -- Will add cross-type operators + function for int2 later on
create operator class test_int4_ops for type int4 using btree family test_family as
  operator 1 < (int4,int4),
  operator 2 <= (int4,int4),
  operator 3 = (int4,int4),
  operator 4 >= (int4,int4),
  operator 5 > (int4,int4),
  function 1 my_int4_sort(int4,int4);
  -- Will add cross-type operators + function for int4 later on
create operator class test_int8_ops for type int8 using btree family test_family as
  operator 1 < (int8,int8),
  operator 2 <= (int8,int8),
  operator 3 = (int8,int8),
  operator 4 >= (int8,int8),
  operator 5 > (int8,int8),
  function 1 my_int8_sort(int8,int8);
create unlogged table opfamily_test(foo int8);
create index on opfamily_test(foo test_int8_ops);
insert into opfamily_test values (365), (366), (367), (32767), (8589934591), (8589934592);
vacuum analyze opfamily_test; -- Be tidy
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
select * from opfamily_test where foo = any ('{365,367}'::int8[]);
 foo 
-----
 365
 367
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from opfamily_test where foo = any ('{365,367}'::int8[]);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.17 rows=2 width=8) (actual rows=2 loops=1)
   Index Cond: (foo = ANY ('{365,367}'::bigint[]))
   Buffers: shared hit=2
(3 rows)

-- Seqscan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to off;
set enable_seqscan to on;
select * from opfamily_test where foo = any ('{365,367}'::int4[]);
 foo 
-----
 365
 367
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from opfamily_test where foo = any ('{365,367}'::int4[]);
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Seq Scan on opfamily_test  (cost=0.00..1.07 rows=2 width=8) (actual rows=2 loops=1)
   Filter: (foo = ANY ('{365,367}'::integer[]))
   Rows Removed by Filter: 4
   Buffers: shared hit=1
(4 rows)

set enable_seqscan to off;
-- Add the missing cross-type operator, but neglect to add a support function 1 to go
-- along with it:
alter operator family test_family using btree add
  operator 3 = (int8, int4);
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Planner gives us an index scan this time, fails at runtime in nbtree
-- preprocessing:
-- (The error matches between master and patch, though it actually comes from
-- _bt_first in the case of master and from array preprocessing in the case
-- of the patch)
EXPLAIN
select * from opfamily_test where foo = any ('{365,367}'::int4[]);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.17 rows=2 width=8)
   Index Cond: (foo = ANY ('{365,367}'::integer[]))
(2 rows)

select * from opfamily_test where foo = any ('{365,367}'::int4[]);
ERROR:  missing support function 1(20,23) for attribute 1 of index "opfamily_test_foo_idx"
-- Add missing support function:
alter operator family test_family using btree add
  function 1 my_int8_int4_sort(int8, int4);
-- Now both planner and preprocessing don't error out, query works:
EXPLAIN
select * from opfamily_test where foo = any ('{365,367}'::int4[]);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.17 rows=2 width=8)
   Index Cond: (foo = ANY ('{365,367}'::integer[]))
(2 rows)

select * from opfamily_test where foo = any ('{365,367}'::int4[]);
 foo 
-----
 365
 367
(2 rows)

-- (March 10) Don't fail to include both scan keys when there is a lack of
-- cross-type support that proves to _bt_preprocess_keys that it can just
-- discard the non-array type.
--
-- Create needed cross-type operators + proc:
alter operator family test_family using btree add
  operator 2 <= (int8, int4);
alter operator family test_family using btree add
  operator 3 = (int8, int2);
alter operator family test_family using btree add
  function 1 my_int8_int2_sort(int8,int2);
-- Difficulty here is that there are many common cases where this'll
-- accidentally fail to fail, provided we at least keep the original array
-- (discarding the non-array scan key can break during this test because of
-- basic confusion about data types, that likely wouldn't ever happen with =
-- operator).
EXPLAIN
select * from opfamily_test where foo = any ('{32767}'::int2[]) and foo <= (-1)::int4;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..2.15 rows=1 width=8)
   Index Cond: ((foo = ANY ('{32767}'::smallint[])) AND (foo <= '-1'::integer))
(2 rows)

select * from opfamily_test where foo = any ('{32767}'::int2[]) and foo <= (-1)::int4;
 foo 
-----
(0 rows)

-- These are just for good luck:
EXPLAIN
select * from opfamily_test where  foo <= (-1)::int4 and foo = any ('{32767}'::int2[]);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..2.15 rows=1 width=8)
   Index Cond: ((foo <= '-1'::integer) AND (foo = ANY ('{32767}'::smallint[])))
(2 rows)

select * from opfamily_test where  foo <= (-1)::int4 and foo = any ('{32767}'::int2[]);
 foo 
-----
(0 rows)

EXPLAIN
select * from opfamily_test where foo = any ('{32767}'::int2[]) and foo = (-1)::int4;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.15 rows=1 width=8)
   Index Cond: ((foo = ANY ('{32767}'::smallint[])) AND (foo = '-1'::integer))
(2 rows)

select * from opfamily_test where foo = any ('{32767}'::int2[]) and foo = (-1)::int4;
 foo 
-----
(0 rows)

EXPLAIN
select * from opfamily_test where foo = (-1)::int4 and foo = any ('{32767}'::int2[]);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.15 rows=1 width=8)
   Index Cond: ((foo = ANY ('{32767}'::smallint[])) AND (foo = '-1'::integer))
(2 rows)

select * from opfamily_test where foo = (-1)::int4 and foo = any ('{32767}'::int2[]);
 foo 
-----
(0 rows)

-- Cross-type redundancies across arrays test
--
-- (December 5) Test caused this assertion failure:
--
-- TRAP: failed Assert("so->arrayKeyData[prev->scan_key].sk_func.fn_oid == cur->sk_func.fn_oid"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 446, PID: 1212966
-- postgres: pg regression [local] SELECT(ExceptionalCondition+0x75)[0x55f0f2bca415]
-- postgres: pg regression [local] SELECT(_bt_preprocess_array_keys+0x7f9)[0x55f0f278fc39]
select *
from opfamily_test
where
  foo = any ('{365,366}'::int4[]) and
  foo = any ('{366,367,8589934591,8589934592}'::int8[]);
 foo 
-----
 366
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from opfamily_test
where
  foo = any ('{365,366}'::int4[]) and
  foo = any ('{366,367,8589934591,8589934592}'::int8[]);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.15 rows=1 width=8) (actual rows=1 loops=1)
   Index Cond: ((foo = ANY ('{365,366}'::integer[])) AND (foo = ANY ('{366,367,8589934591,8589934592}'::bigint[])))
   Buffers: shared hit=2
(3 rows)

-- Variant for good luck
--
-- (January 27) This test proved that I needed to be more careful about the
-- order in which _bt_preprocess_keys appended output scan keys -- it needs
-- to match the input order exactly (we must not allow "swapping" of any pair
-- of not-provably-redundant scan keys), so that our current scan key -> order
-- proc mapping state works reliably later on.
--
-- Recall this stuff (inconsistent arguments between current search type scan
-- key and array scan keys/preprocessing's input scan keys):
--
-- petergeoghegan@regression:5432 [37539]=# select *
-- from opfamily_test
-- where
-- foo = any ('{366,367,8589934591,8589934592}'::int8[]) and
-- foo = any ('{365,366}'::int4[]);
-- ERROR:  3, ikey: 0, cur.sk_argument: 365, skeyarray.sk_argument: 366
select *
from opfamily_test
where
  foo = any ('{366,367,8589934591,8589934592}'::int8[]) and
  foo = any ('{365,366}'::int4[]);
 foo 
-----
 366
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from opfamily_test
where
  foo = any ('{366,367,8589934591,8589934592}'::int8[]) and
  foo = any ('{365,366}'::int4[]);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.15 rows=1 width=8) (actual rows=1 loops=1)
   Index Cond: ((foo = ANY ('{366,367,8589934591,8589934592}'::bigint[])) AND (foo = ANY ('{365,366}'::integer[])))
   Buffers: shared hit=2
(3 rows)

-- Other variants of original December 5 "Cross-type redundancies across arrays
-- test" test case (January 27)
select *
from opfamily_test
where
  foo = any ('{365,366}'::int8[]) and
  foo = any ('{366,367,2147480000,2147480001}'::int4[]);
 foo 
-----
 366
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from opfamily_test
where
  foo = any ('{365,366}'::int8[]) and
  foo = any ('{366,367,2147480000,2147480001}'::int4[]);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.15 rows=1 width=8) (actual rows=1 loops=1)
   Index Cond: ((foo = ANY ('{365,366}'::bigint[])) AND (foo = ANY ('{366,367,2147480000,2147480001}'::integer[])))
   Buffers: shared hit=2
(3 rows)

select *
from opfamily_test
where
  foo = any ('{366,367,2147480000,2147480001}'::int4[]) and
  foo = any ('{365,366}'::int8[]);
 foo 
-----
 366
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from opfamily_test
where
  foo = any ('{366,367,2147480000,2147480001}'::int4[]) and
  foo = any ('{365,366}'::int8[]);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Index Scan using opfamily_test_foo_idx on opfamily_test  (cost=0.13..4.15 rows=1 width=8) (actual rows=1 loops=1)
   Index Cond: ((foo = ANY ('{366,367,2147480000,2147480001}'::integer[])) AND (foo = ANY ('{365,366}'::bigint[])))
   Buffers: shared hit=2
(3 rows)

--------------------------------
-- BooleanTest/BoolExpr tests --
--------------------------------
set client_min_messages=error;
drop table if exists boolindex;
reset client_min_messages;
create unlogged table boolindex (b bool, i int, unique(b, i), junk float);
insert into boolindex select (i % 2 = 0), i from generate_series(1, 10) i;
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- "where b in ()" variants
select * from boolindex where b in (true, false) order by b, i limit 10;
 b | i  | junk 
---+----+------
 f |  1 |     
 f |  3 |     
 f |  5 |     
 f |  7 |     
 f |  9 |     
 t |  2 |     
 t |  4 |     
 t |  6 |     
 t |  8 |     
 t | 10 |     
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b in (true, false) order by b, i limit 10;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..0.45 rows=10 width=13) (actual rows=10 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..58.98 rows=1990 width=13) (actual rows=10 loops=1)
         Index Cond: (b = ANY ('{t,f}'::boolean[]))
         Buffers: shared hit=2
(5 rows)

select * from boolindex where b in (true, false) order by i limit 10;
 b | i  | junk 
---+----+------
 f |  1 |     
 t |  2 |     
 f |  3 |     
 t |  4 |     
 f |  5 |     
 t |  6 |     
 f |  7 |     
 t |  8 |     
 f |  9 |     
 t | 10 |     
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b in (true, false) order by i limit 10;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=101.98..102.01 rows=10 width=13) (actual rows=10 loops=1)
   Buffers: shared hit=2
   ->  Sort  (cost=101.98..106.96 rows=1990 width=13) (actual rows=10 loops=1)
         Sort Key: i
         Sort Method: quicksort  Memory: 25kB
         Buffers: shared hit=2
         ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..58.98 rows=1990 width=13) (actual rows=10 loops=1)
               Index Cond: (b = ANY ('{t,f}'::boolean[]))
               Buffers: shared hit=2
(9 rows)

-- "where b" variants (Just more Var coverage)
select * from boolindex where b and i in (2,4,5) order by b, i limit 10;
 b | i | junk 
---+---+------
 t | 2 |     
 t | 4 |     
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b and i in (2,4,5) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=2 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=2 loops=1)
         Index Cond: ((b = true) AND (i = ANY ('{2,4,5}'::integer[])))
         Buffers: shared hit=2
(5 rows)

select * from boolindex where b and i in (2,4,6) order by b, i limit 10;
 b | i | junk 
---+---+------
 t | 2 |     
 t | 4 |     
 t | 6 |     
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b and i in (2,4,6) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=3 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=3 loops=1)
         Index Cond: ((b = true) AND (i = ANY ('{2,4,6}'::integer[])))
         Buffers: shared hit=2
(5 rows)

-- "where b = true" variants (Just more Var coverage)
select * from boolindex where b = true and i in (2,4,5) order by b, i limit 10;
 b | i | junk 
---+---+------
 t | 2 |     
 t | 4 |     
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b = true and i in (2,4,5) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=2 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=2 loops=1)
         Index Cond: ((b = true) AND (i = ANY ('{2,4,5}'::integer[])))
         Buffers: shared hit=2
(5 rows)

select * from boolindex where b = true and i in (2,4,6) order by b, i limit 10;
 b | i | junk 
---+---+------
 t | 2 |     
 t | 4 |     
 t | 6 |     
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b = true and i in (2,4,6) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=3 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=3 loops=1)
         Index Cond: ((b = true) AND (i = ANY ('{2,4,6}'::integer[])))
         Buffers: shared hit=2
(5 rows)

-- "where b is true" variants (BooleanTest coverage)
select * from boolindex where b is true and i in (2,4,5) order by b, i limit 10;
 b | i | junk 
---+---+------
 t | 2 |     
 t | 4 |     
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b is true and i in (2,4,5) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=2 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=2 loops=1)
         Index Cond: ((b = true) AND (i = ANY ('{2,4,5}'::integer[])))
         Buffers: shared hit=2
(5 rows)

select * from boolindex where b is true and i in (2,4,6) order by b, i limit 10;
 b | i | junk 
---+---+------
 t | 2 |     
 t | 4 |     
 t | 6 |     
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b is true and i in (2,4,6) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=3 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=3 loops=1)
         Index Cond: ((b = true) AND (i = ANY ('{2,4,6}'::integer[])))
         Buffers: shared hit=2
(5 rows)

-- "where b = false" variants (BoolExpr coverage)
select * from boolindex where b = false and i in (2,4,5) order by b, i limit 10;
 b | i | junk 
---+---+------
 f | 5 |     
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b = false and i in (2,4,5) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=1 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=1 loops=1)
         Index Cond: ((b = false) AND (i = ANY ('{2,4,5}'::integer[])))
         Buffers: shared hit=2
(5 rows)

select * from boolindex where b = false and i in (2,4,6) order by b, i limit 10;
 b | i | junk 
---+---+------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where b = false and i in (2,4,6) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=0 loops=1)
   Buffers: shared hit=1
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=0 loops=1)
         Index Cond: ((b = false) AND (i = ANY ('{2,4,6}'::integer[])))
         Buffers: shared hit=1
(5 rows)

-- "where not b" variants (more BoolExpr coverage)
select * from boolindex where not b and i in (2,4,5) order by b, i limit 10;
 b | i | junk 
---+---+------
 f | 5 |     
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where not b and i in (2,4,5) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=1 loops=1)
   Buffers: shared hit=2
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=1 loops=1)
         Index Cond: ((b = false) AND (i = ANY ('{2,4,5}'::integer[])))
         Buffers: shared hit=2
(5 rows)

select * from boolindex where not b and i in (2,4,6) order by b, i limit 10;
 b | i | junk 
---+---+------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from boolindex where not b and i in (2,4,6) order by b, i limit 10;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.15..13.69 rows=10 width=13) (actual rows=0 loops=1)
   Buffers: shared hit=1
   ->  Index Scan using boolindex_b_i_key on boolindex  (cost=0.15..20.45 rows=15 width=13) (actual rows=0 loops=1)
         Index Cond: ((b = false) AND (i = ANY ('{2,4,6}'::integer[])))
         Buffers: shared hit=1
(5 rows)

reset enable_sort;
select 1
from pg_catalog.pg_collation c
where c.collencoding in (-1, 2) and c.collname ~ E'^(no\\.such\\.collation\\$)$';
 ?column? 
----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select 1
from pg_catalog.pg_collation c
where c.collencoding in (-1, 2) and c.collname ~ E'^(no\\.such\\.collation\\$)$';
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Scan using pg_collation_name_enc_nsp_index on pg_collation c  (cost=0.28..6.59 rows=1 width=4) (actual rows=0 loops=1)
   Index Cond: ((collname = 'no.such.collation$'::text) AND (collencoding = ANY ('{-1,2}'::integer[])))
   Filter: (collname ~ '^(no\.such\.collation\$)$'::text)
   Buffers: shared hit=2
(4 rows)

-- (February 2) Need to use same-type comparator for sorting, even when we
-- also need to use cross-type comparator during index scans, for binary
-- searches
set client_min_messages=error;
drop table if exists use_proper_monotype_sort;
reset client_min_messages;
create unlogged table use_proper_monotype_sort(collname name);
create index on use_proper_monotype_sort (collname );
insert into use_proper_monotype_sort values ('zh_CN'), ('ja_JP'), ('C'), ('zh_CN');
vacuum analyze use_proper_monotype_sort; -- Be tidy
-- Clearly this works (and has for a long time now):
select * from use_proper_monotype_sort c
where c.collname = any ('{zh_CN,ja_JP,C,zh_CN}');
 collname 
----------
 C
 ja_JP
 zh_CN
 zh_CN
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from use_proper_monotype_sort c
where c.collname = any ('{zh_CN,ja_JP,C,zh_CN}');
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using use_proper_monotype_sort_collname_idx on use_proper_monotype_sort c  (cost=0.13..6.18 rows=3 width=64) (actual rows=4 loops=1)
   Index Cond: (collname = ANY ('{zh_CN,ja_JP,C,zh_CN}'::name[]))
   Buffers: shared hit=2
(3 rows)

-- We should expect the same from this equivalent spelling, but that'll only
-- actually happen when it has a cross-type ORDER proc for the scan's binary
-- searches, while at the same time using a same-type "text" comparator for
-- its initial sort (cannot use the same ORDER proc for both):
select * from use_proper_monotype_sort c
where c.collname = any ('{zh_CN,ja_JP,C,zh_CN}'::text[]);
 collname 
----------
 C
 ja_JP
 zh_CN
 zh_CN
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from use_proper_monotype_sort c
where c.collname = any ('{zh_CN,ja_JP,C,zh_CN}'::text[]);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using use_proper_monotype_sort_collname_idx on use_proper_monotype_sort c  (cost=0.13..6.18 rows=3 width=64) (actual rows=4 loops=1)
   Index Cond: (collname = ANY ('{zh_CN,ja_JP,C,zh_CN}'::text[]))
   Buffers: shared hit=2
(3 rows)

-- Variant that combines the same elements of previous test case with
-- redundancy:
select * from use_proper_monotype_sort c
where c.collname = any ('{ja_JP,C}'::name[])
and c.collname = any ('{zh_CN,ja_JP,C}'::text[]);
 collname 
----------
 C
 ja_JP
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from use_proper_monotype_sort c
where c.collname = any ('{ja_JP,C}'::name[])
and c.collname = any ('{zh_CN,ja_JP,C}'::text[]);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using use_proper_monotype_sort_collname_idx on use_proper_monotype_sort c  (cost=0.13..4.17 rows=2 width=64) (actual rows=2 loops=1)
   Index Cond: ((collname = ANY ('{ja_JP,C}'::name[])) AND (collname = ANY ('{zh_CN,ja_JP,C}'::text[])))
   Buffers: shared hit=2
(3 rows)

-- Variant that combines the same elements of previous test case with
-- contradictory scan keys:
select * from use_proper_monotype_sort c
where c.collname = any ('{ja_JP,C}'::name[])
and c.collname = any ('{zh_CN}'::text[]);
 collname 
----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from use_proper_monotype_sort c
where c.collname = any ('{ja_JP,C}'::name[])
and c.collname = any ('{zh_CN}'::text[]);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using use_proper_monotype_sort_collname_idx on use_proper_monotype_sort c  (cost=0.13..4.15 rows=1 width=64) (actual rows=0 loops=1)
   Index Cond: ((collname = ANY ('{ja_JP,C}'::name[])) AND (collname = ANY ('{zh_CN}'::text[])))
(2 rows)

-- This test independently proves that merging (not just sorting) has to use
-- the same-type ORDER proc as its comparator, too
select * from use_proper_monotype_sort c
where c.collname = any ('{ja_JP,C}'::text[])
and c.collname = any ('{C,ja_JP}'::text[]);
 collname 
----------
 C
 ja_JP
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from use_proper_monotype_sort c
where c.collname = any ('{ja_JP,C}'::text[])
and c.collname = any ('{C,ja_JP}'::text[]);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using use_proper_monotype_sort_collname_idx on use_proper_monotype_sort c  (cost=0.13..4.15 rows=1 width=64) (actual rows=2 loops=1)
   Index Cond: ((collname = ANY ('{ja_JP,C}'::text[])) AND (collname = ANY ('{C,ja_JP}'::text[])))
   Buffers: shared hit=2
(3 rows)

-- (March 10) Variant that aims to make sure we use the appropriate cross-type
-- operator when non-array is considered against array in _bt_preprocess_keys
select * from use_proper_monotype_sort c
where c.collname = any ('{ja_JP,C}'::name[])
and c.collname = 'ja_JP'::text;
 collname 
----------
 ja_JP
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from use_proper_monotype_sort c
where c.collname = any ('{ja_JP,C}'::name[])
and c.collname = 'ja_JP'::text;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using use_proper_monotype_sort_collname_idx on use_proper_monotype_sort c  (cost=0.13..4.15 rows=1 width=64) (actual rows=1 loops=1)
   Index Cond: ((collname = ANY ('{ja_JP,C}'::name[])) AND (collname = 'ja_JP'::text))
   Buffers: shared hit=2
(3 rows)

-- (April 7) Post-commit assertion failure, per report from Alexander Lakhin:
-- https://postgr.es/m/0539d3d3-a402-0a49-ed5e-26429dffc4bd@gmail.com
set client_min_messages=error;
drop table if exists lakhin;
reset client_min_messages;
create unlogged table lakhin (a int, b int);
create index lakhin_idx on lakhin (a, b);
insert into lakhin (a, b) select g, g from generate_series(0, 999) g;
analyze lakhin;
select * from lakhin where a < any (array[1]) and b < any (array[1]);
 a | b 
---+---
 0 | 0
(1 row)

-- (April 18) Post-commit assertion failure, per report from Donghang Lin:
-- https://postgr.es/m/CAA=D8a2sHK6CAzZ=0CeafC-Y-MFXbYxnRSHvZTi=+JHu6kAa8Q@mail.gmail.com
set client_min_messages=error;
drop table if exists desc_assert_failure;
reset client_min_messages;
create unlogged table desc_assert_failure(a int);
insert into desc_assert_failure select 1 from generate_series(1,10);
create index on desc_assert_failure (a desc);
select * from desc_assert_failure where a IN (1,2) and a IN (1,2,3);
 a 
---
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
(10 rows)

-- (April 21) Post-commit assertion failure, per report from Richar Guo:
-- https://postgr.es/m/CAMbWs48f5rDOwxaT76Zd40m7n9iGZQcjEk7vG_5p3YWNh6oPfA@mail.gmail.com
set client_min_messages=error;
drop table if exists guo_assertion_failure;
reset client_min_messages;
create unlogged table guo_assertion_failure(c int4range);
create unique index on guo_assertion_failure (c);
select * from guo_assertion_failure where c in ('(1, 100]'::int4range, '(50, 300]'::int4range);
 c 
---
(0 rows)

-- (April 22) Post-commit assertion failure, per report from Alexander Lakhin:
-- https://postgr.es/m/ef0f7c8b-a6fa-362e-6fd6-054950f947ca@gmail.com
set client_min_messages=error;
drop table if exists lakhin_cursor;
reset client_min_messages;
create unlogged table lakhin_cursor (a text, b text);
insert into lakhin_cursor (a, b) select 'a', repeat('b', 100) from generate_series(1, 500) g;
create index lakhin_cursor_idx on lakhin_cursor using btree(a);
-- Original test case:
begin;
declare c cursor for select a from lakhin_cursor where a = 'a';
fetch from c;
 a 
---
 a
(1 row)

fetch relative 0 from c;
 a 
---
 a
(1 row)

commit;
-- Mix in a SAOP for good luck:
begin;
declare c cursor for select a from lakhin_cursor where a in ('0', 'a', 'b', 'c');
fetch from c;
 a 
---
 a
(1 row)

fetch relative 0 from c;
 a 
---
 a
(1 row)

commit;
-- Mix in a SAOP for good luck again:
begin;
declare c cursor for select a from lakhin_cursor where a in ('0', 'b', 'c');
fetch from c;
 a 
---
(0 rows)

fetch relative 0 from c;
 a 
---
(0 rows)

commit;
-- (June 20 2024)
--
-- has_required_opposite_direction_only issue with MDAM table when I allow
-- some inequalities to appear at the end of output scan keys during
-- preprocessing
--
-- Recall how the SAOP project assertion gated by this condition would fail:
--
-- "if (has_required_opposite_direction_only && pstate->finaltup &&
-- 	(all_required_satisfied || oppodir_inequality_sktrig))"
--
-- This was because "so->keyData[opsktrig].sk_strategy ==
-- BTEqualStrategyNumber", contrary to what the assertion expected
-- This was the warning I'd see when I changed the assertion into a WARNING:
--
-- WARNING:  has_required_opposite_direction_only opsktrig: 2, sktrig: 1
--
set client_min_messages=error;
drop table if exists sales_mdam_oppodir_issue;
reset client_min_messages;
create unlogged table sales_mdam_oppodir_issue
(
  dept int4,
  sdate date,
  item_class serial,
  store int4,
  item int4,
  total_sales numeric
);
create index oppodir_mdam_idx on sales_mdam_oppodir_issue(dept, sdate, item_class, store);
select setseed(0.5);
 setseed 
---------
 
(1 row)

insert into sales_mdam_oppodir_issue (dept, sdate, item_class, store, total_sales)
select
  dept,
  '1995-01-01'::date + sdate,
  item_class,
  store,
  (random() * 500.0) as total_sales
from
  generate_series(5, 7) dept,
  generate_series(1, 5) sdate,
  generate_series(1, 15) item_class,
  generate_series(1, 25) store;
prepare tenth as
select sdate, item_class, store, sum(total_sales)
from sales_mdam_oppodir_issue
where
  dept between 5 and 7
  and sdate between '1995-01-01' and '1995-01-05'
  and item_class between 1 and 15
  and store between 15 and 25
group by sdate, item_class, store;
-- Here is what the failure looked like, if I make it into an ERROR and dump
-- instrumentation up until that point:
/*
2024-06-20 13:34:35.656 EDT [1633957][client backend] [pg_regress/skip_scan][0/396:0] LOCATION:  _bt_advance_array_keys, nbtutils.c:3566
 2024-06-20 13:34:35.656 EDT [1633957][client backend] [pg_regress/skip_scan][0/396:0] STATEMENT:  execute tenth;
 2024-06-20 13:34:35.656 EDT [1633957][client backend] [pg_regress/skip_scan][0/397:0] ERROR:  XX000:
	👾  btbeginscan to begin scan of index "oppodir_mdam_idx" in worker -1
	♻️  btrescan
	btrescan: BTScanPosInvalidate() called for markPos
	_bt_preprocess_keys:  scan->keyData[0]: [ strategy: >=, attno: 1/"dept", func: int4ge, flags: [] ]
	                      scan->keyData[1]: [ strategy: <=, attno: 1/"dept", func: int4le, flags: [] ]
	                      scan->keyData[2]: [ strategy: >=, attno: 2/"sdate", func: date_ge, flags: [] ]
	                      scan->keyData[3]: [ strategy: <=, attno: 2/"sdate", func: date_le, flags: [] ]
	                      scan->keyData[4]: [ strategy: >=, attno: 3/"item_class", func: int4ge, flags: [] ]
	                      scan->keyData[5]: [ strategy: <=, attno: 3/"item_class", func: int4le, flags: [] ]
	                      scan->keyData[6]: [ strategy: >=, attno: 4/"store", func: int4ge, flags: [] ]
	                      scan->keyData[7]: [ strategy: <=, attno: 4/"store", func: int4le, flags: [] ]
	_bt_preprocess_keys:    so->keyData[0]: [ strategy: = , attno: 1/"dept", func: int4eq, flags: [SK_SEARCHARRAY, SK_BT_REQFWD, SK_BT_REQBKWD, SK_BT_SKIP] ]
	                        so->keyData[1]: [ strategy: = , attno: 2/"sdate", func: date_eq, flags: [SK_SEARCHARRAY, SK_BT_REQFWD, SK_BT_REQBKWD, SK_BT_SKIP] ]
	                        so->keyData[2]: [ strategy: = , attno: 3/"item_class", func: int4eq, flags: [SK_SEARCHARRAY, SK_BT_REQFWD, SK_BT_REQBKWD, SK_BT_SKIP] ]
	                        so->keyData[3]: [ strategy: >=, attno: 4/"store", func: int4ge, flags: [SK_BT_REQBKWD] ]
	                        so->keyData[4]: [ strategy: <=, attno: 4/"store", func: int4le, flags: [SK_BT_REQFWD] ]
	_bt_preprocess_keys: scan->numberOfKeys is 8, so->numberOfKeys on output is 5, so->numArrayKeys on output is 3

	➕     ➕     ➕
	_bt_first: sk_attno 1. val: 5, func: btint4cmp
	           sk_attno 2. val: 01-01-1995, func: date_cmp
	           sk_attno 3. val: 1, func: btint4cmp
	           sk_attno 4. val: 15, func: btint4cmp
	           with strat_total='>=', inskey.keys=4, inskey.nextkey=0, inskey.backward=0
	🔽  ==================== _bt_search begin at root 3 level 1 ====================
	_bt_moveright: blk 3 is rightmost
	_bt_search: sk > (dept, sdate, item_class, store)=(), sk <= (dept, sdate, item_class, store)=(5, 01-02-1995, 12)
	🔽  -------------------- descended to child blk 1 level 0 --------------------
	_bt_moveright: (dept, sdate, item_class, store)=(5, 01-02-1995, 12), high key no move right
	⏹️  ==================== _bt_search end ====================
	_bt_readpage: 🍀  1 with 276 offsets/tuples (leftsib 0, rightsib 19) ➡️
	 _bt_readpage first: (dept, sdate, item_class, store)=(5, 01-02-1995, 1, 1), TID='(0,1)', 0x7f4b16e65fc0, from non-pivot offnum 2 started page
	  _bt_checkkeys: comparing (dept, sdate, item_class, store)=(5, 01-02-1995, 1, 1) with TID (0,1), 0x7f4b16e65fc0
	_bt_advance_array_keys, sktrig: 1, tuple: (dept, sdate, item_class, store)=(5, 01-02-1995, 1, 1), 0x7f4b16e65fc0
	  numberOfKeys: 5

	  - sk_attno: 1, cur_elem:    0, num_elems:   -1, val: 5
	  - sk_attno: 2, cur_elem:    0, num_elems:   -1, val: 01-01-1995            <--
	  - sk_attno: 3, cur_elem:    0, num_elems:   -1, val: 1

	  + sk_attno: 1, cur_elem:    0, num_elems:   -1, val: 5
	  + sk_attno: 2, cur_elem:    0, num_elems:   -1, val: 01-02-1995
	  + sk_attno: 3, cur_elem:    0, num_elems:   -1, val: 1

	  _bt_checkkeys: comparing (dept, sdate, item_class, store)=(5, 01-02-1995, 1, 1) with TID (0,1), 0x7f4b16e65fc0
	  _bt_checkkeys: comparing (dept, sdate, item_class, store)=(5, 01-02-1995, 12) with TID -inf, 0x7f4b16e65fd8

	, has_required_opposite_direction_only opsktrig: 2, sktrig: 1
 2024-06-20 13:34:35.656 EDT [1633957][client backend] [pg_regress/skip_scan][0/397:0] LOCATION:  _bt_advance_array_keys, nbtutils.c:3566
 2024-06-20 13:34:35.656 EDT [1633957][client backend] [pg_regress/skip_scan][0/397:0] STATEMENT:  EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
	execute tenth;
*/
execute tenth;
   sdate    | item_class | store |         sum         
------------+------------+-------+---------------------
 01-02-1995 |          1 |    15 |    712.455156002685
 01-02-1995 |          1 |    16 |    931.032952712839
 01-02-1995 |          1 |    17 |   1075.966745173139
 01-02-1995 |          1 |    18 |   480.2462050412299
 01-02-1995 |          1 |    19 |   440.4997622200872
 01-02-1995 |          1 |    20 |    539.001994018469
 01-02-1995 |          1 |    21 |   918.3949569896443
 01-02-1995 |          1 |    22 |   1243.624130736671
 01-02-1995 |          1 |    23 |  718.39163017978945
 01-02-1995 |          1 |    24 |   324.7616742010412
 01-02-1995 |          1 |    25 |   1008.702965595610
 01-02-1995 |          2 |    15 |    708.544632872755
 01-02-1995 |          2 |    16 |   1215.186378998930
 01-02-1995 |          2 |    17 |   565.7026299951959
 01-02-1995 |          2 |    18 |    490.909999263379
 01-02-1995 |          2 |    19 |   1280.373749014421
 01-02-1995 |          2 |    20 |  539.90423490258349
 01-02-1995 |          2 |    21 |   964.2536927598623
 01-02-1995 |          2 |    22 |    903.814958778709
 01-02-1995 |          2 |    23 |   856.1438341002742
 01-02-1995 |          2 |    24 |    904.933351258493
 01-02-1995 |          2 |    25 |    584.040889525515
 01-02-1995 |          3 |    15 |    919.118565020666
 01-02-1995 |          3 |    16 |   1032.384217950248
 01-02-1995 |          3 |    17 |    826.997858215772
 01-02-1995 |          3 |    18 |    848.617268023107
 01-02-1995 |          3 |    19 |   1390.059100612893
 01-02-1995 |          3 |    20 |    882.771496829415
 01-02-1995 |          3 |    21 |   564.7348603251986
 01-02-1995 |          3 |    22 |  529.91223479490112
 01-02-1995 |          3 |    23 |   726.6407408407428
 01-02-1995 |          3 |    24 |   687.5682633666762
 01-02-1995 |          3 |    25 |   1018.185141068719
 01-02-1995 |          4 |    15 |  639.12408847657649
 01-02-1995 |          4 |    16 |    731.964601289625
 01-02-1995 |          4 |    17 |    999.908285019187
 01-02-1995 |          4 |    18 |   799.1016621060428
 01-02-1995 |          4 |    19 |   734.2506407227829
 01-02-1995 |          4 |    20 |   701.3897104059662
 01-02-1995 |          4 |    21 |   479.1758533107909
 01-02-1995 |          4 |    22 |   590.1666356245688
 01-02-1995 |          4 |    23 |   1206.858081159051
 01-02-1995 |          4 |    24 |    830.655916333108
 01-02-1995 |          4 |    25 |    828.613253913630
 01-02-1995 |          5 |    15 |    883.856157671578
 01-02-1995 |          5 |    16 |   532.3323606195024
 01-02-1995 |          5 |    17 |    731.108374813310
 01-02-1995 |          5 |    18 |   398.6412931459952
 01-02-1995 |          5 |    19 |   461.8880923922783
 01-02-1995 |          5 |    20 |   759.2215240992528
 01-02-1995 |          5 |    21 |   1213.779102777923
 01-02-1995 |          5 |    22 |    477.521553006073
 01-02-1995 |          5 |    23 |   1019.635426471315
 01-02-1995 |          5 |    24 |   1048.232822009054
 01-02-1995 |          5 |    25 |   1174.699031950399
 01-02-1995 |          6 |    15 |    644.518955532015
 01-02-1995 |          6 |    16 |    902.814395556265
 01-02-1995 |          6 |    17 |    755.496499347514
 01-02-1995 |          6 |    18 |    544.099673052349
 01-02-1995 |          6 |    19 |   658.9726309475083
 01-02-1995 |          6 |    20 |    945.367412035263
 01-02-1995 |          6 |    21 |   800.1880284188924
 01-02-1995 |          6 |    22 |   508.7454423762681
 01-02-1995 |          6 |    23 |    993.569028250501
 01-02-1995 |          6 |    24 |   641.8326426469614
 01-02-1995 |          6 |    25 |  1005.0630698609494
 01-02-1995 |          7 |    15 |   935.1231224583592
 01-02-1995 |          7 |    16 |   1309.097401196387
 01-02-1995 |          7 |    17 |    623.397010367172
 01-02-1995 |          7 |    18 |   1225.265675981821
 01-02-1995 |          7 |    19 |   1019.435854600906
 01-02-1995 |          7 |    20 |   582.2939355479092
 01-02-1995 |          7 |    21 |   837.4062583332249
 01-02-1995 |          7 |    22 |    883.890181772842
 01-02-1995 |          7 |    23 |    877.153748670014
 01-02-1995 |          7 |    24 |    424.262791544206
 01-02-1995 |          7 |    25 |   1132.376585003058
 01-02-1995 |          8 |    15 |   912.1368298443399
 01-02-1995 |          8 |    16 |   619.6668372430839
 01-02-1995 |          8 |    17 |   291.2941754548599
 01-02-1995 |          8 |    18 |   520.0071621164633
 01-02-1995 |          8 |    19 |   1123.269685635577
 01-02-1995 |          8 |    20 |    763.856690407651
 01-02-1995 |          8 |    21 |   938.5353391882323
 01-02-1995 |          8 |    22 |   518.4912246953697
 01-02-1995 |          8 |    23 |   1287.752981202392
 01-02-1995 |          8 |    24 |    634.901245533000
 01-02-1995 |          8 |    25 |    694.432781461532
 01-02-1995 |          9 |    15 |   347.8919791054283
 01-02-1995 |          9 |    16 |    489.318594641537
 01-02-1995 |          9 |    17 |   998.5021546642747
 01-02-1995 |          9 |    18 |   1087.528642154075
 01-02-1995 |          9 |    19 |    334.171404162593
 01-02-1995 |          9 |    20 |   1280.002241004952
 01-02-1995 |          9 |    21 |    734.438134218001
 01-02-1995 |          9 |    22 |    574.606808646402
 01-02-1995 |          9 |    23 |   1091.431804426942
 01-02-1995 |          9 |    24 |   588.7583874840026
 01-02-1995 |          9 |    25 |    889.834898276180
 01-02-1995 |         10 |    15 |   1124.110772189281
 01-02-1995 |         10 |    16 |   793.4223031936753
 01-02-1995 |         10 |    17 |   738.5065067316696
 01-02-1995 |         10 |    18 |    577.972299344497
 01-02-1995 |         10 |    19 |   1052.456329994887
 01-02-1995 |         10 |    20 |  796.43239419837864
 01-02-1995 |         10 |    21 |   1062.341931821071
 01-02-1995 |         10 |    22 |   378.0304033727635
 01-02-1995 |         10 |    23 |    616.891454150725
 01-02-1995 |         10 |    24 |   404.8485621603534
 01-02-1995 |         10 |    25 |    853.778143693656
 01-02-1995 |         11 |    15 |    731.950468324131
 01-02-1995 |         11 |    16 |   751.5542130219392
 01-02-1995 |         11 |    17 |    806.829900863646
 01-02-1995 |         11 |    18 |   671.4298093623162
 01-02-1995 |         11 |    19 |   464.1838324244147
 01-02-1995 |         11 |    20 |    859.798920632678
 01-02-1995 |         11 |    21 |   1276.371056750555
 01-02-1995 |         11 |    22 |  316.17420239502831
 01-02-1995 |         11 |    23 |   612.3888345298189
 01-02-1995 |         11 |    24 |   412.4643108181328
 01-02-1995 |         11 |    25 |   736.1898960945982
 01-02-1995 |         12 |    15 |    947.074956364320
 01-02-1995 |         12 |    16 |  244.87515357002069
 01-02-1995 |         12 |    17 |    963.657855352465
 01-02-1995 |         12 |    18 |   605.4936245509433
 01-02-1995 |         12 |    19 |   623.0886784391208
 01-02-1995 |         12 |    20 |    731.611482103201
 01-02-1995 |         12 |    21 |   1068.458224703685
 01-02-1995 |         12 |    22 |   1164.940661329681
 01-02-1995 |         12 |    23 |   598.9806128723809
 01-02-1995 |         12 |    24 |  172.74061467968936
 01-02-1995 |         12 |    25 |   1016.783864007976
 01-02-1995 |         13 |    15 |    726.983400301609
 01-02-1995 |         13 |    16 |   648.8130762983081
 01-02-1995 |         13 |    17 |    706.487396916779
 01-02-1995 |         13 |    18 |    830.997479649991
 01-02-1995 |         13 |    19 |   611.4379606791454
 01-02-1995 |         13 |    20 |   650.4963315287761
 01-02-1995 |         13 |    21 |   1104.599481215309
 01-02-1995 |         13 |    22 |  488.33811019070249
 01-02-1995 |         13 |    23 |    646.476269039467
 01-02-1995 |         13 |    24 |    816.651340805377
 01-02-1995 |         13 |    25 |   591.3200691020628
 01-02-1995 |         14 |    15 |    995.339889032993
 01-02-1995 |         14 |    16 |    968.023607011142
 01-02-1995 |         14 |    17 |   320.2888439240965
 01-02-1995 |         14 |    18 |   1135.326865338630
 01-02-1995 |         14 |    19 |   1000.511026928623
 01-02-1995 |         14 |    20 |   864.3168600052982
 01-02-1995 |         14 |    21 |   695.7344076083114
 01-02-1995 |         14 |    22 |   450.5837593112081
 01-02-1995 |         14 |    23 |    924.692893727057
 01-02-1995 |         14 |    24 |   369.6691612691873
 01-02-1995 |         14 |    25 |    998.325576555851
 01-02-1995 |         15 |    15 |   336.2142488971041
 01-02-1995 |         15 |    16 |   1087.841637622211
 01-02-1995 |         15 |    17 |   517.3040846633340
 01-02-1995 |         15 |    18 |    987.910958898650
 01-02-1995 |         15 |    19 |    814.415461535650
 01-02-1995 |         15 |    20 |  636.37013760248021
 01-02-1995 |         15 |    21 |    840.599364067316
 01-02-1995 |         15 |    22 |   486.8596302559808
 01-02-1995 |         15 |    23 |    770.189956798091
 01-02-1995 |         15 |    24 |    625.440922089641
 01-02-1995 |         15 |    25 |   399.4539118899507
 01-03-1995 |          1 |    15 |   562.4910522273588
 01-03-1995 |          1 |    16 |    928.465520703861
 01-03-1995 |          1 |    17 |    736.327392166331
 01-03-1995 |          1 |    18 |   1020.312699373185
 01-03-1995 |          1 |    19 |    963.373934686416
 01-03-1995 |          1 |    20 |   560.5599339929868
 01-03-1995 |          1 |    21 |  158.74024548370387
 01-03-1995 |          1 |    22 |   568.3646514652105
 01-03-1995 |          1 |    23 |   815.0836199395343
 01-03-1995 |          1 |    24 |    825.474053294743
 01-03-1995 |          1 |    25 |    731.813342056411
 01-03-1995 |          2 |    15 |    700.166393200826
 01-03-1995 |          2 |    16 |   637.2817840051785
 01-03-1995 |          2 |    17 |    761.382853602607
 01-03-1995 |          2 |    18 |    959.198652537115
 01-03-1995 |          2 |    19 |    790.581824208551
 01-03-1995 |          2 |    20 |   401.7513419817735
 01-03-1995 |          2 |    21 |  193.26162477321667
 01-03-1995 |          2 |    22 |   1259.842424538366
 01-03-1995 |          2 |    23 |    751.860295626757
 01-03-1995 |          2 |    24 |    982.142082489412
 01-03-1995 |          2 |    25 |   364.6938423488403
 01-03-1995 |          3 |    15 |   785.6107425078665
 01-03-1995 |          3 |    16 |   682.5800202425744
 01-03-1995 |          3 |    17 |  678.41457532060882
 01-03-1995 |          3 |    18 |   737.1317642933628
 01-03-1995 |          3 |    19 |    763.904087683445
 01-03-1995 |          3 |    20 |   218.9424490121505
 01-03-1995 |          3 |    21 |   885.3857678432654
 01-03-1995 |          3 |    22 |    734.791283390004
 01-03-1995 |          3 |    23 |   1056.463268007577
 01-03-1995 |          3 |    24 |  545.56005701827924
 01-03-1995 |          3 |    25 |   752.8474733275467
 01-03-1995 |          4 |    15 |    945.696605885784
 01-03-1995 |          4 |    16 |    790.556736675290
 01-03-1995 |          4 |    17 |   315.8899013586876
 01-03-1995 |          4 |    18 |   518.9832099870608
 01-03-1995 |          4 |    19 |   315.6945677055976
 01-03-1995 |          4 |    20 |   1105.321867096677
 01-03-1995 |          4 |    21 |   541.2373024733717
 01-03-1995 |          4 |    22 |   495.6616998813613
 01-03-1995 |          4 |    23 |    987.309639448946
 01-03-1995 |          4 |    24 |    709.179864654819
 01-03-1995 |          4 |    25 |    635.303660128209
 01-03-1995 |          5 |    15 |    859.412227141914
 01-03-1995 |          5 |    16 |   718.9463729498915
 01-03-1995 |          5 |    17 |   645.1638848739913
 01-03-1995 |          5 |    18 |    425.091680140901
 01-03-1995 |          5 |    19 |    695.869506949744
 01-03-1995 |          5 |    20 |    785.648232123792
 01-03-1995 |          5 |    21 |   545.2111064879617
 01-03-1995 |          5 |    22 |    868.893021816082
 01-03-1995 |          5 |    23 |   638.3941475122136
 01-03-1995 |          5 |    24 |   451.4377921635629
 01-03-1995 |          5 |    25 |   552.3219480849513
 01-03-1995 |          6 |    15 |   1134.899929499342
 01-03-1995 |          6 |    16 |    709.145661801683
 01-03-1995 |          6 |    17 |   574.0964166377761
 01-03-1995 |          6 |    18 |   1020.995898988323
 01-03-1995 |          6 |    19 |    860.762829267998
 01-03-1995 |          6 |    20 |   761.7941646499133
 01-03-1995 |          6 |    21 |   1042.701732011738
 01-03-1995 |          6 |    22 |   614.6796951979879
 01-03-1995 |          6 |    23 |   1327.133895552738
 01-03-1995 |          6 |    24 |    670.965716768519
 01-03-1995 |          6 |    25 |   1145.404473418426
 01-03-1995 |          7 |    15 |   455.6524780108052
 01-03-1995 |          7 |    16 |    857.775573356293
 01-03-1995 |          7 |    17 |    746.886183901742
 01-03-1995 |          7 |    18 |    716.203864803724
 01-03-1995 |          7 |    19 |    775.815248489582
 01-03-1995 |          7 |    20 |  216.51754341582553
 01-03-1995 |          7 |    21 |    941.142829488290
 01-03-1995 |          7 |    22 |   622.4947354511309
 01-03-1995 |          7 |    23 |    743.947832049115
 01-03-1995 |          7 |    24 |    892.569894634391
 01-03-1995 |          7 |    25 |    835.993535788314
 01-03-1995 |          8 |    15 |   1352.803357764101
 01-03-1995 |          8 |    16 |    916.863566700589
 01-03-1995 |          8 |    17 |   586.7375437325231
 01-03-1995 |          8 |    18 |   183.4440092756956
 01-03-1995 |          8 |    19 |    529.124962356197
 01-03-1995 |          8 |    20 |    796.838679348331
 01-03-1995 |          8 |    21 |   593.5949356089288
 01-03-1995 |          8 |    22 |   760.5077054666095
 01-03-1995 |          8 |    23 |   721.6108128676159
 01-03-1995 |          8 |    24 |    727.022651974583
 01-03-1995 |          8 |    25 |   862.3169717604842
 01-03-1995 |          9 |    15 |    988.442083663460
 01-03-1995 |          9 |    16 |   254.4094271964840
 01-03-1995 |          9 |    17 |    973.911606260981
 01-03-1995 |          9 |    18 |   1060.791384565826
 01-03-1995 |          9 |    19 |   1258.230887448613
 01-03-1995 |          9 |    20 |   1247.010104549703
 01-03-1995 |          9 |    21 |   1129.529825531373
 01-03-1995 |          9 |    22 |   960.3237222863067
 01-03-1995 |          9 |    23 |   611.5418513420179
 01-03-1995 |          9 |    24 |    985.825076947996
 01-03-1995 |          9 |    25 |   565.9800977613688
 01-03-1995 |         10 |    15 |    919.771690854994
 01-03-1995 |         10 |    16 |    684.967985856059
 01-03-1995 |         10 |    17 |   281.0534896272883
 01-03-1995 |         10 |    18 |    687.223761091582
 01-03-1995 |         10 |    19 |   553.5872277699063
 01-03-1995 |         10 |    20 |    741.437455283078
 01-03-1995 |         10 |    21 |   346.8246153146670
 01-03-1995 |         10 |    22 |   1077.517938315969
 01-03-1995 |         10 |    23 |  671.31060680151169
 01-03-1995 |         10 |    24 |    966.345356777929
 01-03-1995 |         10 |    25 |   448.9399527690762
 01-03-1995 |         11 |    15 |    858.190564351323
 01-03-1995 |         11 |    16 |    619.103008684932
 01-03-1995 |         11 |    17 |    777.112615773823
 01-03-1995 |         11 |    18 |    574.063656340926
 01-03-1995 |         11 |    19 |    988.624471803839
 01-03-1995 |         11 |    20 |   853.5443369009882
 01-03-1995 |         11 |    21 |   736.1449982443969
 01-03-1995 |         11 |    22 |    751.411454155180
 01-03-1995 |         11 |    23 |    784.897538042862
 01-03-1995 |         11 |    24 |   1069.657271606239
 01-03-1995 |         11 |    25 |   785.6364027511449
 01-03-1995 |         12 |    15 |   565.0372425218256
 01-03-1995 |         12 |    16 |   1197.433893581741
 01-03-1995 |         12 |    17 |   552.8168595129116
 01-03-1995 |         12 |    18 |   219.0489754103944
 01-03-1995 |         12 |    19 |   93.84707677405296
 01-03-1995 |         12 |    20 |    914.319689411215
 01-03-1995 |         12 |    21 |   574.5167449163978
 01-03-1995 |         12 |    22 |    809.912378183556
 01-03-1995 |         12 |    23 |  1033.8582176093215
 01-03-1995 |         12 |    24 |   800.1626370026145
 01-03-1995 |         12 |    25 |   938.0458307164358
 01-03-1995 |         13 |    15 |   1063.990936538671
 01-03-1995 |         13 |    16 |  230.38339986041317
 01-03-1995 |         13 |    17 |  468.05284552634628
 01-03-1995 |         13 |    18 |   306.4190751347108
 01-03-1995 |         13 |    19 |   655.8032193043614
 01-03-1995 |         13 |    20 |   1204.695962383664
 01-03-1995 |         13 |    21 |   1068.631779748735
 01-03-1995 |         13 |    22 |   1201.802229530740
 01-03-1995 |         13 |    23 |    771.320509294152
 01-03-1995 |         13 |    24 |   477.2442651764381
 01-03-1995 |         13 |    25 |   1095.306786970810
 01-03-1995 |         14 |    15 |    670.008443242562
 01-03-1995 |         14 |    16 |    882.411499759740
 01-03-1995 |         14 |    17 |    627.087766865459
 01-03-1995 |         14 |    18 |   915.7231167471431
 01-03-1995 |         14 |    19 |   509.1019633005082
 01-03-1995 |         14 |    20 |    875.062945508586
 01-03-1995 |         14 |    21 |   743.9930336165645
 01-03-1995 |         14 |    22 |   675.6838786097277
 01-03-1995 |         14 |    23 |   618.3949459361054
 01-03-1995 |         14 |    24 |    755.859644724799
 01-03-1995 |         14 |    25 |   468.6998989425271
 01-03-1995 |         15 |    15 |   793.0683285038261
 01-03-1995 |         15 |    16 |   1144.506091551334
 01-03-1995 |         15 |    17 |    978.762357675031
 01-03-1995 |         15 |    18 |   424.5186394990567
 01-03-1995 |         15 |    19 |    634.910105569876
 01-03-1995 |         15 |    20 |    878.243410328306
 01-03-1995 |         15 |    21 |    800.776581870625
 01-03-1995 |         15 |    22 |   1083.780159278751
 01-03-1995 |         15 |    23 |    600.895425124603
 01-03-1995 |         15 |    24 |    694.788244367821
 01-03-1995 |         15 |    25 |   887.8702959077237
 01-04-1995 |          1 |    15 |   896.9453497245253
 01-04-1995 |          1 |    16 |   561.3774781327210
 01-04-1995 |          1 |    17 |   685.5392875157378
 01-04-1995 |          1 |    18 |    978.720147688592
 01-04-1995 |          1 |    19 |   917.8616798333655
 01-04-1995 |          1 |    20 |   578.5389226364707
 01-04-1995 |          1 |    21 |   1178.656416983176
 01-04-1995 |          1 |    22 |    708.420243309025
 01-04-1995 |          1 |    23 |   519.6450298396859
 01-04-1995 |          1 |    24 |   770.6317351764194
 01-04-1995 |          1 |    25 |   500.7888820135648
 01-04-1995 |          2 |    15 |   422.1795971406379
 01-04-1995 |          2 |    16 |   395.7770615295061
 01-04-1995 |          2 |    17 |   754.3749729194034
 01-04-1995 |          2 |    18 |    744.826748919385
 01-04-1995 |          2 |    19 |   828.7966013782752
 01-04-1995 |          2 |    20 |   709.8746558948175
 01-04-1995 |          2 |    21 |  269.54668358423257
 01-04-1995 |          2 |    22 |   278.2054790305121
 01-04-1995 |          2 |    23 |   605.0296267143007
 01-04-1995 |          2 |    24 |   510.1296402539999
 01-04-1995 |          2 |    25 |   247.0077097282928
 01-04-1995 |          3 |    15 |    756.204958677129
 01-04-1995 |          3 |    16 |   555.1582448498500
 01-04-1995 |          3 |    17 |   882.6203838948481
 01-04-1995 |          3 |    18 |    994.854387907626
 01-04-1995 |          3 |    19 |    790.697270230729
 01-04-1995 |          3 |    20 |   554.3109197517755
 01-04-1995 |          3 |    21 |   666.2705371946231
 01-04-1995 |          3 |    22 |   704.4138746217333
 01-04-1995 |          3 |    23 |   477.2530947957866
 01-04-1995 |          3 |    24 |   1200.735960792456
 01-04-1995 |          3 |    25 |   283.3731273333467
 01-04-1995 |          4 |    15 |    834.090496664419
 01-04-1995 |          4 |    16 |   710.5621989588465
 01-04-1995 |          4 |    17 |    447.653088220309
 01-04-1995 |          4 |    18 |  533.86211869336342
 01-04-1995 |          4 |    19 |  327.23152771454761
 01-04-1995 |          4 |    20 |   1241.360545178003
 01-04-1995 |          4 |    21 |   787.6244221747093
 01-04-1995 |          4 |    22 |   520.4623599449948
 01-04-1995 |          4 |    23 |   740.1011362503718
 01-04-1995 |          4 |    24 |    810.735254509210
 01-04-1995 |          4 |    25 |   656.1414333789709
 01-04-1995 |          5 |    15 |    627.427437725078
 01-04-1995 |          5 |    16 |   1238.916840342970
 01-04-1995 |          5 |    17 |   643.0290467998584
 01-04-1995 |          5 |    18 |    556.895763983260
 01-04-1995 |          5 |    19 |   1021.691344632543
 01-04-1995 |          5 |    20 |    953.968617393823
 01-04-1995 |          5 |    21 |   484.3243557951126
 01-04-1995 |          5 |    22 |   317.7126089959584
 01-04-1995 |          5 |    23 |    914.540489946122
 01-04-1995 |          5 |    24 |   990.9934706323214
 01-04-1995 |          5 |    25 |   503.9177990131387
 01-04-1995 |          6 |    15 |    653.866586851304
 01-04-1995 |          6 |    16 |    557.025205434299
 01-04-1995 |          6 |    17 |    673.694295593444
 01-04-1995 |          6 |    18 |   850.0981266800433
 01-04-1995 |          6 |    19 |   382.8829956687547
 01-04-1995 |          6 |    20 |    788.579173457953
 01-04-1995 |          6 |    21 |   600.7487762792061
 01-04-1995 |          6 |    22 |    939.840683264046
 01-04-1995 |          6 |    23 |    986.809750904218
 01-04-1995 |          6 |    24 |    820.177927767882
 01-04-1995 |          6 |    25 |   1338.622944307595
 01-04-1995 |          7 |    15 |    702.608878011192
 01-04-1995 |          7 |    16 |    780.662729138014
 01-04-1995 |          7 |    17 |   633.3825276519399
 01-04-1995 |          7 |    18 |    945.613046116669
 01-04-1995 |          7 |    19 |    975.653019714585
 01-04-1995 |          7 |    20 |    707.090750548172
 01-04-1995 |          7 |    21 |  606.44698009043061
 01-04-1995 |          7 |    22 |    815.497217066797
 01-04-1995 |          7 |    23 |    880.737524298885
 01-04-1995 |          7 |    24 |   270.5642676939085
 01-04-1995 |          7 |    25 |   883.5352129372067
 01-04-1995 |          8 |    15 |   607.6547362727671
 01-04-1995 |          8 |    16 |    876.031668138835
 01-04-1995 |          8 |    17 |   824.9741298588717
 01-04-1995 |          8 |    18 |    777.221261735637
 01-04-1995 |          8 |    19 |   780.8500476834398
 01-04-1995 |          8 |    20 |   591.8310877334709
 01-04-1995 |          8 |    21 |    851.759105166377
 01-04-1995 |          8 |    22 |    891.935077791320
 01-04-1995 |          8 |    23 |   660.3074396606883
 01-04-1995 |          8 |    24 |   609.3947901639373
 01-04-1995 |          8 |    25 |   656.4220025322074
 01-04-1995 |          9 |    15 |  265.83594521271419
 01-04-1995 |          9 |    16 |   345.8648935729765
 01-04-1995 |          9 |    17 |    972.253336600130
 01-04-1995 |          9 |    18 |   1107.122229538127
 01-04-1995 |          9 |    19 |   948.4665387485546
 01-04-1995 |          9 |    20 |    851.246697378723
 01-04-1995 |          9 |    21 |   526.7453105785178
 01-04-1995 |          9 |    22 |   586.3314831909894
 01-04-1995 |          9 |    23 |   1080.051016701516
 01-04-1995 |          9 |    24 |   1024.809061864848
 01-04-1995 |          9 |    25 |   1003.162385059292
 01-04-1995 |         10 |    15 |   597.5736894255952
 01-04-1995 |         10 |    16 |   1006.845331097525
 01-04-1995 |         10 |    17 |   278.0672134132829
 01-04-1995 |         10 |    18 |    855.247618216417
 01-04-1995 |         10 |    19 |    902.459439603830
 01-04-1995 |         10 |    20 |   229.9027158844624
 01-04-1995 |         10 |    21 |   736.8024080081342
 01-04-1995 |         10 |    22 |   1021.443307440659
 01-04-1995 |         10 |    23 |    746.336414434414
 01-04-1995 |         10 |    24 |    801.306647167463
 01-04-1995 |         10 |    25 |    380.148771391858
 01-04-1995 |         11 |    15 |   739.4149073157859
 01-04-1995 |         11 |    16 |   938.2284975413306
 01-04-1995 |         11 |    17 | 188.025210091537422
 01-04-1995 |         11 |    18 |    693.553200034499
 01-04-1995 |         11 |    19 |    664.582666544095
 01-04-1995 |         11 |    20 |   578.1904335405114
 01-04-1995 |         11 |    21 |   604.2093328960216
 01-04-1995 |         11 |    22 |    954.098561454266
 01-04-1995 |         11 |    23 |   283.5482704147806
 01-04-1995 |         11 |    24 |    833.606057390289
 01-04-1995 |         11 |    25 |   1065.305649590139
 01-04-1995 |         12 |    15 |    710.128953415466
 01-04-1995 |         12 |    16 |    701.908934517289
 01-04-1995 |         12 |    17 |    640.380475589371
 01-04-1995 |         12 |    18 |   257.6844960758554
 01-04-1995 |         12 |    19 |   428.4005766884637
 01-04-1995 |         12 |    20 |    902.434837199875
 01-04-1995 |         12 |    21 |   527.9258394795481
 01-04-1995 |         12 |    22 |  453.80822275617146
 01-04-1995 |         12 |    23 |   733.1288937449176
 01-04-1995 |         12 |    24 |   848.2065660390006
 01-04-1995 |         12 |    25 |   695.6826704949865
 01-04-1995 |         13 |    15 |   1227.645938154597
 01-04-1995 |         13 |    16 |    968.331706353141
 01-04-1995 |         13 |    17 |    663.632924953175
 01-04-1995 |         13 |    18 |    960.475248257171
 01-04-1995 |         13 |    19 |   492.8594177788272
 01-04-1995 |         13 |    20 |   1024.769106388499
 01-04-1995 |         13 |    21 |    833.587079912508
 01-04-1995 |         13 |    22 |    951.511966155698
 01-04-1995 |         13 |    23 |   1103.773386510636
 01-04-1995 |         13 |    24 |    829.593472336973
 01-04-1995 |         13 |    25 |    798.778973411257
 01-04-1995 |         14 |    15 |   753.0091217194125
 01-04-1995 |         14 |    16 |   1085.251713475172
 01-04-1995 |         14 |    17 |    809.811689769770
 01-04-1995 |         14 |    18 |    687.313966869380
 01-04-1995 |         14 |    19 |   750.5642075132582
 01-04-1995 |         14 |    20 |    704.632686151373
 01-04-1995 |         14 |    21 |    590.086281444132
 01-04-1995 |         14 |    22 |    992.680403711105
 01-04-1995 |         14 |    23 |   530.7097988123088
 01-04-1995 |         14 |    24 |   365.2819957936212
 01-04-1995 |         14 |    25 |   1135.552637043715
 01-04-1995 |         15 |    15 |   1104.006953570154
 01-04-1995 |         15 |    16 |    923.373856967196
 01-04-1995 |         15 |    17 |   523.5219011269281
 01-04-1995 |         15 |    18 |  257.61952861053035
 01-04-1995 |         15 |    19 |    840.196645950283
 01-04-1995 |         15 |    20 |   614.3326536267029
 01-04-1995 |         15 |    21 |   639.3858907350889
 01-04-1995 |         15 |    22 |    969.166842176874
 01-04-1995 |         15 |    23 |   778.8516163014654
 01-04-1995 |         15 |    24 |    671.690022760797
 01-04-1995 |         15 |    25 |   626.4795930184212
 01-05-1995 |          1 |    15 |   888.2143320498493
 01-05-1995 |          1 |    16 |   511.7011247790197
 01-05-1995 |          1 |    17 |    889.735312366279
 01-05-1995 |          1 |    18 |  547.71864121557742
 01-05-1995 |          1 |    19 |    967.269278658225
 01-05-1995 |          1 |    20 |    952.755250959224
 01-05-1995 |          1 |    21 |    730.853034214953
 01-05-1995 |          1 |    22 |   925.7570965670778
 01-05-1995 |          1 |    23 |   1020.953863455744
 01-05-1995 |          1 |    24 |   1088.427168140005
 01-05-1995 |          1 |    25 |   1013.095173806309
 01-05-1995 |          2 |    15 |   1040.521710338475
 01-05-1995 |          2 |    16 |   1013.731383042811
 01-05-1995 |          2 |    17 |   709.9038778540073
 01-05-1995 |          2 |    18 |   662.0810722321435
 01-05-1995 |          2 |    19 |    788.455308428616
 01-05-1995 |          2 |    20 |    749.629014053118
 01-05-1995 |          2 |    21 |    719.494073090629
 01-05-1995 |          2 |    22 |    913.096140839334
 01-05-1995 |          2 |    23 |    597.772605897717
 01-05-1995 |          2 |    24 |    918.663993727655
 01-05-1995 |          2 |    25 |   509.1917963112634
 01-05-1995 |          3 |    15 |   778.2877762365003
 01-05-1995 |          3 |    16 |   586.3446485239147
 01-05-1995 |          3 |    17 |   597.9892836298322
 01-05-1995 |          3 |    18 |  292.59120661256002
 01-05-1995 |          3 |    19 |    81.9313197596127
 01-05-1995 |          3 |    20 |   352.3761607681822
 01-05-1995 |          3 |    21 |    640.997108407599
 01-05-1995 |          3 |    22 |    722.963203976512
 01-05-1995 |          3 |    23 |    899.715361925107
 01-05-1995 |          3 |    24 |   546.9935409473667
 01-05-1995 |          3 |    25 |   568.0031712425243
 01-05-1995 |          4 |    15 |   475.9670698998402
 01-05-1995 |          4 |    16 |   1088.526918522532
 01-05-1995 |          4 |    17 |   1085.685218604059
 01-05-1995 |          4 |    18 |   1135.686257425647
 01-05-1995 |          4 |    19 |   439.1517390971868
 01-05-1995 |          4 |    20 |   291.5943234505634
 01-05-1995 |          4 |    21 |  1011.4637936091086
 01-05-1995 |          4 |    22 |    736.503734969644
 01-05-1995 |          4 |    23 |    897.596085476497
 01-05-1995 |          4 |    24 |   517.6146303433233
 01-05-1995 |          4 |    25 |   435.0413046772442
 01-05-1995 |          5 |    15 |    744.266054489105
 01-05-1995 |          5 |    16 |   322.9308948599552
 01-05-1995 |          5 |    17 |   199.3356325362687
 01-05-1995 |          5 |    18 |   799.7157691837961
 01-05-1995 |          5 |    19 |   877.7077003544146
 01-05-1995 |          5 |    20 |   370.8988514504218
 01-05-1995 |          5 |    21 |   1046.306486376126
 01-05-1995 |          5 |    22 |   648.8359431608909
 01-05-1995 |          5 |    23 |   484.1385223107162
 01-05-1995 |          5 |    24 |   660.7397696312004
 01-05-1995 |          5 |    25 |    762.741133423305
 01-05-1995 |          6 |    15 |   837.3041845203566
 01-05-1995 |          6 |    16 |   707.2463663466199
 01-05-1995 |          6 |    17 |    918.381678276942
 01-05-1995 |          6 |    18 |    726.944091559952
 01-05-1995 |          6 |    19 |    840.209019686015
 01-05-1995 |          6 |    20 |   363.8183540487736
 01-05-1995 |          6 |    21 |   1118.314240839085
 01-05-1995 |          6 |    22 |    703.719867411253
 01-05-1995 |          6 |    23 |    877.322652599278
 01-05-1995 |          6 |    24 |    721.382470399002
 01-05-1995 |          6 |    25 |   176.0104597814708
 01-05-1995 |          7 |    15 |    806.451570437110
 01-05-1995 |          7 |    16 |   1346.828794994548
 01-05-1995 |          7 |    17 |   618.3551567409882
 01-05-1995 |          7 |    18 |    553.222300825879
 01-05-1995 |          7 |    19 |   225.1142148015535
 01-05-1995 |          7 |    20 |    865.277762103799
 01-05-1995 |          7 |    21 |   657.3897088733282
 01-05-1995 |          7 |    22 |    759.008915753481
 01-05-1995 |          7 |    23 |    746.253026230462
 01-05-1995 |          7 |    24 |   822.0054885196799
 01-05-1995 |          7 |    25 |    868.634294880130
 01-05-1995 |          8 |    15 |   906.5593892673011
 01-05-1995 |          8 |    16 |    861.942835299162
 01-05-1995 |          8 |    17 |   785.2281536697145
 01-05-1995 |          8 |    18 |   1009.630674723363
 01-05-1995 |          8 |    19 |    915.467753879672
 01-05-1995 |          8 |    20 |   847.4691091620499
 01-05-1995 |          8 |    21 |    699.765095369451
 01-05-1995 |          8 |    22 |   1019.840709702122
 01-05-1995 |          8 |    23 |   1223.947323385453
 01-05-1995 |          8 |    24 |   309.0981082403727
 01-05-1995 |          8 |    25 |   546.3201495504033
 01-05-1995 |          9 |    15 |    839.014544932238
 01-05-1995 |          9 |    16 |    918.240081730936
 01-05-1995 |          9 |    17 |  1020.0893656954469
 01-05-1995 |          9 |    18 |    455.527434539945
 01-05-1995 |          9 |    19 |    983.308257792102
 01-05-1995 |          9 |    20 |    960.741687654806
 01-05-1995 |          9 |    21 |   1073.777965617293
 01-05-1995 |          9 |    22 |   595.0260754387292
 01-05-1995 |          9 |    23 |   576.0630073512783
 01-05-1995 |          9 |    24 |    790.021714040001
 01-05-1995 |          9 |    25 |   1152.194108146839
 01-05-1995 |         10 |    15 |    723.456751998827
 01-05-1995 |         10 |    16 |    893.872978100514
 01-05-1995 |         10 |    17 |    424.181075144962
 01-05-1995 |         10 |    18 |   631.0435868348350
 01-05-1995 |         10 |    19 |   627.1084159694051
 01-05-1995 |         10 |    20 |    825.240510038054
 01-05-1995 |         10 |    21 |    940.676216778784
 01-05-1995 |         10 |    22 |   531.9640874675150
 01-05-1995 |         10 |    23 |    877.127167183462
 01-05-1995 |         10 |    24 |    737.867335945291
 01-05-1995 |         10 |    25 |    765.647745314808
 01-05-1995 |         11 |    15 |   732.6541978356433
 01-05-1995 |         11 |    16 |    764.092078356430
 01-05-1995 |         11 |    17 |   1170.033394270456
 01-05-1995 |         11 |    18 |   553.7891560317988
 01-05-1995 |         11 |    19 |    693.973161044351
 01-05-1995 |         11 |    20 |    651.213936977664
 01-05-1995 |         11 |    21 |   782.3860666832352
 01-05-1995 |         11 |    22 |    750.430006210216
 01-05-1995 |         11 |    23 |   1026.263460414859
 01-05-1995 |         11 |    24 |    671.577767672157
 01-05-1995 |         11 |    25 |   942.9525484863094
 01-05-1995 |         12 |    15 |    756.439868662985
 01-05-1995 |         12 |    16 |    908.682400565125
 01-05-1995 |         12 |    17 |   515.2933640191049
 01-05-1995 |         12 |    18 |    596.275557579002
 01-05-1995 |         12 |    19 |   1211.691535987299
 01-05-1995 |         12 |    20 |   460.9540735976003
 01-05-1995 |         12 |    21 |   458.2072026633129
 01-05-1995 |         12 |    22 |  691.51572642608657
 01-05-1995 |         12 |    23 |   1100.005707835101
 01-05-1995 |         12 |    24 |   453.9051203757893
 01-05-1995 |         12 |    25 |    803.717981595903
 01-05-1995 |         13 |    15 |   817.2767903183407
 01-05-1995 |         13 |    16 |   1035.150677911142
 01-05-1995 |         13 |    17 |   583.8839129446665
 01-05-1995 |         13 |    18 |   326.9085787307384
 01-05-1995 |         13 |    19 |   368.1458941702712
 01-05-1995 |         13 |    20 |    888.166673294365
 01-05-1995 |         13 |    21 |   533.2536626324772
 01-05-1995 |         13 |    22 |   663.3153823693378
 01-05-1995 |         13 |    23 |   1016.624924289561
 01-05-1995 |         13 |    24 |   793.9740204464238
 01-05-1995 |         13 |    25 |    386.615080536907
 01-05-1995 |         14 |    15 |   307.8439620045240
 01-05-1995 |         14 |    16 |    911.162380053834
 01-05-1995 |         14 |    17 |    725.143890964411
 01-05-1995 |         14 |    18 |   632.0559958706307
 01-05-1995 |         14 |    19 |   776.6095586048428
 01-05-1995 |         14 |    20 |   523.9801436660183
 01-05-1995 |         14 |    21 |   409.7194000730824
 01-05-1995 |         14 |    22 |    802.347926420369
 01-05-1995 |         14 |    23 |   1007.094414790309
 01-05-1995 |         14 |    24 |    753.247993526966
 01-05-1995 |         14 |    25 |   680.2499477173768
 01-05-1995 |         15 |    15 |   1109.035059339814
 01-05-1995 |         15 |    16 |    963.339373024521
 01-05-1995 |         15 |    17 |    809.768600508353
 01-05-1995 |         15 |    18 |   1020.505201972747
 01-05-1995 |         15 |    19 |    437.865666769090
 01-05-1995 |         15 |    20 |    941.491962262963
 01-05-1995 |         15 |    21 |    907.957278458833
 01-05-1995 |         15 |    22 |    946.322562720606
 01-05-1995 |         15 |    23 |    787.195067842115
 01-05-1995 |         15 |    24 |  809.38210671447849
 01-05-1995 |         15 |    25 |    784.253377419485
(660 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute tenth;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=4.83..4.86 rows=1 width=44) (actual rows=660 loops=1)
   Group Key: sdate, item_class, store
   Buffers: shared hit=2012
   ->  Sort  (cost=4.83..4.83 rows=1 width=44) (actual rows=1980 loops=1)
         Sort Key: sdate, item_class, store
         Sort Method: quicksort  Memory: 129kB
         Buffers: shared hit=2012
         ->  Index Scan using oppodir_mdam_idx on sales_mdam_oppodir_issue  (cost=0.28..4.82 rows=1 width=44) (actual rows=1980 loops=1)
               Index Cond: ((dept >= 5) AND (dept <= 7) AND (sdate >= '01-01-1995'::date) AND (sdate <= '01-05-1995'::date) AND (item_class >= 1) AND (item_class <= 15) AND (store >= 15) AND (store <= 25))
               Buffers: shared hit=2012
(10 rows)

deallocate tenth;
-- (June 20)
--
-- This simplified variant doesn't even require the use of skip arrays.  It
-- exposed a bug on HEAD.
prepare simplied_tenth_no_skipping as
select
  dept,
  sdate,
  item_class,
  store,
  total_sales
from
  sales_mdam_oppodir_issue
where
  dept = 5
  and sdate in ('0001-01-01', '1995-01-02')
  and item_class = 1
  and store >= 555555
  order by dept, sdate, item_class, store;
execute simplied_tenth_no_skipping;
 dept | sdate | item_class | store | total_sales 
------+-------+------------+-------+-------------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute simplied_tenth_no_skipping;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Index Scan using oppodir_mdam_idx on sales_mdam_oppodir_issue  (cost=0.28..6.61 rows=1 width=48) (actual rows=0 loops=1)
   Index Cond: ((dept = 5) AND (sdate = ANY ('{01-01-0001,01-02-1995}'::date[])) AND (item_class = 1) AND (store >= 555555))
   Buffers: shared hit=2
(3 rows)

deallocate simplied_tenth_no_skipping;
-- (August 26 2024) Post-commit assertion failure, per another report from Alexander Lakhin:
-- https://postgr.es/m/6c68ac42-bbb5-8b24-103e-af0e279c536f@gmail.com
set enable_sort = off;
select conname
from pg_constraint
where conname in ('pkey', 'id')
order by conname desc;
 conname 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, COSTS OFF, TIMING OFF, SUMMARY OFF)
select conname
from pg_constraint
where conname in ('pkey', 'id')
order by conname desc;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Index Scan Backward using pg_constraint_conname_nsp_index on pg_constraint (actual rows=0 loops=1)
   Index Cond: (conname = ANY ('{pkey,id}'::name[]))
   Buffers: shared hit=4
(3 rows)

-- (October 29 2024) Post-commit bug with cursor that changes direction,
-- discovered after largely unrelated nbtree backwards scan optimization and
-- refactoring work
--
-- https://postgr.es/m/CAH2-Wznv49bFsE2jkt4GuZ0tU2C91dEST=50egzjY2FeOcHL4Q@mail.gmail.com
-- Setup:
set client_min_messages=error;
drop table if exists btfirst_array_confusion_test;
reset client_min_messages;
create unlogged table btfirst_array_confusion_test(
  district int4,
  warehouse int4,
  orderid int4,
  orderline int4
);
create index btfirst_array_confusion_test_idx
            on
            btfirst_array_confusion_test(district, warehouse, orderid, orderline) with (fillfactor = 30);
-- Load:
insert into btfirst_array_confusion_test
select district, warehouse, orderid, orderline
from
  generate_series(1, 2) district,
  generate_series(1, 5) warehouse,
  generate_series(1, 10) orderid,
  generate_series(1, 10) orderline
order by
district, warehouse, orderid, orderline;
-- This is :rootitems, just to avoid test regressions:
select itemoffset, ctid, itemlen, nulls from bt_page_items('btfirst_array_confusion_test_idx',
  (select fastroot::int4 from bt_metap('btfirst_array_confusion_test_idx')));
 itemoffset |  ctid  | itemlen | nulls 
------------+--------+---------+-------
          1 | (1,0)  |       8 | f
          2 | (2,2)  |      16 | f
          3 | (4,2)  |      16 | f
          4 | (5,2)  |      16 | f
          5 | (6,2)  |      16 | f
          6 | (7,1)  |      16 | f
          7 | (8,2)  |      16 | f
          8 | (9,2)  |      16 | f
          9 | (10,2) |      16 | f
(9 rows)

-- pg@regression:5432 [309395]=# :rootitems
-- ┌────────────┬────────┬─────────┬───────┬──────┬──────────────────────────────────────────────────┬──────┬──────┬──────┐
-- │ itemoffset │  ctid  │ itemlen │ nulls │ vars │                       data                       │ dead │ htid │ tids │
-- ├────────────┼────────┼─────────┼───────┼──────┼──────────────────────────────────────────────────┼──────┼──────┼──────┤
-- │          1 │ (1,0)  │       8 │ f     │ f    │ (district, warehouse, orderid, orderline)=()     │ ∅    │ ∅    │ ∅    │
-- │          2 │ (2,2)  │      16 │ f     │ f    │ (district, warehouse, orderid, orderline)=(1, 2) │ ∅    │ ∅    │ ∅    │
-- │          3 │ (4,2)  │      16 │ f     │ f    │ (district, warehouse, orderid, orderline)=(1, 3) │ ∅    │ ∅    │ ∅    │
-- │          4 │ (5,2)  │      16 │ f     │ f    │ (district, warehouse, orderid, orderline)=(1, 4) │ ∅    │ ∅    │ ∅    │
-- │          5 │ (6,2)  │      16 │ f     │ f    │ (district, warehouse, orderid, orderline)=(1, 5) │ ∅    │ ∅    │ ∅    │
-- │          6 │ (7,1)  │      16 │ f     │ f    │ (district, warehouse, orderid, orderline)=(2)    │ ∅    │ ∅    │ ∅    │
-- │          7 │ (8,2)  │      16 │ f     │ f    │ (district, warehouse, orderid, orderline)=(2, 2) │ ∅    │ ∅    │ ∅    │
-- │          8 │ (9,2)  │      16 │ f     │ f    │ (district, warehouse, orderid, orderline)=(2, 3) │ ∅    │ ∅    │ ∅    │
-- │          9 │ (10,2) │      16 │ f     │ f    │ (district, warehouse, orderid, orderline)=(2, 4) │ ∅    │ ∅    │ ∅    │
-- └────────────┴────────┴─────────┴───────┴──────┴──────────────────────────────────────────────────┴──────┴──────┴──────┘
-- (9 rows)
--
-- Importantly, this test case involves cursor scrolling confined to this leaf
-- page (once bug is fixed this is what we expect):
--
-- 	_bt_readpage: 🍀  1 with 101 offsets/tuples (leftsib 0, rightsib 2) ➡️
--	 _bt_readpage first: (district, warehouse, orderid, orderline)=(1, 1, 9, 1), TID='(0,81)', 0x7f91ea04b848, from non-pivot offnum 82 started page
--	 _bt_advance_array_keys, sktrig: 2, tuple: (district, warehouse, orderid, orderline)=(1, 1, 10, 1), 0x7f91ea04b758
-- Index scan without materialization for cursor query:
set enable_seqscan to off;
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
set work_mem = 64;
set enable_sort = off;
begin;
declare btfirst_array_confusion_test_cursor cursor for
select * from btfirst_array_confusion_test
where district in (1, 2) and warehouse = 1 and orderid = 9
order by district, warehouse, orderid, orderline;
-- Fetch all 10 orderlines for the first order returned by cursor, so that we
-- read all relevant index tuples from the first leaf page read, and so leave
-- so->currPos.itemIndex right at the end of the page (not one before or one after the
-- end; precisely at the boundaries between two adjoining pages):
fetch forward 10 from btfirst_array_confusion_test_cursor;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         1 |       9 |         1
        1 |         1 |       9 |         2
        1 |         1 |       9 |         3
        1 |         1 |       9 |         4
        1 |         1 |       9 |         5
        1 |         1 |       9 |         6
        1 |         1 |       9 |         7
        1 |         1 |       9 |         8
        1 |         1 |       9 |         9
        1 |         1 |       9 |        10
(10 rows)

-- Fetch 9 orderlines before the last one returned by previous fetch
-- (_bt_first confusion happens here when run against buggy server, as
-- evidenced by this statement returning 10 rows rather than just 9):
fetch backward 10 from btfirst_array_confusion_test_cursor; -- returns an extra row with bug
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         1 |       9 |         9
        1 |         1 |       9 |         8
        1 |         1 |       9 |         7
        1 |         1 |       9 |         6
        1 |         1 |       9 |         5
        1 |         1 |       9 |         4
        1 |         1 |       9 |         3
        1 |         1 |       9 |         2
        1 |         1 |       9 |         1
(9 rows)

-- Note: _bt_first becoming confused by the prior fetch statement relies on
-- the fact that the page we almost (but didn't quite) move right from is also
-- the first page visited by the entire top-level index scan for the cursor.
-- This is a necessary condition, since we don't try to call _bt_first again
-- when the scan direction changes unless the scan direction changes on the
-- first page for the top-level scan.
-- Repeat the first fetch, expect the same 10 order + orderline rows as with
-- the first fetch (but don't get them with buggy server with confused array
-- state following previous fetch):
fetch forward 10 from btfirst_array_confusion_test_cursor; -- returns no rows with bug
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         1 |       9 |         1
        1 |         1 |       9 |         2
        1 |         1 |       9 |         3
        1 |         1 |       9 |         4
        1 |         1 |       9 |         5
        1 |         1 |       9 |         6
        1 |         1 |       9 |         7
        1 |         1 |       9 |         8
        1 |         1 |       9 |         9
        1 |         1 |       9 |        10
(10 rows)

/* btfirst_array_confusion_test_cursor */ commit;
-- (December 18, 2024)
--
-- This revealed a bug on HEAD, where so->scanBehind wasn't reset on an
-- !sktrigrequired call to _bt_advance_array_keys, meaning that we denied
-- the _bt_check_compare recheck call the opportunity to return 'true'.
--
-- See: https://postgr.es/m/CAH2-WzkJKncfqyAUTeuB5GgRhT1vhsWO2q11dbZNqKmvjopP_g@mail.gmail.com
set client_min_messages=error;
drop table if exists dec_bug_test;
reset client_min_messages;
create unlogged table dec_bug_test(
  leading_singleval int4,
  second_twovals int4,
  inequal_one_ten_range int4,
  nonrequired_equal_one_ten_range int4
);
create index dec_bug_test_idx on dec_bug_test(leading_singleval, second_twovals, inequal_one_ten_range, nonrequired_equal_one_ten_range) with (fillfactor = 30);
insert into dec_bug_test
select leading_singleval, second_twovals, inequal_one_ten_range, nonrequired_equal_one_ten_range
from
  generate_series(1, 1) leading_singleval,
  generate_series(1, 5) second_twovals,
  generate_series(1, 10) inequal_one_ten_range,
  generate_series(1, 10) nonrequired_equal_one_ten_range
order by
leading_singleval,
second_twovals,
inequal_one_ten_range,
nonrequired_equal_one_ten_range;
-- prewarm
select count(*) from dec_bug_test;
 count 
-------
   500
(1 row)

vacuum analyze dec_bug_test;
---------------------------------------------------------------------------------
-- Index scan
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_seqscan to off;
set enable_indexscan to on;
prepare dec_bug_test_qry as
select * from dec_bug_test
where
leading_singleval = 1
  and second_twovals in (1, 2)
  and inequal_one_ten_range <= 10
  and nonrequired_equal_one_ten_range in (1, 2)
order by
  leading_singleval,
  second_twovals,
  inequal_one_ten_range,
  nonrequired_equal_one_ten_range;
set skipscan_prefix_cols = 0; -- don't allow skip scan patch to suppress coverage of issue
ERROR:  unrecognized configuration parameter "skipscan_prefix_cols"
execute dec_bug_test_qry;
 leading_singleval | second_twovals | inequal_one_ten_range | nonrequired_equal_one_ten_range 
-------------------+----------------+-----------------------+---------------------------------
                 1 |              1 |                     1 |                               1
                 1 |              1 |                     1 |                               2
                 1 |              1 |                     2 |                               1
                 1 |              1 |                     2 |                               2
                 1 |              1 |                     3 |                               1
                 1 |              1 |                     3 |                               2
                 1 |              1 |                     4 |                               1
                 1 |              1 |                     4 |                               2
                 1 |              1 |                     5 |                               1
                 1 |              1 |                     5 |                               2
                 1 |              1 |                     6 |                               1
                 1 |              1 |                     6 |                               2
                 1 |              1 |                     7 |                               1
                 1 |              1 |                     7 |                               2
                 1 |              1 |                     8 |                               1
                 1 |              1 |                     8 |                               2
                 1 |              1 |                     9 |                               1
                 1 |              1 |                     9 |                               2
                 1 |              1 |                    10 |                               1
                 1 |              1 |                    10 |                               2
                 1 |              2 |                     1 |                               1
                 1 |              2 |                     1 |                               2
                 1 |              2 |                     2 |                               1
                 1 |              2 |                     2 |                               2
                 1 |              2 |                     3 |                               1
                 1 |              2 |                     3 |                               2
                 1 |              2 |                     4 |                               1
                 1 |              2 |                     4 |                               2
                 1 |              2 |                     5 |                               1
                 1 |              2 |                     5 |                               2
                 1 |              2 |                     6 |                               1
                 1 |              2 |                     6 |                               2
                 1 |              2 |                     7 |                               1
                 1 |              2 |                     7 |                               2
                 1 |              2 |                     8 |                               1
                 1 |              2 |                     8 |                               2
                 1 |              2 |                     9 |                               1
                 1 |              2 |                     9 |                               2
                 1 |              2 |                    10 |                               1
                 1 |              2 |                    10 |                               2
(40 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute dec_bug_test_qry;
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using dec_bug_test_idx on dec_bug_test  (cost=0.27..13.70 rows=40 width=16) (actual rows=40 loops=1)
   Index Cond: ((leading_singleval = 1) AND (second_twovals = ANY ('{1,2}'::integer[])) AND (inequal_one_ten_range <= 10) AND (nonrequired_equal_one_ten_range = ANY ('{1,2}'::integer[])))
   Buffers: shared hit=5
(3 rows)

reset skipscan_prefix_cols; -- now do it again, this time with skip scan enabled
ERROR:  unrecognized configuration parameter "skipscan_prefix_cols"
execute dec_bug_test_qry;
 leading_singleval | second_twovals | inequal_one_ten_range | nonrequired_equal_one_ten_range 
-------------------+----------------+-----------------------+---------------------------------
                 1 |              1 |                     1 |                               1
                 1 |              1 |                     1 |                               2
                 1 |              1 |                     2 |                               1
                 1 |              1 |                     2 |                               2
                 1 |              1 |                     3 |                               1
                 1 |              1 |                     3 |                               2
                 1 |              1 |                     4 |                               1
                 1 |              1 |                     4 |                               2
                 1 |              1 |                     5 |                               1
                 1 |              1 |                     5 |                               2
                 1 |              1 |                     6 |                               1
                 1 |              1 |                     6 |                               2
                 1 |              1 |                     7 |                               1
                 1 |              1 |                     7 |                               2
                 1 |              1 |                     8 |                               1
                 1 |              1 |                     8 |                               2
                 1 |              1 |                     9 |                               1
                 1 |              1 |                     9 |                               2
                 1 |              1 |                    10 |                               1
                 1 |              1 |                    10 |                               2
                 1 |              2 |                     1 |                               1
                 1 |              2 |                     1 |                               2
                 1 |              2 |                     2 |                               1
                 1 |              2 |                     2 |                               2
                 1 |              2 |                     3 |                               1
                 1 |              2 |                     3 |                               2
                 1 |              2 |                     4 |                               1
                 1 |              2 |                     4 |                               2
                 1 |              2 |                     5 |                               1
                 1 |              2 |                     5 |                               2
                 1 |              2 |                     6 |                               1
                 1 |              2 |                     6 |                               2
                 1 |              2 |                     7 |                               1
                 1 |              2 |                     7 |                               2
                 1 |              2 |                     8 |                               1
                 1 |              2 |                     8 |                               2
                 1 |              2 |                     9 |                               1
                 1 |              2 |                     9 |                               2
                 1 |              2 |                    10 |                               1
                 1 |              2 |                    10 |                               2
(40 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute dec_bug_test_qry;
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using dec_bug_test_idx on dec_bug_test  (cost=0.27..13.70 rows=40 width=16) (actual rows=40 loops=1)
   Index Cond: ((leading_singleval = 1) AND (second_twovals = ANY ('{1,2}'::integer[])) AND (inequal_one_ten_range <= 10) AND (nonrequired_equal_one_ten_range = ANY ('{1,2}'::integer[])))
   Buffers: shared hit=5
(3 rows)

deallocate dec_bug_test_qry;
-- (January 20 2025) RowCompare unsatisfiable qual + NULL test
--
-- Per https://postgr.es/m/CAH2-WzmySVXst2hFrOATC-zw1Byg1XC-jYUS314=mzuqsNwk+Q@mail.gmail.com
set client_min_messages=error;
drop table if exists rowcompare_test;
reset client_min_messages;
create unlogged table rowcompare_test as
select i as first, i as second, i as third
from generate_series(1, 100) i;
create index on rowcompare_test (first, second, third);
-- Usable-by-_bt_first (also required) RowCompare key case:
select *
from rowcompare_test
where first = 1 and (second, third) > (null, 0);
 first | second | third 
-------+--------+-------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from rowcompare_test
where first = 1 and (second, third) > (null, 0);
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using rowcompare_test_first_second_third_idx on rowcompare_test  (cost=0.14..4.16 rows=1 width=12) (actual rows=0 loops=1)
   Index Cond: ((first = 1) AND (ROW(second, third) > ROW(NULL::integer, 0)))
(2 rows)

-- Not-usable-by-_bt_first (also non-required) RowCompare key case:
select *
from rowcompare_test
where (second, third) > (null, 0);
 first | second | third 
-------+--------+-------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from rowcompare_test
where (second, third) > (null, 0);
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using rowcompare_test_first_second_third_idx on rowcompare_test  (cost=0.14..6.90 rows=1 width=12) (actual rows=0 loops=1)
   Index Cond: (ROW(second, third) > ROW(NULL::integer, 0))
(2 rows)

