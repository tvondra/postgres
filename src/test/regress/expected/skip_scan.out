set work_mem='100MB';
set effective_cache_size='24GB';
set random_page_cost=2.0;
set track_io_timing to off;
set enable_seqscan to off;
set client_min_messages=error;
-- set skipscan_skipsupport_enabled=false;
-- set skipscan_prefix_cols=0;
set vacuum_freeze_min_age = 0;
set cursor_tuple_fraction=1.000;
create extension if not exists pageinspect; -- just to have it
-- set statement_timeout='4s';
reset client_min_messages;
-- Set log_btree_verbosity to 1 without depending on having that patch
-- applied (HACK, just sets commit_siblings instead when we don't have that
-- patch available):
select set_config((select coalesce((select name from pg_settings where name = 'log_btree_verbosity'), 'commit_siblings')), '1', false);
 set_config 
------------
 1
(1 row)

-- Establish if this server is master or the patch -- want to skip stress
-- tests if it's the latter
--
-- Reminder: Don't vary the database state between master and patch (just the
-- tests run, which must be read-only)
select (setting = '5432') as testing_patch from pg_settings where name = 'port'
       \gset
-- Quick sanity check, to make it obvious when you forgot to initdb correctly:
-- Shows the available skip support routines in the database
select
  amp.oid as skip_proc_oid,
  amp.amproc::regproc as proc,
  opf.opfname as opfamily_name,
  opc.opcname as opclass_name,
  opc.opcintype::regtype as opcintype
from pg_am as am
join pg_opclass as opc on opc.opcmethod = am.oid
join pg_opfamily as opf on opc.opcfamily = opf.oid
join pg_amproc as amp on amp.amprocfamily = opf.oid and
    amp.amproclefttype = opc.opcintype and amp.amprocnum = 6
where am.amname = 'btree'
order by 1, 2, 3, 4;
 skip_proc_oid |         proc          | opfamily_name |  opclass_name   |          opcintype          
---------------+-----------------------+---------------+-----------------+-----------------------------
         10004 | btboolskipsupport     | bool_ops      | bool_ops        | boolean
         10014 | btcharskipsupport     | char_ops      | char_ops        | "char"
         10018 | date_skipsupport      | datetime_ops  | date_ops        | date
         10024 | timestamp_skipsupport | datetime_ops  | timestamp_ops   | timestamp without time zone
         10030 | timestamp_skipsupport | datetime_ops  | timestamptz_ops | timestamp with time zone
         10050 | btint2skipsupport     | integer_ops   | int2_ops        | smallint
         10059 | btint4skipsupport     | integer_ops   | int4_ops        | integer
         10068 | btint8skipsupport     | integer_ops   | int8_ops        | bigint
         10083 | btoidskipsupport      | oid_ops       | oid_ops         | oid
         10115 | uuid_skipsupport      | uuid_ops      | uuid_ops        | uuid
(10 rows)

--
-- Heikki CREATE INDEX regression stress test query (miniaturized) --
--
-- Test case taken from: https://postgr.es/m/aa55adf3-6466-4324-92e6-5ef54e7c3918@iki.fi
--
-- set enable_seqscan=off; set max_parallel_workers_per_gather=0;
-- Setup:
set client_min_messages=error;
drop table if exists heikki_skiptest_small;
reset client_min_messages;
-- First do retail insert version of his query, where suffix truncation is
-- effective:
create unlogged table heikki_skiptest_small (a int, b int);
create index heikki_skiptest_small_idx on heikki_skiptest_small (a, b);
insert into heikki_skiptest_small
select g / 10 as a, g % 10 as b
from generate_series(1, 10_000) g;
vacuum freeze heikki_skiptest_small;
-- Forwards:
select count(*)
from heikki_skiptest_small
where b = 1;
 count 
-------
  1000
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*)
from heikki_skiptest_small
where b = 1;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=133.91..133.92 rows=1 width=8) (actual rows=1.00 loops=1)
   Buffers: shared hit=29
   ->  Index Only Scan using heikki_skiptest_small_idx on heikki_skiptest_small  (cost=0.29..133.78 rows=50 width=0) (actual rows=1000.00 loops=1)
         Index Cond: (b = 1)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=29
(7 rows)

-- Backwards:
select a, b
from heikki_skiptest_small
where b = 1
order by a desc, b desc
limit 1 offset 20_000;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b
from heikki_skiptest_small
where b = 1
order by a desc, b desc
limit 1 offset 20_000;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=133.78..136.45 rows=1 width=8) (actual rows=0.00 loops=1)
   Buffers: shared hit=29
   ->  Index Only Scan Backward using heikki_skiptest_small_idx on heikki_skiptest_small  (cost=0.29..133.78 rows=50 width=8) (actual rows=1000.00 loops=1)
         Index Cond: (b = 1)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=29
(7 rows)

-- Okay, now the actual adversarial case, which requires that suffix
-- truncation wasn't very effective -- REINDEX to get that:
reindex index heikki_skiptest_small_idx;
-- Now repeat exactly the same queries as first time around:
-- Forwards:
select count(*)
from heikki_skiptest_small
where b = 1;
 count 
-------
  1000
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*)
from heikki_skiptest_small
where b = 1;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=135.91..135.92 rows=1 width=8) (actual rows=1.00 loops=1)
   Buffers: shared hit=30
   ->  Index Only Scan using heikki_skiptest_small_idx on heikki_skiptest_small  (cost=0.29..135.78 rows=50 width=0) (actual rows=1000.00 loops=1)
         Index Cond: (b = 1)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=30
(7 rows)

-- Backwards:
select a, b
from heikki_skiptest_small
where b = 1
order by a desc, b desc
limit 1 offset 20_000;
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b
from heikki_skiptest_small
where b = 1
order by a desc, b desc
limit 1 offset 20_000;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=135.78..138.50 rows=1 width=8) (actual rows=0.00 loops=1)
   Buffers: shared hit=30
   ->  Index Only Scan Backward using heikki_skiptest_small_idx on heikki_skiptest_small  (cost=0.29..135.78 rows=50 width=8) (actual rows=1000.00 loops=1)
         Index Cond: (b = 1)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=30
(7 rows)

----------------------
-- Misc multi tests --
----------------------
set client_min_messages=error;
drop table if exists multi_test_skip;
reset client_min_messages;
create unlogged table multi_test_skip(
  a int,
  b int,
  c int
);
create index multi_test_skip_idx on multi_test_skip(a, b);
insert into multi_test_skip
select
  j,
  case when i < 14 then
    0
  else
    1
  end
from
  generate_series(1, 14) i,
  generate_series(1, 400) j
order by
  j,
  i;
vacuum analyze multi_test_skip;
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Harder case
select a, b from multi_test_skip where a in (123, 182, 183) and b in (1,2);
  a  | b 
-----+---
 123 | 1
 182 | 1
 183 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (123, 182, 183) and b in (1,2);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=6.88..11.89 rows=3 width=8) (actual rows=3.00 loops=1)
   Recheck Cond: ((a = ANY ('{123,182,183}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Blocks: exact=2
   Buffers: shared hit=4
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3.00 loops=1)
         Index Cond: ((a = ANY ('{123,182,183}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
         Index Searches: 1
         Buffers: shared hit=2
(8 rows)

-- Hard case
select a, b from multi_test_skip where a in (182, 183, 184) and b in (1,2);
  a  | b 
-----+---
 182 | 1
 183 | 1
 184 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (182, 183, 184) and b in (1,2);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=6.88..11.89 rows=3 width=8) (actual rows=3.00 loops=1)
   Recheck Cond: ((a = ANY ('{182,183,184}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=4
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3.00 loops=1)
         Index Cond: ((a = ANY ('{182,183,184}'::integer[])) AND (b = ANY ('{1,2}'::integer[])))
         Index Searches: 1
         Buffers: shared hit=3
(8 rows)

select a, b from multi_test_skip where a in (3,4,5) and b > 0;
 a | b 
---+---
 3 | 1
 4 | 1
 5 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (3,4,5) and b > 0;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=6.88..11.89 rows=3 width=8) (actual rows=3.00 loops=1)
   Recheck Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..6.88 rows=3 width=0) (actual rows=3.00 loops=1)
         Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
         Index Searches: 1
         Buffers: shared hit=2
(8 rows)

set enable_indexscan to on;
-- Backwards scan:
select a, b from multi_test_skip where a in (3,4,5) and b > 0
order by a desc, b desc;
 a | b 
---+---
 5 | 1
 4 | 1
 3 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (3,4,5) and b > 0
order by a desc, b desc;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using multi_test_skip_idx on multi_test_skip  (cost=0.28..10.66 rows=3 width=8) (actual rows=3.00 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
   Index Searches: 1
   Buffers: shared hit=3
(4 rows)

set enable_indexscan to off;
-- (July 24, day before taking the train to Cambridge)
--
-- Make sure that skip array stores no more than a single inequality in a
-- cross-type scenario where we cannot prove which type/operator (the > operator
-- or the >= operator) is the redundant of the two lower bound operators.
--
-- The bug here was that we senselessly clobbered the skip array's
-- array.lower_bound field.  We must avoid behaving as if we can roll more
-- than a single lower/upper bound inequality into a skip array.
select
  a, b from
  multi_test_skip
where
  a > 395 and a >= 390::int8 and b = 1;
  a  | b 
-----+---
 396 | 1
 397 | 1
 398 | 1
 399 | 1
 400 | 1
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a > 395 and a >= 390::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=6.92..14.78 rows=5 width=8) (actual rows=5.00 loops=1)
   Recheck Cond: ((a > 395) AND (a >= '390'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..6.92 rows=5 width=0) (actual rows=5.00 loops=1)
         Index Cond: ((a > 395) AND (a >= '390'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(10 rows)

-- (July 24, day before taking the train to Cambridge)
--
-- This test shouldn't get confused about which is the most restrictive scan
-- key -- it's important that we not start the scan on a leaf page to the left
-- of the tree needlessly:
--
-- (This behvior might be acceptable with an incomplete opfamily, but that's
-- not why we have here)
select
  a, b from
  multi_test_skip
where
  a > 1 and a >= 400::int8 and b = 1;
  a  | b 
-----+---
 400 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 2 buffer hits, not 8
select
  a, b from
  multi_test_skip
where
  a > 1 and a >= 400::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=2.46..4.48 rows=1 width=8) (actual rows=1.00 loops=1)
   Recheck Cond: ((a > 1) AND (a >= '400'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..2.46 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((a > 1) AND (a >= '400'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 1:
select
  a, b from
  multi_test_skip
where
  a > 399 and a >= 400::int8 and b = 1;
  a  | b 
-----+---
 400 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a > 399 and a >= 400::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=2.46..4.48 rows=1 width=8) (actual rows=1.00 loops=1)
   Recheck Cond: ((a > 399) AND (a >= '400'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..2.46 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((a > 399) AND (a >= '400'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 2:
select
  a, b from
  multi_test_skip
where
  a > 399::int8 and a >= 400 and b = 1;
  a  | b 
-----+---
 400 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a > 399::int8 and a >= 400 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=2.46..4.48 rows=1 width=8) (actual rows=1.00 loops=1)
   Recheck Cond: ((a > '399'::bigint) AND (a >= 400) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..2.46 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((a > '399'::bigint) AND (a >= 400) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 3:
select
  a, b from
  multi_test_skip
where
  a >= 400::int8 and a > 399 and b = 1;
  a  | b 
-----+---
 400 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a >= 400::int8 and a > 399 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=2.46..4.48 rows=1 width=8) (actual rows=1.00 loops=1)
   Recheck Cond: ((a >= '400'::bigint) AND (a > 399) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..2.46 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((a >= '400'::bigint) AND (a > 399) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 4:
select
  a, b from
  multi_test_skip
where
  a >= 400 and a > 399::int8 and b = 1;
  a  | b 
-----+---
 400 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a >= 400 and a > 399::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=2.46..4.48 rows=1 width=8) (actual rows=1.00 loops=1)
   Recheck Cond: ((a >= 400) AND (a > '399'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..2.46 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((a >= 400) AND (a > '399'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 5:
select
  a, b from
  multi_test_skip
where
  a > 399 and a >= 400::int8 and b = 1;
  a  | b 
-----+---
 400 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a > 399 and a >= 400::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=2.46..4.48 rows=1 width=8) (actual rows=1.00 loops=1)
   Recheck Cond: ((a > 399) AND (a >= '400'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..2.46 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((a > 399) AND (a >= '400'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 6:
select
  a, b from
  multi_test_skip
where
  a > 399 and a >= 399::int8 and b = 1;
  a  | b 
-----+---
 400 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a > 399 and a >= 399::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=2.46..4.48 rows=1 width=8) (actual rows=1.00 loops=1)
   Recheck Cond: ((a > 399) AND (a >= '399'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..2.46 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((a > 399) AND (a >= '399'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 7:
select
  a, b from
  multi_test_skip
where
  a >= 399 and a > 399::int8 and b = 1;
  a  | b 
-----+---
 400 | 1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a >= 399 and a > 399::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=2.46..4.48 rows=1 width=8) (actual rows=1.00 loops=1)
   Recheck Cond: ((a >= 399) AND (a > '399'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..2.46 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((a >= 399) AND (a > '399'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 8:
select
  a, b from
  multi_test_skip
where
  a <= 3 and a < 3::int8 and b = 1;
 a | b 
---+---
 1 | 1
 2 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a <= 3 and a < 3::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=4.59..8.06 rows=2 width=8) (actual rows=2.00 loops=1)
   Recheck Cond: ((a <= 3) AND (a < '3'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..4.59 rows=2 width=0) (actual rows=2.00 loops=1)
         Index Cond: ((a <= 3) AND (a < '3'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 9:
select
  a, b from
  multi_test_skip
where
  a <= 2 and a < 3::int8 and b = 1;
 a | b 
---+---
 1 | 1
 2 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a <= 2 and a < 3::int8 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=4.59..8.06 rows=2 width=8) (actual rows=2.00 loops=1)
   Recheck Cond: ((a <= 2) AND (a < '3'::bigint) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..4.59 rows=2 width=0) (actual rows=2.00 loops=1)
         Index Cond: ((a <= 2) AND (a < '3'::bigint) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Variant 10:
select
  a, b from
  multi_test_skip
where
  a <= 2::int8 and a < 3 and b = 1;
 a | b 
---+---
 1 | 1
 2 | 1
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  a, b from
  multi_test_skip
where
  a <= 2::int8 and a < 3 and b = 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=4.59..8.06 rows=2 width=8) (actual rows=2.00 loops=1)
   Recheck Cond: ((a <= '2'::bigint) AND (a < 3) AND (b = 1))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..4.59 rows=2 width=0) (actual rows=2.00 loops=1)
         Index Cond: ((a <= '2'::bigint) AND (a < 3) AND (b = 1))
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=6
(10 rows)

-- Redundant test:
select a, b
from multi_test_skip
where
  a in (1, 99, 182, 183, 184)
  and a > 183;
  a  | b 
-----+---
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b
from multi_test_skip
where
  a in (1, 99, 182, 183, 184)
  and a > 183;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=7.25..31.32 rows=38 width=8) (actual rows=14.00 loops=1)
   Recheck Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a > 183))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=14.00 loops=1)
         Index Cond: ((a = ANY ('{1,99,182,183,184}'::integer[])) AND (a > 183))
         Index Searches: 1
         Buffers: shared hit=2
(8 rows)

-- Redundant test, flip order:
select a, b
from multi_test_skip
where
  a > 183
  and a in (1, 99, 182, 183, 184);
  a  | b 
-----+---
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 0
 184 | 1
(14 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select a, b
from multi_test_skip
where
  a > 183
  and a in (1, 99, 182, 183, 184);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=7.25..31.32 rows=38 width=8) (actual rows=14.00 loops=1)
   Recheck Cond: ((a > 183) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=3
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..7.24 rows=38 width=0) (actual rows=14.00 loops=1)
         Index Cond: ((a > 183) AND (a = ANY ('{1,99,182,183,184}'::integer[])))
         Index Searches: 1
         Buffers: shared hit=2
(8 rows)

select a, b
from multi_test_skip
where
  a in (180, 345)
  and a in (230, 300);
 a | b 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 0 buffer hits (contradictory qual)
select a, b
from multi_test_skip
where
  a in (180, 345)
  and a in (230, 300);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=6.88..8.89 rows=1 width=8) (actual rows=0.00 loops=1)
   Recheck Cond: ((a = ANY ('{180,345}'::integer[])) AND (a = ANY ('{230,300}'::integer[])))
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..6.88 rows=1 width=0) (actual rows=0.00 loops=1)
         Index Cond: ((a = ANY ('{180,345}'::integer[])) AND (a = ANY ('{230,300}'::integer[])))
         Index Searches: 0
(5 rows)

insert into multi_test_skip
select
  NULL,
  j
from
  generate_series(1, 10) j
order by j;
vacuum analyze multi_test_skip;
select a, b
from multi_test_skip
where b = 1;
  a  | b 
-----+---
   1 | 1
   2 | 1
   3 | 1
   4 | 1
   5 | 1
   6 | 1
   7 | 1
   8 | 1
   9 | 1
  10 | 1
  11 | 1
  12 | 1
  13 | 1
  14 | 1
  15 | 1
  16 | 1
  17 | 1
  18 | 1
  19 | 1
  20 | 1
  21 | 1
  22 | 1
  23 | 1
  24 | 1
  25 | 1
  26 | 1
  27 | 1
  28 | 1
  29 | 1
  30 | 1
  31 | 1
  32 | 1
  33 | 1
  34 | 1
  35 | 1
  36 | 1
  37 | 1
  38 | 1
  39 | 1
  40 | 1
  41 | 1
  42 | 1
  43 | 1
  44 | 1
  45 | 1
  46 | 1
  47 | 1
  48 | 1
  49 | 1
  50 | 1
  51 | 1
  52 | 1
  53 | 1
  54 | 1
  55 | 1
  56 | 1
  57 | 1
  58 | 1
  59 | 1
  60 | 1
  61 | 1
  62 | 1
  63 | 1
  64 | 1
  65 | 1
  66 | 1
  67 | 1
  68 | 1
  69 | 1
  70 | 1
  71 | 1
  72 | 1
  73 | 1
  74 | 1
  75 | 1
  76 | 1
  77 | 1
  78 | 1
  79 | 1
  80 | 1
  81 | 1
  82 | 1
  83 | 1
  84 | 1
  85 | 1
  86 | 1
  87 | 1
  88 | 1
  89 | 1
  90 | 1
  91 | 1
  92 | 1
  93 | 1
  94 | 1
  95 | 1
  96 | 1
  97 | 1
  98 | 1
  99 | 1
 100 | 1
 101 | 1
 102 | 1
 103 | 1
 104 | 1
 105 | 1
 106 | 1
 107 | 1
 108 | 1
 109 | 1
 110 | 1
 111 | 1
 112 | 1
 113 | 1
 114 | 1
 115 | 1
 116 | 1
 117 | 1
 118 | 1
 119 | 1
 120 | 1
 121 | 1
 122 | 1
 123 | 1
 124 | 1
 125 | 1
 126 | 1
 127 | 1
 128 | 1
 129 | 1
 130 | 1
 131 | 1
 132 | 1
 133 | 1
 134 | 1
 135 | 1
 136 | 1
 137 | 1
 138 | 1
 139 | 1
 140 | 1
 141 | 1
 142 | 1
 143 | 1
 144 | 1
 145 | 1
 146 | 1
 147 | 1
 148 | 1
 149 | 1
 150 | 1
 151 | 1
 152 | 1
 153 | 1
 154 | 1
 155 | 1
 156 | 1
 157 | 1
 158 | 1
 159 | 1
 160 | 1
 161 | 1
 162 | 1
 163 | 1
 164 | 1
 165 | 1
 166 | 1
 167 | 1
 168 | 1
 169 | 1
 170 | 1
 171 | 1
 172 | 1
 173 | 1
 174 | 1
 175 | 1
 176 | 1
 177 | 1
 178 | 1
 179 | 1
 180 | 1
 181 | 1
 182 | 1
 183 | 1
 184 | 1
 185 | 1
 186 | 1
 187 | 1
 188 | 1
 189 | 1
 190 | 1
 191 | 1
 192 | 1
 193 | 1
 194 | 1
 195 | 1
 196 | 1
 197 | 1
 198 | 1
 199 | 1
 200 | 1
 201 | 1
 202 | 1
 203 | 1
 204 | 1
 205 | 1
 206 | 1
 207 | 1
 208 | 1
 209 | 1
 210 | 1
 211 | 1
 212 | 1
 213 | 1
 214 | 1
 215 | 1
 216 | 1
 217 | 1
 218 | 1
 219 | 1
 220 | 1
 221 | 1
 222 | 1
 223 | 1
 224 | 1
 225 | 1
 226 | 1
 227 | 1
 228 | 1
 229 | 1
 230 | 1
 231 | 1
 232 | 1
 233 | 1
 234 | 1
 235 | 1
 236 | 1
 237 | 1
 238 | 1
 239 | 1
 240 | 1
 241 | 1
 242 | 1
 243 | 1
 244 | 1
 245 | 1
 246 | 1
 247 | 1
 248 | 1
 249 | 1
 250 | 1
 251 | 1
 252 | 1
 253 | 1
 254 | 1
 255 | 1
 256 | 1
 257 | 1
 258 | 1
 259 | 1
 260 | 1
 261 | 1
 262 | 1
 263 | 1
 264 | 1
 265 | 1
 266 | 1
 267 | 1
 268 | 1
 269 | 1
 270 | 1
 271 | 1
 272 | 1
 273 | 1
 274 | 1
 275 | 1
 276 | 1
 277 | 1
 278 | 1
 279 | 1
 280 | 1
 281 | 1
 282 | 1
 283 | 1
 284 | 1
 285 | 1
 286 | 1
 287 | 1
 288 | 1
 289 | 1
 290 | 1
 291 | 1
 292 | 1
 293 | 1
 294 | 1
 295 | 1
 296 | 1
 297 | 1
 298 | 1
 299 | 1
 300 | 1
 301 | 1
 302 | 1
 303 | 1
 304 | 1
 305 | 1
 306 | 1
 307 | 1
 308 | 1
 309 | 1
 310 | 1
 311 | 1
 312 | 1
 313 | 1
 314 | 1
 315 | 1
 316 | 1
 317 | 1
 318 | 1
 319 | 1
 320 | 1
 321 | 1
 322 | 1
 323 | 1
 324 | 1
 325 | 1
 326 | 1
 327 | 1
 328 | 1
 329 | 1
 330 | 1
 331 | 1
 332 | 1
 333 | 1
 334 | 1
 335 | 1
 336 | 1
 337 | 1
 338 | 1
 339 | 1
 340 | 1
 341 | 1
 342 | 1
 343 | 1
 344 | 1
 345 | 1
 346 | 1
 347 | 1
 348 | 1
 349 | 1
 350 | 1
 351 | 1
 352 | 1
 353 | 1
 354 | 1
 355 | 1
 356 | 1
 357 | 1
 358 | 1
 359 | 1
 360 | 1
 361 | 1
 362 | 1
 363 | 1
 364 | 1
 365 | 1
 366 | 1
 367 | 1
 368 | 1
 369 | 1
 370 | 1
 371 | 1
 372 | 1
 373 | 1
 374 | 1
 375 | 1
 376 | 1
 377 | 1
 378 | 1
 379 | 1
 380 | 1
 381 | 1
 382 | 1
 383 | 1
 384 | 1
 385 | 1
 386 | 1
 387 | 1
 388 | 1
 389 | 1
 390 | 1
 391 | 1
 392 | 1
 393 | 1
 394 | 1
 395 | 1
 396 | 1
 397 | 1
 398 | 1
 399 | 1
 400 | 1
     | 1
(401 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b
from multi_test_skip
where b = 1;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on multi_test_skip  (cost=60.46..90.47 rows=401 width=8) (actual rows=401.00 loops=1)
   Recheck Cond: (b = 1)
   Heap Blocks: exact=25
   Buffers: shared hit=33
   ->  Bitmap Index Scan on multi_test_skip_idx  (cost=0.00..60.36 rows=401 width=0) (actual rows=401.00 loops=1)
         Index Cond: (b = 1)
         Index Searches: 1
         Buffers: shared hit=8
(8 rows)

-- Reset
set enable_indexonlyscan to on;
set enable_indexscan to on;
-- (June 6)
-- Backwards scan, visibly breaks when I was refactoring code in
-- _bt_advance_array_keys so that it dealt with out-of-bounds skip array case more
-- like conventional array case (i.e. by using result/beyond_end_advance
-- variables directly, not just taking instructions from _bt_binsrch_array_skey
-- skip array logic):
select a, b from multi_test_skip where a in (3,4,5) and b < 1
order by a desc, b desc;
 a | b 
---+---
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (3,4,5) and b < 1
order by a desc, b desc;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using multi_test_skip_idx on multi_test_skip  (cost=0.28..7.63 rows=39 width=8) (actual rows=39.00 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 1))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=3
(5 rows)

drop index multi_test_skip_idx;
-- Test that roll over logic doesn't increment sk_datum plus remove NULL sk
-- marking when it should just do the latter.  Bug found in NULLS FIRST case
-- after returning from pgConf.dev.
--
-- (June 3)
create index multi_test_skip_idx_nulls_first on multi_test_skip(a nulls first, b);
-- Insert INT_MIN value that had better not be overlooked here:
insert into multi_test_skip
select -2147483648, 1;
vacuum analyze multi_test_skip;
select a, b
from multi_test_skip
where b = 1
order by a nulls first, b limit 5;
      a      | b 
-------------+---
             | 1
 -2147483648 | 1
           1 | 1
           2 | 1
           3 | 1
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b
from multi_test_skip
where b = 1
order by a nulls first, b limit 5;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.28..1.08 rows=5 width=8) (actual rows=5.00 loops=1)
   Buffers: shared hit=3
   ->  Index Only Scan using multi_test_skip_idx_nulls_first on multi_test_skip  (cost=0.28..64.38 rows=402 width=8) (actual rows=5.00 loops=1)
         Index Cond: (b = 1)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=3
(7 rows)

drop index multi_test_skip_idx_nulls_first;
-- (June 9)
-- DESC NULLS LAST
create index multi_test_skip_idx_desc_nulls_last on multi_test_skip(a desc nulls last, b);
select a, b
from multi_test_skip
where b = 1
order by a desc nulls last, b limit 5;
  a  | b 
-----+---
 400 | 1
 399 | 1
 398 | 1
 397 | 1
 396 | 1
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b
from multi_test_skip
where b = 1
order by a desc nulls last, b limit 5;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.28..1.08 rows=5 width=8) (actual rows=5.00 loops=1)
   Buffers: shared hit=3
   ->  Index Only Scan using multi_test_skip_idx_desc_nulls_last on multi_test_skip  (cost=0.28..64.38 rows=402 width=8) (actual rows=5.00 loops=1)
         Index Cond: (b = 1)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=3
(7 rows)

select a, b
from multi_test_skip
where b = 1
order by a desc nulls last, b limit 5 offset 397;
      a      | b 
-------------+---
           3 | 1
           2 | 1
           1 | 1
 -2147483648 | 1
             | 1
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b
from multi_test_skip
where b = 1
order by a desc nulls last, b limit 5 offset 397;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=63.59..64.38 rows=5 width=8) (actual rows=5.00 loops=1)
   Buffers: shared hit=9
   ->  Index Only Scan using multi_test_skip_idx_desc_nulls_last on multi_test_skip  (cost=0.28..64.38 rows=402 width=8) (actual rows=402.00 loops=1)
         Index Cond: (b = 1)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=9
(7 rows)

drop index multi_test_skip_idx_desc_nulls_last;
create index multi_test_skip_desc_idx on multi_test_skip(a desc, b desc);
-- Backwards scan:
select a, b from multi_test_skip where a in (3,4,5) and b > 0
order by a, b;
 a | b 
---+---
 3 | 1
 4 | 1
 5 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (3,4,5) and b > 0
order by a, b;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using multi_test_skip_desc_idx on multi_test_skip  (cost=0.28..6.91 rows=3 width=8) (actual rows=3.00 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=3
(5 rows)

-- Forwards scan:
select a, b from multi_test_skip where a in (3,4,5) and b > 0
order by a desc, b desc;
 a | b 
---+---
 5 | 1
 4 | 1
 3 | 1
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (3,4,5) and b > 0
order by a desc, b desc;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_skip_desc_idx on multi_test_skip  (cost=0.28..6.91 rows=3 width=8) (actual rows=3.00 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b > 0))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=3
(5 rows)

-- Backwards scan:
select a, b from multi_test_skip where a in (3,4,5) and b < 1
order by a, b;
 a | b 
---+---
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (3,4,5) and b < 1
order by a, b;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using multi_test_skip_desc_idx on multi_test_skip  (cost=0.28..7.63 rows=39 width=8) (actual rows=39.00 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 1))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=3
(5 rows)

-- Forwards scan:
select a, b from multi_test_skip where a in (3,4,5) and b < 1
order by a desc, b desc;
 a | b 
---+---
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 5 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 4 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
 3 | 0
(39 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b from multi_test_skip where a in (3,4,5) and b < 1
order by a desc, b desc;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using multi_test_skip_desc_idx on multi_test_skip  (cost=0.28..7.63 rows=39 width=8) (actual rows=39.00 loops=1)
   Index Cond: ((a = ANY ('{3,4,5}'::integer[])) AND (b < 1))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=3
(5 rows)

-- (August 13)
--
-- Add test coverage for this code path:
--
-- @@ -1924,7 +1927,10 @@ _bt_binsrch_skiparray_skey(FmgrInfo *orderproc,
--          if (array->null_elem)
--              *set_elem_result = 0;   /* NULL "=" NULL */
--          else if (cur->sk_flags & SK_BT_NULLS_FIRST)
-- +        {
-- +            elog(WARNING, "fff");   <-- fff indicates covered path
--              *set_elem_result = -1;  /* NULL "<" NOT_NULL */
-- +        }
--          else
--              *set_elem_result = 1;   /* NULL ">" NOT_NULL */
create index multi_test_skip_idx_nulls_first_nulls_first
on
multi_test_skip(a asc nulls first, b asc nulls first, c);
insert into multi_test_skip
select
  3,
  case when i < 14 then
    NULL
  else
    1
  end
from
  generate_series(1, 14) i,
  generate_series(1, 400) j
order by
  j,
  i;
vacuum analyze multi_test_skip;
select a, b, c
from multi_test_skip
where b < 1 and c is not null
order by a desc nulls last, b desc nulls last;
 a | b | c 
---+---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select a, b, c
from multi_test_skip
where b < 1 and c is not null
order by a desc nulls last, b desc nulls last;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using multi_test_skip_idx_nulls_first_nulls_first on multi_test_skip  (cost=0.29..146.41 rows=1 width=12) (actual rows=0.00 loops=1)
   Index Cond: ((b < 1) AND (c IS NOT NULL))
   Heap Fetches: 0
   Index Searches: 2
   Buffers: shared hit=14
(5 rows)

drop index multi_test_skip_idx_nulls_first_nulls_first;
----------------
-- UUID tests --
----------------
-- (June 5)
--
-- UUID is notable for being a pass-by-reference type that can use the
-- increment/decrement stuff in roughly the same way as types like integer and
-- date.  It's a good way of making things like memory management and copying
-- of datums work, because I can do that stuff without first figuring out how
-- to do next value probes that are expected to be required by more popular
-- pass-by-reference types such as text.
--
-- Another notable thing about UUID is that it's unlikely that rolling over and
-- incrementing the existing UUID value will result in a UUID value that
-- actually finds a match in the index -- that makes it a lot closer to types
-- like text than to discrete types like integer.  With types like integer,
-- we somewhat expect that incrementing/decrementing the current value will
-- actually result in a value that finds matches in the index.
set client_min_messages=error;
DROP TABLE if exists uuid_tests;
reset client_min_messages;
create unlogged table uuid_tests
(
  skippy uuid,
  predval int4
);
create index uuid_tests_idx on uuid_tests(skippy, predval);
insert into uuid_tests
select '00000000-0000-0000-0000-000000000001', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '10000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '20000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '30000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '40000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '50000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '60000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '70000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '80000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select '90000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select 'A0000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select 'B0000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select 'C0000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select 'D0000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select 'E0000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select 'F0000000-0000-0000-0000-000000000000', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFE', j from
  generate_series(1, 5000) j;
insert into uuid_tests
select NULL, j from
  generate_series(1, 5000) j;
vacuum analyze uuid_tests;
-- Basic skip scan test case for UUID:
select skippy, predval
from uuid_tests
where predval = 777 order by skippy, predval;
                skippy                | predval 
--------------------------------------+---------
 00000000-0000-0000-0000-000000000001 |     777
 10000000-0000-0000-0000-000000000000 |     777
 20000000-0000-0000-0000-000000000000 |     777
 30000000-0000-0000-0000-000000000000 |     777
 40000000-0000-0000-0000-000000000000 |     777
 50000000-0000-0000-0000-000000000000 |     777
 60000000-0000-0000-0000-000000000000 |     777
 70000000-0000-0000-0000-000000000000 |     777
 80000000-0000-0000-0000-000000000000 |     777
 90000000-0000-0000-0000-000000000000 |     777
 a0000000-0000-0000-0000-000000000000 |     777
 b0000000-0000-0000-0000-000000000000 |     777
 c0000000-0000-0000-0000-000000000000 |     777
 d0000000-0000-0000-0000-000000000000 |     777
 e0000000-0000-0000-0000-000000000000 |     777
 f0000000-0000-0000-0000-000000000000 |     777
 ffffffff-ffff-ffff-ffff-fffffffffffe |     777
                                      |     777
(18 rows)

-- The number of descents of the index significantly exceeds the number of
-- distinct "skippy" values, since we effectively probe for the next UUID
-- value by incrementing here.  Even though explicit probes aren't really used,
-- it more or less looks like they're used in practice.
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select skippy, predval
from uuid_tests
where predval = 777 order by skippy, predval;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Index Only Scan using uuid_tests_idx on uuid_tests  (cost=0.42..43.83 rows=18 width=20) (actual rows=18.00 loops=1)
   Index Cond: (predval = 777)
   Heap Fetches: 0
   Index Searches: 36
   Buffers: shared hit=111
(5 rows)

-- Basic skip scan test case for UUID, backwards scan:
select skippy, predval
from uuid_tests
where predval = 777 order by skippy desc, predval desc;
                skippy                | predval 
--------------------------------------+---------
                                      |     777
 ffffffff-ffff-ffff-ffff-fffffffffffe |     777
 f0000000-0000-0000-0000-000000000000 |     777
 e0000000-0000-0000-0000-000000000000 |     777
 d0000000-0000-0000-0000-000000000000 |     777
 c0000000-0000-0000-0000-000000000000 |     777
 b0000000-0000-0000-0000-000000000000 |     777
 a0000000-0000-0000-0000-000000000000 |     777
 90000000-0000-0000-0000-000000000000 |     777
 80000000-0000-0000-0000-000000000000 |     777
 70000000-0000-0000-0000-000000000000 |     777
 60000000-0000-0000-0000-000000000000 |     777
 50000000-0000-0000-0000-000000000000 |     777
 40000000-0000-0000-0000-000000000000 |     777
 30000000-0000-0000-0000-000000000000 |     777
 20000000-0000-0000-0000-000000000000 |     777
 10000000-0000-0000-0000-000000000000 |     777
 00000000-0000-0000-0000-000000000001 |     777
(18 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select skippy, predval
from uuid_tests
where predval = 777 order by skippy desc, predval desc;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using uuid_tests_idx on uuid_tests  (cost=0.42..43.83 rows=18 width=20) (actual rows=18.00 loops=1)
   Index Cond: (predval = 777)
   Heap Fetches: 0
   Index Searches: 36
   Buffers: shared hit=109
(5 rows)

-- (July 16) Same again ("Basic skip scan test case for UUID, backwards
-- scan"), but no skip support this time around.
-- This caught a silly bug, fixed like so:
-- diff --git a/src/backend/access/nbtree/nbtutils.c b/src/backend/access/nbtree/nbtutils.c
-- index 4b7b55a9f..d75b3e54a 100644
-- --- a/src/backend/access/nbtree/nbtutils.c
-- +++ b/src/backend/access/nbtree/nbtutils.c
-- @@ -2475,7 +2475,7 @@ _bt_scankey_skip_increment(Relation rel, ScanDirection dir,
--               * This saves a useless primitive index scan that would otherwise
--               * try to locate a value before NULL.
--               */
-- -            if (sk_isnull && !(skey->sk_flags & SK_BT_NULLS_FIRST))
-- +            if (sk_isnull && (skey->sk_flags & SK_BT_NULLS_FIRST))
--                  goto rollover;
--
-- Test:
set skipscan_skipsupport_enabled=false;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
select skippy, predval
from uuid_tests
where predval = 777 order by skippy desc, predval desc;
                skippy                | predval 
--------------------------------------+---------
                                      |     777
 ffffffff-ffff-ffff-ffff-fffffffffffe |     777
 f0000000-0000-0000-0000-000000000000 |     777
 e0000000-0000-0000-0000-000000000000 |     777
 d0000000-0000-0000-0000-000000000000 |     777
 c0000000-0000-0000-0000-000000000000 |     777
 b0000000-0000-0000-0000-000000000000 |     777
 a0000000-0000-0000-0000-000000000000 |     777
 90000000-0000-0000-0000-000000000000 |     777
 80000000-0000-0000-0000-000000000000 |     777
 70000000-0000-0000-0000-000000000000 |     777
 60000000-0000-0000-0000-000000000000 |     777
 50000000-0000-0000-0000-000000000000 |     777
 40000000-0000-0000-0000-000000000000 |     777
 30000000-0000-0000-0000-000000000000 |     777
 20000000-0000-0000-0000-000000000000 |     777
 10000000-0000-0000-0000-000000000000 |     777
 00000000-0000-0000-0000-000000000001 |     777
(18 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select skippy, predval
from uuid_tests
where predval = 777 order by skippy desc, predval desc;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using uuid_tests_idx on uuid_tests  (cost=0.42..43.83 rows=18 width=20) (actual rows=18.00 loops=1)
   Index Cond: (predval = 777)
   Heap Fetches: 0
   Index Searches: 36
   Buffers: shared hit=109
(5 rows)

reset skipscan_skipsupport_enabled;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
-- SAOP skip scan test case for UUID:
select count(*)
from uuid_tests
where predval in (333, 4000, 4500, 5000);
 count 
-------
    72
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*)
from uuid_tests
where predval in (333, 4000, 4500, 5000);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=165.50..165.51 rows=1 width=8) (actual rows=1.00 loops=1)
   Buffers: shared hit=222
   ->  Index Only Scan using uuid_tests_idx on uuid_tests  (cost=0.42..165.32 rows=72 width=0) (actual rows=72.00 loops=1)
         Index Cond: (predval = ANY ('{333,4000,4500,5000}'::integer[]))
         Heap Fetches: 0
         Index Searches: 73
         Buffers: shared hit=222
(7 rows)

-- Equivalent-ish range scan formulation (expected to do same accesses, and
-- give same answer):
select count(*)
from uuid_tests
where skippy between '00000000-0000-0000-0000-000000000000' and 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'
and
predval in (333, 4000, 4500, 5000);
 count 
-------
    68
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- COSTS OFF added to get stable test output
select count(*)
from uuid_tests
where skippy between '00000000-0000-0000-0000-000000000000' and 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'
and
predval in (333, 4000, 4500, 5000);
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1.00 loops=1)
   Buffers: shared hit=210
   ->  Index Only Scan using uuid_tests_idx on uuid_tests (actual rows=68.00 loops=1)
         Index Cond: ((skippy >= '00000000-0000-0000-0000-000000000000'::uuid) AND (skippy <= 'ffffffff-ffff-ffff-ffff-ffffffffffff'::uuid) AND (predval = ANY ('{333,4000,4500,5000}'::integer[])))
         Heap Fetches: 0
         Index Searches: 69
         Buffers: shared hit=210
(7 rows)

-- Equivalent-ish range scan formulation using > and < operators (expected to do same accesses, and
-- give same answer) -- stresses preprocessing with pass-by-reference types:
--
-- (UPDATE July 22) This arguably regressed a bit when we went from setting
-- low_elem and high_elem during preprocessing to always directly using the
-- inequalities to fix cross-type range bugs.  One extra primitive index scan.
select count(*)
from uuid_tests
where skippy > '00000000-0000-0000-0000-000000000000' and skippy < 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'
and
predval in (333, 4000, 4500, 5000);
 count 
-------
    68
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- COSTS OFF added to get stable test output
select count(*)
from uuid_tests
where skippy > '00000000-0000-0000-0000-000000000000' and skippy < 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'
and
predval in (333, 4000, 4500, 5000);
                                                                                            QUERY PLAN                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1.00 loops=1)
   Buffers: shared hit=207
   ->  Index Only Scan using uuid_tests_idx on uuid_tests (actual rows=68.00 loops=1)
         Index Cond: ((skippy > '00000000-0000-0000-0000-000000000000'::uuid) AND (skippy < 'ffffffff-ffff-ffff-ffff-ffffffffffff'::uuid) AND (predval = ANY ('{333,4000,4500,5000}'::integer[])))
         Heap Fetches: 0
         Index Searches: 68
         Buffers: shared hit=207
(7 rows)

-- For good luck, more inequality stuff designed to stress preprocessing code
-- (note that these are boundary cases):
--
-- (UPDATE July 22) This arguably regressed a bit when we went from setting
-- low_elem and high_elem during preprocessing to always directly using the
-- inequalities to fix cross-type range bugs.  One extra primitive index scan.
prepare uuid_good_luck as
select count(*)
from uuid_tests
where skippy > '0FFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF' and skippy < 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFE'
and
predval in (333, 4000, 4500, 5000);
execute uuid_good_luck;
 count 
-------
    60
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- COSTS OFF added to get stable test output
execute uuid_good_luck;
                                                                                            QUERY PLAN                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate (actual rows=1.00 loops=1)
   Buffers: shared hit=182
   ->  Index Only Scan using uuid_tests_idx on uuid_tests (actual rows=60.00 loops=1)
         Index Cond: ((skippy > '0fffffff-ffff-ffff-ffff-ffffffffffff'::uuid) AND (skippy < 'ffffffff-ffff-ffff-ffff-fffffffffffe'::uuid) AND (predval = ANY ('{333,4000,4500,5000}'::integer[])))
         Heap Fetches: 0
         Index Searches: 60
         Buffers: shared hit=182
(7 rows)

deallocate uuid_good_luck;
-----------------------------
-- create_index NULL tests --
-----------------------------
set client_min_messages=error;
DROP TABLE if exists onek_skipscan;
DROP TABLE if exists onek_with_null;
reset client_min_messages;
CREATE unlogged TABLE onek_skipscan (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
\getenv abs_srcdir PG_ABS_SRCDIR
\set filename :abs_srcdir '/data/onek.data'
COPY onek_skipscan FROM :'filename';
VACUUM ANALYZE onek_skipscan;
SET enable_indexscan = ON;
SET enable_bitmapscan = ON;
-- First with skip support
set skipscan_skipsupport_enabled=true;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
CREATE unlogged TABLE onek_with_null AS SELECT unique1, unique2 FROM onek_skipscan ;
INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
CREATE UNIQUE INDEX onek_with_null_unique2_unique1 ON onek_with_null (unique2,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

 /* 1 */ SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_with_null_unique2_unique1;
CREATE UNIQUE INDEX onek_with_null_unique2desc_unique1 ON onek_with_null (unique2 desc,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

 /* 2 */ SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IN (-1, 0, 1);
 count 
-------
     1
(1 row)

DROP INDEX onek_with_null_unique2desc_unique1;
CREATE UNIQUE INDEX onek_with_null_unique2descnullslast_unique1 ON onek_with_null (unique2 desc nulls last,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

 /* 3 */ SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_with_null_unique2descnullslast_unique1;
CREATE UNIQUE INDEX onek_with_null_unique2ascnullsfirst_unique1 ON onek_with_null (unique2  nulls first,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

 /* 4 */ SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_with_null_unique2ascnullsfirst_unique1;
-- Check initial-positioning logic too
CREATE UNIQUE INDEX onek_with_null_unique2 ON onek_with_null (unique2);
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
     147 |       0
     931 |       1
(2 rows)

SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |        
     278 |     999
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
     278 |     999
       0 |     998
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
       0 |     998
     744 |     997
(2 rows)

-- Now without skip support
DROP TABLE onek_with_null;
set skipscan_skipsupport_enabled=false;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
CREATE unlogged TABLE onek_with_null AS SELECT unique1, unique2 FROM onek_skipscan ;
INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
CREATE UNIQUE INDEX onek_with_null_unique2_unique1 ON onek_with_null (unique2,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

 /* 5 */ SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_with_null_unique2_unique1;
CREATE UNIQUE INDEX onek_with_null_unique2desc_unique1 ON onek_with_null (unique2 desc,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

 /* 6 */ SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IN (-1, 0, 1);
 count 
-------
     1
(1 row)

DROP INDEX onek_with_null_unique2desc_unique1;
CREATE UNIQUE INDEX onek_with_null_unique2descnullslast_unique1 ON onek_with_null (unique2 desc nulls last,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

 /* 7 */ SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_with_null_unique2descnullslast_unique1;
CREATE UNIQUE INDEX onek_with_null_unique2ascnullsfirst_unique1 ON onek_with_null (unique2  nulls first,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

 /* 8 */ SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_with_null_unique2ascnullsfirst_unique1;
-- Check initial-positioning logic too
CREATE UNIQUE INDEX onek_with_null_unique2 ON onek_with_null (unique2);
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
     147 |       0
     931 |       1
(2 rows)

SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |        
     278 |     999
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
     278 |     999
       0 |     998
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
       0 |     998
     744 |     997
(2 rows)

reset skipscan_skipsupport_enabled;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
RESET enable_indexscan;
RESET enable_bitmapscan;
--------------------------------
-- MDAM paper small test case --
--------------------------------
set client_min_messages=error;
drop table if exists sales_mdam_paper_small;
reset client_min_messages;
create unlogged table sales_mdam_paper_small
(
  dept int4,
  sdate date,
  item_class serial,
  store int4,
  item int4,
  total_sales numeric
);
create index mdam_small_idx on sales_mdam_paper_small(dept, sdate, item_class, store);
vacuum analyze sales_mdam_paper_small;
-- Load data
insert into sales_mdam_paper_small (dept, sdate, item_class, store, total_sales)
select
  dept,
  '1995-01-01'::date + sdate,
  item_class,
  store,
  (random() * 500.0) as total_sales
from
  generate_series(1, 1) dept,
  generate_series(1, 4) sdate,
  generate_series(1, 8) item_class,
  generate_series(1, 3) store;
-- Mixes range arrays with conventional SAOPs, leading to confusion about
-- boundary conditions:
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate between '1995-01-04' and '1995-01-05'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
  ctid  | dept |   sdate    | item_class | store 
--------+------+------------+------------+-------
 (0,8)  |    1 | 01-04-1995 |          1 |     2
 (0,9)  |    1 | 01-04-1995 |          1 |     3
 (0,32) |    1 | 01-04-1995 |          3 |     2
 (0,33) |    1 | 01-04-1995 |          3 |     3
 (0,56) |    1 | 01-04-1995 |          5 |     2
 (0,57) |    1 | 01-04-1995 |          5 |     3
 (0,11) |    1 | 01-05-1995 |          1 |     2
 (0,12) |    1 | 01-05-1995 |          1 |     3
 (0,35) |    1 | 01-05-1995 |          3 |     2
 (0,36) |    1 | 01-05-1995 |          3 |     3
 (0,59) |    1 | 01-05-1995 |          5 |     2
 (0,60) |    1 | 01-05-1995 |          5 |     3
(12 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate between '1995-01-04' and '1995-01-05'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using mdam_small_idx on sales_mdam_paper_small  (cost=0.14..7.68 rows=1 width=22) (actual rows=12.00 loops=1)
   Index Cond: ((sdate >= '01-04-1995'::date) AND (sdate <= '01-05-1995'::date) AND (item_class = ANY ('{1,3,5}'::integer[])) AND (store = ANY ('{2,3}'::integer[])))
   Index Searches: 1
   Buffers: shared hit=2
(4 rows)

-- Non-skip-support, repeat "Mixes range arrays with conventional SAOPs,
-- leading to confusion about boundary conditions":
set skipscan_skipsupport_enabled=false;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate between '1995-01-04' and '1995-01-05'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
  ctid  | dept |   sdate    | item_class | store 
--------+------+------------+------------+-------
 (0,8)  |    1 | 01-04-1995 |          1 |     2
 (0,9)  |    1 | 01-04-1995 |          1 |     3
 (0,32) |    1 | 01-04-1995 |          3 |     2
 (0,33) |    1 | 01-04-1995 |          3 |     3
 (0,56) |    1 | 01-04-1995 |          5 |     2
 (0,57) |    1 | 01-04-1995 |          5 |     3
 (0,11) |    1 | 01-05-1995 |          1 |     2
 (0,12) |    1 | 01-05-1995 |          1 |     3
 (0,35) |    1 | 01-05-1995 |          3 |     2
 (0,36) |    1 | 01-05-1995 |          3 |     3
 (0,59) |    1 | 01-05-1995 |          5 |     2
 (0,60) |    1 | 01-05-1995 |          5 |     3
(12 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate between '1995-01-04' and '1995-01-05'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using mdam_small_idx on sales_mdam_paper_small  (cost=0.14..7.68 rows=1 width=22) (actual rows=12.00 loops=1)
   Index Cond: ((sdate >= '01-04-1995'::date) AND (sdate <= '01-05-1995'::date) AND (item_class = ANY ('{1,3,5}'::integer[])) AND (store = ANY ('{2,3}'::integer[])))
   Index Searches: 1
   Buffers: shared hit=2
(4 rows)

reset skipscan_skipsupport_enabled;
ERROR:  unrecognized configuration parameter "skipscan_skipsupport_enabled"
-- Same again, but this time we use different operators/constants to get the
-- same effective date range as original BETWEEN version:
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate > '1995-01-03' and sdate <= '1995-01-05'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
  ctid  | dept |   sdate    | item_class | store 
--------+------+------------+------------+-------
 (0,8)  |    1 | 01-04-1995 |          1 |     2
 (0,9)  |    1 | 01-04-1995 |          1 |     3
 (0,32) |    1 | 01-04-1995 |          3 |     2
 (0,33) |    1 | 01-04-1995 |          3 |     3
 (0,56) |    1 | 01-04-1995 |          5 |     2
 (0,57) |    1 | 01-04-1995 |          5 |     3
 (0,11) |    1 | 01-05-1995 |          1 |     2
 (0,12) |    1 | 01-05-1995 |          1 |     3
 (0,35) |    1 | 01-05-1995 |          3 |     2
 (0,36) |    1 | 01-05-1995 |          3 |     3
 (0,59) |    1 | 01-05-1995 |          5 |     2
 (0,60) |    1 | 01-05-1995 |          5 |     3
(12 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate > '1995-01-03' and sdate <= '1995-01-05'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using mdam_small_idx on sales_mdam_paper_small  (cost=0.14..7.68 rows=1 width=22) (actual rows=12.00 loops=1)
   Index Cond: ((sdate > '01-03-1995'::date) AND (sdate <= '01-05-1995'::date) AND (item_class = ANY ('{1,3,5}'::integer[])) AND (store = ANY ('{2,3}'::integer[])))
   Index Searches: 1
   Buffers: shared hit=2
(4 rows)

-- Ditto:
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate > '1995-01-03' and sdate < '1995-01-06'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
  ctid  | dept |   sdate    | item_class | store 
--------+------+------------+------------+-------
 (0,8)  |    1 | 01-04-1995 |          1 |     2
 (0,9)  |    1 | 01-04-1995 |          1 |     3
 (0,32) |    1 | 01-04-1995 |          3 |     2
 (0,33) |    1 | 01-04-1995 |          3 |     3
 (0,56) |    1 | 01-04-1995 |          5 |     2
 (0,57) |    1 | 01-04-1995 |          5 |     3
 (0,11) |    1 | 01-05-1995 |          1 |     2
 (0,12) |    1 | 01-05-1995 |          1 |     3
 (0,35) |    1 | 01-05-1995 |          3 |     2
 (0,36) |    1 | 01-05-1995 |          3 |     3
 (0,59) |    1 | 01-05-1995 |          5 |     2
 (0,60) |    1 | 01-05-1995 |          5 |     3
(12 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate > '1995-01-03' and sdate < '1995-01-06'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using mdam_small_idx on sales_mdam_paper_small  (cost=0.14..7.68 rows=1 width=22) (actual rows=12.00 loops=1)
   Index Cond: ((sdate > '01-03-1995'::date) AND (sdate < '01-06-1995'::date) AND (item_class = ANY ('{1,3,5}'::integer[])) AND (store = ANY ('{2,3}'::integer[])))
   Index Searches: 1
   Buffers: shared hit=2
(4 rows)

-- range on date has no lower bound (or lower bound is -inf):
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate < '1995-01-04'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
  ctid  | dept |   sdate    | item_class | store 
--------+------+------------+------------+-------
 (0,2)  |    1 | 01-02-1995 |          1 |     2
 (0,3)  |    1 | 01-02-1995 |          1 |     3
 (0,26) |    1 | 01-02-1995 |          3 |     2
 (0,27) |    1 | 01-02-1995 |          3 |     3
 (0,50) |    1 | 01-02-1995 |          5 |     2
 (0,51) |    1 | 01-02-1995 |          5 |     3
 (0,5)  |    1 | 01-03-1995 |          1 |     2
 (0,6)  |    1 | 01-03-1995 |          1 |     3
 (0,29) |    1 | 01-03-1995 |          3 |     2
 (0,30) |    1 | 01-03-1995 |          3 |     3
 (0,53) |    1 | 01-03-1995 |          5 |     2
 (0,54) |    1 | 01-03-1995 |          5 |     3
(12 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate < '1995-01-04'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Index Scan using mdam_small_idx on sales_mdam_paper_small  (cost=0.14..7.43 rows=1 width=22) (actual rows=12.00 loops=1)
   Index Cond: ((sdate < '01-04-1995'::date) AND (item_class = ANY ('{1,3,5}'::integer[])) AND (store = ANY ('{2,3}'::integer[])))
   Index Searches: 1
   Buffers: shared hit=2
(4 rows)

-- range on date has no upper bound (or upper bound is +inf):
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate > '1995-01-04'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
  ctid  | dept |   sdate    | item_class | store 
--------+------+------------+------------+-------
 (0,11) |    1 | 01-05-1995 |          1 |     2
 (0,12) |    1 | 01-05-1995 |          1 |     3
 (0,35) |    1 | 01-05-1995 |          3 |     2
 (0,36) |    1 | 01-05-1995 |          3 |     3
 (0,59) |    1 | 01-05-1995 |          5 |     2
 (0,60) |    1 | 01-05-1995 |          5 |     3
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  sdate > '1995-01-04'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Index Scan using mdam_small_idx on sales_mdam_paper_small  (cost=0.14..7.43 rows=1 width=22) (actual rows=6.00 loops=1)
   Index Cond: ((sdate > '01-04-1995'::date) AND (item_class = ANY ('{1,3,5}'::integer[])) AND (store = ANY ('{2,3}'::integer[])))
   Index Searches: 1
   Buffers: shared hit=2
(4 rows)

-- Now don't omit dept key, without changing rows returned:
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  dept between 0 and 100
  and sdate between '1995-01-04' and '1995-01-05'
  and item_class = 3
  and store = 2
order by dept, sdate, item_class, store;
  ctid  | dept |   sdate    | item_class | store 
--------+------+------------+------------+-------
 (0,32) |    1 | 01-04-1995 |          3 |     2
 (0,35) |    1 | 01-05-1995 |          3 |     2
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  dept between 0 and 100
  and sdate between '1995-01-04' and '1995-01-05'
  and item_class = 3
  and store = 2
order by dept, sdate, item_class, store;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using mdam_small_idx on sales_mdam_paper_small  (cost=0.14..4.17 rows=1 width=22) (actual rows=2.00 loops=1)
   Index Cond: ((dept >= 0) AND (dept <= 100) AND (sdate >= '01-04-1995'::date) AND (sdate <= '01-05-1995'::date) AND (item_class = 3) AND (store = 2))
   Index Searches: 1
   Buffers: shared hit=2
(4 rows)

-- Now don't omit dept key, without changing rows returned (matches original
-- query by including conventional SAOPs to make it harder to get right):
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  dept between 0 and 100
  and sdate between '1995-01-04' and '1995-01-05'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
  ctid  | dept |   sdate    | item_class | store 
--------+------+------------+------------+-------
 (0,8)  |    1 | 01-04-1995 |          1 |     2
 (0,9)  |    1 | 01-04-1995 |          1 |     3
 (0,32) |    1 | 01-04-1995 |          3 |     2
 (0,33) |    1 | 01-04-1995 |          3 |     3
 (0,56) |    1 | 01-04-1995 |          5 |     2
 (0,57) |    1 | 01-04-1995 |          5 |     3
 (0,11) |    1 | 01-05-1995 |          1 |     2
 (0,12) |    1 | 01-05-1995 |          1 |     3
 (0,35) |    1 | 01-05-1995 |          3 |     2
 (0,36) |    1 | 01-05-1995 |          3 |     3
 (0,59) |    1 | 01-05-1995 |          5 |     2
 (0,60) |    1 | 01-05-1995 |          5 |     3
(12 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select
  ctid, dept, sdate, item_class, store
from sales_mdam_paper_small
where
  dept between 0 and 100
  and sdate between '1995-01-04' and '1995-01-05'
  and item_class in (1, 3, 5)
  and store in (2, 3)
order by dept, sdate, item_class, store;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using mdam_small_idx on sales_mdam_paper_small  (cost=0.14..4.17 rows=1 width=22) (actual rows=12.00 loops=1)
   Index Cond: ((dept >= 0) AND (dept <= 100) AND (sdate >= '01-04-1995'::date) AND (sdate <= '01-05-1995'::date) AND (item_class = ANY ('{1,3,5}'::integer[])) AND (store = ANY ('{2,3}'::integer[])))
   Index Searches: 1
   Buffers: shared hit=2
(4 rows)

-----------------------
-- tenk1 test cases  --
-----------------------
set client_min_messages=error;
drop table if exists tenk1_skipscan;
reset client_min_messages;
CREATE UNLOGGED TABLE tenk1_skipscan (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
ALTER TABLE tenk1_skipscan SET (autovacuum_enabled=off);
\getenv abs_srcdir PG_ABS_SRCDIR
\set filename :abs_srcdir '/data/tenk.data'
COPY tenk1_skipscan FROM :'filename';
VACUUM ANALYZE tenk1_skipscan;
CREATE INDEX tenk1_skipscan_four_unique1 ON tenk1_skipscan (four, unique1);
prepare tenk1_four_skipscan as
SELECT four, unique1 FROM tenk1_skipscan
 WHERE unique1 = 444;
execute tenk1_four_skipscan;
 four | unique1 
------+---------
    0 |     444
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- master 30 hits
execute tenk1_four_skipscan;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using tenk1_skipscan_four_unique1 on tenk1_skipscan  (cost=0.29..11.47 rows=1 width=8) (actual rows=1.00 loops=1)
   Index Cond: (unique1 = 444)
   Heap Fetches: 0
   Index Searches: 5
   Buffers: shared hit=11
(5 rows)

deallocate tenk1_four_skipscan;
prepare tenk1_four_skipscan_with_saop as
select four, unique1 from tenk1_skipscan where unique1 in (4444, 4445) limit 3;
execute tenk1_four_skipscan_with_saop;
 four | unique1 
------+---------
    0 |    4444
    1 |    4445
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- master 31 hits
execute tenk1_four_skipscan_with_saop;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..20.95 rows=2 width=8) (actual rows=2.00 loops=1)
   Buffers: shared hit=13
   ->  Index Only Scan using tenk1_skipscan_four_unique1 on tenk1_skipscan  (cost=0.29..20.95 rows=2 width=8) (actual rows=2.00 loops=1)
         Index Cond: (unique1 = ANY ('{4444,4445}'::integer[]))
         Heap Fetches: 0
         Index Searches: 6
         Buffers: shared hit=13
(7 rows)

deallocate tenk1_four_skipscan_with_saop;
-- Challenge here is to not do significantly worse than master branch's
-- traditional full index scan, since skipping isn't going to work here:
drop index tenk1_skipscan_four_unique1;
CREATE INDEX tenk1_skipscan_hundred_unique1 ON tenk1_skipscan (hundred, unique1);
prepare tenk1_fallback_to_regular_fullscan as
SELECT hundred, unique1 FROM tenk1_skipscan
 WHERE unique1 = 444;
execute tenk1_fallback_to_regular_fullscan;
 hundred | unique1 
---------+---------
      44 |     444
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- master 30 hits
execute tenk1_fallback_to_regular_fullscan;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using tenk1_skipscan_hundred_unique1 on tenk1_skipscan  (cost=0.29..135.29 rows=1 width=8) (actual rows=1.00 loops=1)
   Index Cond: (unique1 = 444)
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=30
(5 rows)

deallocate tenk1_fallback_to_regular_fullscan;
drop index tenk1_skipscan_hundred_unique1;
CREATE INDEX tenk1_skipscan_two_four_twenty ON tenk1_skipscan (two, four, twenty);
-- This test case caught sloppiness in adding new "input" skip scan keys for
-- index attributes that already had = strategy scan keys:
set enable_hashagg=off; -- XXX 2024-12-18 force sort-based agg, to get stable test output
select distinct four, twenty from tenk1_skipscan
where four in (1, 2) and twenty in (1, 2);
 four | twenty 
------+--------
    1 |      1
    2 |      2
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select distinct four, twenty from tenk1_skipscan
where four in (1, 2) and twenty in (1, 2);
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Unique  (cost=41.55..45.30 rows=80 width=8) (actual rows=2.00 loops=1)
   Buffers: shared hit=11
   ->  Sort  (cost=41.55..42.80 rows=500 width=8) (actual rows=1000.00 loops=1)
         Sort Key: four, twenty
         Sort Method: quicksort  Memory: 48kB
         Buffers: shared hit=11
         ->  Index Only Scan using tenk1_skipscan_two_four_twenty on tenk1_skipscan  (cost=0.29..19.14 rows=500 width=8) (actual rows=1000.00 loops=1)
               Index Cond: ((four = ANY ('{1,2}'::integer[])) AND (twenty = ANY ('{1,2}'::integer[])))
               Heap Fetches: 0
               Index Searches: 5
               Buffers: shared hit=11
(11 rows)

set enable_indexonlyscan=on;
-- Redundant attributes test related to bug where equality input keys
-- spuriously get their own skip input key:
select distinct two, four, twenty, hundred
from tenk1_skipscan
where
  four in (0, 1)
  and four in (1, 2)
  and twenty = 1
order by two, four, twenty;
 two | four | twenty | hundred 
-----+------+--------+---------
   1 |    1 |      1 |       1
   1 |    1 |      1 |      21
   1 |    1 |      1 |      41
   1 |    1 |      1 |      61
   1 |    1 |      1 |      81
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select distinct two, four, twenty, hundred
from tenk1_skipscan
where
  four in (0, 1)
  and four in (1, 2)
  and twenty = 1
order by two, four, twenty;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Unique  (cost=170.51..171.76 rows=116 width=16) (actual rows=5.00 loops=1)
   Buffers: shared hit=271
   ->  Sort  (cost=170.51..170.82 rows=125 width=16) (actual rows=500.00 loops=1)
         Sort Key: two, four, hundred
         Sort Method: quicksort  Memory: 40kB
         Buffers: shared hit=271
         ->  Bitmap Heap Scan on tenk1_skipscan  (cost=10.72..166.15 rows=125 width=16) (actual rows=500.00 loops=1)
               Recheck Cond: ((four = ANY ('{0,1}'::integer[])) AND (four = ANY ('{1,2}'::integer[])) AND (twenty = 1))
               Heap Blocks: exact=263
               Buffers: shared hit=271
               ->  Bitmap Index Scan on tenk1_skipscan_two_four_twenty  (cost=0.00..10.69 rows=125 width=0) (actual rows=500.00 loops=1)
                     Index Cond: ((four = ANY ('{0,1}'::integer[])) AND (four = ANY ('{1,2}'::integer[])) AND (twenty = 1))
                     Index Searches: 4
                     Buffers: shared hit=8
(14 rows)

drop index tenk1_skipscan_two_four_twenty;
create index on tenk1_skipscan (two, four, twenty, hundred);
prepare tenk1_two_four_twenty_hundred_inequal as
select count(*), two, four, twenty, hundred
from tenk1_skipscan
where
  four in (1, 2, 3)
  and four = 1
  and twenty in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)
  and hundred < 50
group by two, four, twenty, hundred
order by two, four, twenty, hundred;
execute tenk1_two_four_twenty_hundred_inequal;
 count | two | four | twenty | hundred 
-------+-----+------+--------+---------
   100 |   1 |    1 |      1 |       1
   100 |   1 |    1 |      1 |      21
   100 |   1 |    1 |      1 |      41
   100 |   1 |    1 |      5 |       5
   100 |   1 |    1 |      5 |      25
   100 |   1 |    1 |      5 |      45
   100 |   1 |    1 |      9 |       9
   100 |   1 |    1 |      9 |      29
   100 |   1 |    1 |      9 |      49
   100 |   1 |    1 |     13 |      13
   100 |   1 |    1 |     13 |      33
   100 |   1 |    1 |     17 |      17
   100 |   1 |    1 |     17 |      37
(13 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute tenk1_two_four_twenty_hundred_inequal;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=0.29..42.66 rows=564 width=24) (actual rows=13.00 loops=1)
   Group Key: two, twenty, hundred
   Buffers: shared hit=12
   ->  Index Only Scan using tenk1_skipscan_two_four_twenty_hundred_idx on tenk1_skipscan  (cost=0.29..29.05 rows=797 width=16) (actual rows=1300.00 loops=1)
         Index Cond: ((four = ANY ('{1,2,3}'::integer[])) AND (four = 1) AND (twenty = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}'::integer[])) AND (hundred < 50))
         Heap Fetches: 0
         Index Searches: 4
         Buffers: shared hit=12
(8 rows)

deallocate tenk1_two_four_twenty_hundred_inequal;
-------------------------------------------------------------------------------
-- upper range tenk1 test case based on aggregates.out from regression tests --
-------------------------------------------------------------------------------
create index on tenk1_skipscan (unique1, unique2);
-- Closest match for regression test:
select unique1
from tenk1_skipscan
where unique1 > 2147483647
limit 3;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select unique1
from tenk1_skipscan
where unique1 > 2147483647
limit 3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   Buffers: shared hit=2
   ->  Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
         Index Cond: (unique1 > 2147483647)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- Same again, this time force a skip array on unique1, so that now we can
-- try to increment > to >=, but get overflow (this will make the scan qual
-- unsatisfiable, unlike the prior no-skip-array example):
--
-- XXX (November 15 2024) This used to work like this, then I stopped making
-- overflow make the qual unsatisfiable in order to make cross-type "> to >="
-- transformations work, and finally just today I decided that cross-type
-- transformations weren't going to happen -- and so we might as well have
-- this small thing in return (once you assume that cross-type support isn't
-- happening, which now seems inevitable, then it also seems easy to do this
-- marginal optimization too).
select unique1
from tenk1_skipscan
where unique1 > 2147483647
and unique2 = 101010 -- Forces unique1 to have skip array, so it gets skip array preprocessing
limit 3;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- no buffer hits this time
select unique1
from tenk1_skipscan
where unique1 > 2147483647
and unique2 = 101010 -- Forces unique1 to have skip array, so it gets skip array preprocessing
limit 3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   ->  Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
         Index Cond: ((unique1 > 2147483647) AND (unique2 = 101010))
         Heap Fetches: 0
         Index Searches: 0
 Planning:
   Buffers: shared hit=3
(7 rows)

-- (November 15 2024)
-- Same again, this time decrement < to <= instead (this will make the scan qual
-- unsatisfiable, too):
select unique1
from tenk1_skipscan
where unique1 < (-2147483648)::int4
and unique2 = 101010
limit 3;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- no buffer hits this time
select unique1
from tenk1_skipscan
where unique1 < (-2147483648)::int4
and unique2 = 101010
limit 3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   ->  Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
         Index Cond: ((unique1 < '-2147483648'::integer) AND (unique2 = 101010))
         Heap Fetches: 0
         Index Searches: 0
 Planning:
   Buffers: shared hit=3
(7 rows)

-- Variant:
select unique1
from tenk1_skipscan
where unique1 >= 2147483647
and unique2 = 101010 -- Forces unique1 to have skip array, so it gets skip array preprocessing
limit 3;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select unique1
from tenk1_skipscan
where unique1 >= 2147483647
and unique2 = 101010 -- Forces unique1 to have skip array, so it gets skip array preprocessing
limit 3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   Buffers: shared hit=2
   ->  Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
         Index Cond: ((unique1 >= 2147483647) AND (unique2 = 101010))
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- Variant:
select unique1
from tenk1_skipscan
where unique1 > 2147483648
limit 3;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select unique1
from tenk1_skipscan
where unique1 > 2147483648
limit 3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   Buffers: shared hit=2
   ->  Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
         Index Cond: (unique1 > '2147483648'::bigint)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- Same again, this time force a skip array on unique1, so that now we can
-- try and fail to increment > to >=:
select unique1
from tenk1_skipscan
where unique1 > 2147483648
and unique2 = 101010 -- Forces unique1 to have skip array, so it gets skip array preprocessing
limit 3;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select unique1
from tenk1_skipscan
where unique1 > 2147483648
and unique2 = 101010 -- Forces unique1 to have skip array, so it gets skip array preprocessing
limit 3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   Buffers: shared hit=2
   ->  Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
         Index Cond: ((unique1 > '2147483648'::bigint) AND (unique2 = 101010))
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- Variant:
select unique1
from tenk1_skipscan
where unique1 < (-2147483649)
limit 3;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select unique1
from tenk1_skipscan
where unique1 < (-2147483649)
limit 3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   Buffers: shared hit=2
   ->  Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
         Index Cond: (unique1 < '-2147483649'::bigint)
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- Same again, this time force a skip array on unique1, so that now we can
-- try and fail to increment < to <=:
select unique1
from tenk1_skipscan
where unique1 < (-2147483649)
and unique2 = 101010 -- Forces unique1 to have skip array, so it gets skip array preprocessing
limit 3;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- no buffer hits this time
select unique1
from tenk1_skipscan
where unique1 < (-2147483649)
and unique2 = 101010 -- Forces unique1 to have skip array, so it gets skip array preprocessing
limit 3;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   Buffers: shared hit=2
   ->  Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
         Index Cond: ((unique1 < '-2147483649'::bigint) AND (unique2 = 101010))
         Heap Fetches: 0
         Index Searches: 1
         Buffers: shared hit=2
 Planning:
   Buffers: shared hit=3
(9 rows)

-- SAOP project regression test that once failed 32-bit platforms including CI:
prepare floatbyref_preproc as
select
  unique1
from
  tenk1_skipscan
where
  unique1 < 3
  and unique1 <(-1)::bigint;
-- Note: This doesn't fail reliably when run on horse server (with "#define
-- USE_FLOAT8_BYVAL" commented out), though using ../coredump-run.sh seems to
-- help it to fail
execute floatbyref_preproc;
 unique1 
---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute floatbyref_preproc;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using tenk1_skipscan_unique1_unique2_idx on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=4) (actual rows=0.00 loops=1)
   Index Cond: ((unique1 < 3) AND (unique1 < '-1'::bigint))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=2
(5 rows)

deallocate floatbyref_preproc;
--------------------------------------------------------------------------------------------------
-- (November 15) Cross-type opclasses from datetime_ops opfamily "> to >=" transformation tests --
--------------------------------------------------------------------------------------------------
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
set client_min_messages=error;
drop table if exists timestamp_date_crosstype_test;
reset client_min_messages;
create unlogged table timestamp_date_crosstype_test(
  t timestamp,
  i int4
);
create index timestamp_date_crosstype_test_idx on timestamp_date_crosstype_test (t, i);
insert into timestamp_date_crosstype_test
select ('1995-01-01'::date + i)::timestamp + interval '1 second', i
from generate_series(0, 100) i;
vacuum analyze timestamp_date_crosstype_test;
-- This had better not increment "t > 1995-01-01" into "t >= 1995-01-02",
-- given that the underlying column is actually a timestamp, not a date:
select *
from timestamp_date_crosstype_test
where
  t > '1995-01-01'::date and i = 0;
            t             | i 
--------------------------+---
 Sun Jan 01 00:00:01 1995 | 0
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from timestamp_date_crosstype_test
where
  t > '1995-01-01'::date and i = 0;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on timestamp_date_crosstype_test  (cost=5.15..7.17 rows=1 width=12) (actual rows=1.00 loops=1)
   Recheck Cond: ((t > '01-01-1995'::date) AND (i = 0))
   Heap Blocks: exact=1
   Buffers: shared hit=2
   ->  Bitmap Index Scan on timestamp_date_crosstype_test_idx  (cost=0.00..5.15 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((t > '01-01-1995'::date) AND (i = 0))
         Index Searches: 1
         Buffers: shared hit=1
 Planning:
   Buffers: shared hit=2
(10 rows)

-- Same again, but timestamptz this time (just for good luck):
set client_min_messages=error;
drop table if exists timestamptz_date_crosstype_test;
reset client_min_messages;
create unlogged table timestamptz_date_crosstype_test(
  t timestamptz,
  i int4
);
create index timestamptz_date_crosstype_test_idx on timestamptz_date_crosstype_test (t, i);
insert into timestamptz_date_crosstype_test
select ('1995-01-01'::date + i)::timestamptz + interval '1 second', i
from generate_series(0, 100) i;
vacuum analyze timestamptz_date_crosstype_test;
select *
from timestamptz_date_crosstype_test
where
  t > '1995-01-01'::date and i = 0;
              t               | i 
------------------------------+---
 Sun Jan 01 00:00:01 1995 PST | 0
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select *
from timestamptz_date_crosstype_test
where
  t > '1995-01-01'::date and i = 0;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on timestamptz_date_crosstype_test  (cost=5.15..7.17 rows=1 width=12) (actual rows=1.00 loops=1)
   Recheck Cond: ((t > '01-01-1995'::date) AND (i = 0))
   Heap Blocks: exact=1
   Buffers: shared hit=2
   ->  Bitmap Index Scan on timestamptz_date_crosstype_test_idx  (cost=0.00..5.15 rows=1 width=0) (actual rows=1.00 loops=1)
         Index Cond: ((t > '01-01-1995'::date) AND (i = 0))
         Index Searches: 1
         Buffers: shared hit=1
 Planning:
   Buffers: shared hit=2
(10 rows)

--------------------------------------------------------------------------
-- (July 9) Terminate scan promptly when name column lacks skip support --
--------------------------------------------------------------------------
create index name_no_skip_support on tenk1_skipscan (string4, tenthous);
set enable_bitmapscan to on;
set enable_indexonlyscan to on;
set enable_indexscan to on;
-- This query shouldn't have to access more than one leaf page (the leftmost),
-- since string4 < 'AAAAxx' condition matches tuples that are before any
-- actual extant tuples from the index:
prepare just_scan_leftmost_page as
select string4, tenthous
from tenk1_skipscan
where string4 < 'AAAAxx' and tenthous = 21;
execute just_scan_leftmost_page;
 string4 | tenthous 
---------+----------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- Expect only 2 buffer hits
execute just_scan_leftmost_page;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using name_no_skip_support on tenk1_skipscan  (cost=0.29..2.30 rows=1 width=68) (actual rows=0.00 loops=1)
   Index Cond: ((string4 < 'AAAAxx'::name) AND (tenthous = 21))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=2
(5 rows)

deallocate just_scan_leftmost_page;
-- Forwards scan
prepare terminate_name_ontime_inequality as
SELECT string4, tenthous FROM tenk1_skipscan
 WHERE string4 < 'OOOOxx' and tenthous in (131, 997, 5997, 992);
-- When first working on range skip scans + no-skip-support, had this one
-- remaining failure to terminate the scan when it reached the leaf page where
-- we naturally expect it to end.  The usual familiar assertion failure (with
-- a lack of any wrong answers to queries) proved as much:
-- TRAP: failed Assert("!_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts, false, 0, NULL)"), File: "../source/src/backend/access/nbtree/nbtutils.c", Line: 3063, PID: 497118
-- [0x55627e45e524] _bt_advance_array_keys: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtutils.c:3062
-- [0x55627e45d20a] _bt_checkkeys: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtutils.c:5070
-- [0x55627e450d7f] _bt_readpage: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtsearch.c:2288
-- [0x55627e4500fb] _bt_first: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtsearch.c:1955
-- [0x55627e449e74] btgettuple: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtree.c:259
-- [0x55627e436625] index_getnext_tid: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/index/indexam.c:590
execute terminate_name_ontime_inequality;
 string4 | tenthous 
---------+----------
 AAAAxx  |      131
 AAAAxx  |      997
 HHHHxx  |      992
 HHHHxx  |     5997
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute terminate_name_ontime_inequality;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using name_no_skip_support on tenk1_skipscan  (cost=0.29..18.38 rows=2 width=68) (actual rows=4.00 loops=1)
   Index Cond: ((string4 < 'OOOOxx'::name) AND (tenthous = ANY ('{131,997,5997,992}'::integer[])))
   Heap Fetches: 0
   Index Searches: 6
   Buffers: shared hit=13
(5 rows)

deallocate terminate_name_ontime_inequality;
-- Backwards scan
prepare terminate_name_ontime_inequality_backwards as
SELECT string4, tenthous FROM tenk1_skipscan
 WHERE string4 < 'OOOOxx' and tenthous in (131, 997, 5997, 992) order by string4 desc, tenthous desc;
execute terminate_name_ontime_inequality_backwards;
 string4 | tenthous 
---------+----------
 HHHHxx  |     5997
 HHHHxx  |      992
 AAAAxx  |      997
 AAAAxx  |      131
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute terminate_name_ontime_inequality_backwards;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using name_no_skip_support on tenk1_skipscan  (cost=0.29..18.38 rows=2 width=68) (actual rows=4.00 loops=1)
   Index Cond: ((string4 < 'OOOOxx'::name) AND (tenthous = ANY ('{131,997,5997,992}'::integer[])))
   Heap Fetches: 0
   Index Searches: 6
   Buffers: shared hit=13
(5 rows)

deallocate terminate_name_ontime_inequality_backwards;
drop index name_no_skip_support;
-- (July 12) This is like the create_view.sql failure in the regression tests
-- (seen once skipping was enabled on catalog indexes)
--
-- This fails due to a simple lack of cross-type support in places where we
-- need to use non-input-opclass-type-typed inequality sk_argument values.
create index stringu1_tenthous_idx on tenk1_skipscan (stringu1, tenthous);
-- Simplest version:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  -- Original: stringu1 like 'A_%' and tenthous in (5174, 7384, 9438)
  stringu1 >= 'A'::text and stringu1 < 'B'::text and tenthous in (5174, 7384, 9438)
order by stringu1, tenthous;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ARAAAA   |     5174
 AYAAAA   |     7384
 AZAAAA   |     9438
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 >= 'A'::text) AND (stringu1 < 'B'::text) AND (tenthous = ANY ('{5174,7384,9438}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=4
(5 rows)

deallocate like_test;
-- Same, but this time as a backwards scan:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  -- Original: stringu1 like 'A_%' and tenthous in (5174, 7384, 9438)
  stringu1 >= 'A'::text and stringu1 < 'B'::text and tenthous in (5174, 7384, 9438)
order by stringu1 desc, tenthous desc;
execute like_test;
 stringu1 | tenthous 
----------+----------
 AZAAAA   |     9438
 AYAAAA   |     7384
 ARAAAA   |     5174
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 >= 'A'::text) AND (stringu1 < 'B'::text) AND (tenthous = ANY ('{5174,7384,9438}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=4
(5 rows)

deallocate like_test;
-- Other end of index this time:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  -- Original: stringu1 like 'Z_%' and tenthous in (25, 8787, 571)
  stringu1 >= 'Z'::text and stringu1 < '['::text and tenthous in (25, 8787, 571)
order by stringu1, tenthous;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ZAAAAA   |       25
 ZVAAAA   |      571
 ZZAAAA   |     8787
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 >= 'Z'::text) AND (stringu1 < '['::text) AND (tenthous = ANY ('{25,8787,571}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=5
(5 rows)

deallocate like_test;
-- Same, but this time as a backwards scan:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  -- Original: stringu1 like 'Z_%' and tenthous in (25, 8787, 571)
  stringu1 >= 'Z'::text and stringu1 < '['::text and tenthous in (25, 8787, 571)
order by stringu1 desc, tenthous desc;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ZZAAAA   |     8787
 ZVAAAA   |      571
 ZAAAAA   |       25
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 >= 'Z'::text) AND (stringu1 < '['::text) AND (tenthous = ANY ('{25,8787,571}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=5
(5 rows)

deallocate like_test;
-- (July 16) Variants with mixed inequalities:
-- > and < variants:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > '@'::text and stringu1 < 'B'::text and tenthous in (5174, 7384, 9438)
order by stringu1, tenthous;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ARAAAA   |     5174
 AYAAAA   |     7384
 AZAAAA   |     9438
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > '@'::text) AND (stringu1 < 'B'::text) AND (tenthous = ANY ('{5174,7384,9438}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=4
(5 rows)

deallocate like_test;
-- Same, but this time as a backwards scan:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > '@'::text and stringu1 < 'B'::text and tenthous in (5174, 7384, 9438)
order by stringu1 desc, tenthous desc;
execute like_test;
 stringu1 | tenthous 
----------+----------
 AZAAAA   |     9438
 AYAAAA   |     7384
 ARAAAA   |     5174
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > '@'::text) AND (stringu1 < 'B'::text) AND (tenthous = ANY ('{5174,7384,9438}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=4
(5 rows)

deallocate like_test;
-- Other end of index this time:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > 'Y'::text and stringu1 < '['::text and tenthous in (25, 8787, 571)
order by stringu1, tenthous;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ZAAAAA   |       25
 ZVAAAA   |      571
 ZZAAAA   |     8787
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..17.86 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > 'Y'::text) AND (stringu1 < '['::text) AND (tenthous = ANY ('{25,8787,571}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=6
(5 rows)

deallocate like_test;
-- Same, but this time as a backwards scan:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > 'Y'::text and stringu1 < '['::text and tenthous in (25, 8787, 571)
order by stringu1 desc, tenthous desc;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ZZAAAA   |     8787
 ZVAAAA   |      571
 ZAAAAA   |       25
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..17.86 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > 'Y'::text) AND (stringu1 < '['::text) AND (tenthous = ANY ('{25,8787,571}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=6
(5 rows)

deallocate like_test;
-- > and <= variants:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > '@'::text and stringu1 <= 'AZZZZZZ'::text and tenthous in (5174, 7384, 9438)
order by stringu1, tenthous;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ARAAAA   |     5174
 AYAAAA   |     7384
 AZAAAA   |     9438
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > '@'::text) AND (stringu1 <= 'AZZZZZZ'::text) AND (tenthous = ANY ('{5174,7384,9438}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=4
(5 rows)

deallocate like_test;
-- Same, but this time as a backwards scan:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > '@'::text and stringu1 <= 'AZZZZZZ'::text and tenthous in (5174, 7384, 9438)
order by stringu1 desc, tenthous desc;
execute like_test;
 stringu1 | tenthous 
----------+----------
 AZAAAA   |     9438
 AYAAAA   |     7384
 ARAAAA   |     5174
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > '@'::text) AND (stringu1 <= 'AZZZZZZ'::text) AND (tenthous = ANY ('{5174,7384,9438}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=4
(5 rows)

deallocate like_test;
-- Other end of index this time:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > 'Y'::text and stringu1 <= 'Z{'::text and tenthous in (25, 8787, 571)
order by stringu1, tenthous;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ZAAAAA   |       25
 ZVAAAA   |      571
 ZZAAAA   |     8787
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..17.86 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > 'Y'::text) AND (stringu1 <= 'Z{'::text) AND (tenthous = ANY ('{25,8787,571}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=6
(5 rows)

deallocate like_test;
-- Same, but this time as a backwards scan:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > 'Y'::text and stringu1 <= 'Z{'::text and tenthous in (25, 8787, 571)
order by stringu1 desc, tenthous desc;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ZZAAAA   |     8787
 ZVAAAA   |      571
 ZAAAAA   |       25
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using stringu1_tenthous_idx on tenk1_skipscan  (cost=0.29..17.86 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > 'Y'::text) AND (stringu1 <= 'Z{'::text) AND (tenthous = ANY ('{25,8787,571}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=6
(5 rows)

deallocate like_test;
-- (July 16) This time with DESC index cols, to make sure that we have
-- backwards scan coverage (using non-cross-type comparator accidentally fails
-- to fail without this extra dimension):
-- instead:
drop index stringu1_tenthous_idx;
create index stringu1_tenthous_desc_idx on tenk1_skipscan (stringu1 desc, tenthous desc);
-- > and <= variants:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > '@'::text and stringu1 <= 'AZZZZZZ'::text and tenthous in (5174, 7384, 9438)
order by stringu1, tenthous;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ARAAAA   |     5174
 AYAAAA   |     7384
 AZAAAA   |     9438
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using stringu1_tenthous_desc_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > '@'::text) AND (stringu1 <= 'AZZZZZZ'::text) AND (tenthous = ANY ('{5174,7384,9438}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=5
(5 rows)

deallocate like_test;
-- Same, but this time as a backwards scan:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > '@'::text and stringu1 <= 'AZZZZZZ'::text and tenthous in (5174, 7384, 9438)
order by stringu1 desc, tenthous desc;
execute like_test;
 stringu1 | tenthous 
----------+----------
 AZAAAA   |     9438
 AYAAAA   |     7384
 ARAAAA   |     5174
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using stringu1_tenthous_desc_idx on tenk1_skipscan  (cost=0.29..28.18 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > '@'::text) AND (stringu1 <= 'AZZZZZZ'::text) AND (tenthous = ANY ('{5174,7384,9438}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=5
(5 rows)

deallocate like_test;
-- Other end of index this time:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > 'Y'::text and stringu1 <= 'Z{'::text and tenthous in (25, 8787, 571)
order by stringu1, tenthous;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ZAAAAA   |       25
 ZVAAAA   |      571
 ZZAAAA   |     8787
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan Backward using stringu1_tenthous_desc_idx on tenk1_skipscan  (cost=0.29..17.86 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > 'Y'::text) AND (stringu1 <= 'Z{'::text) AND (tenthous = ANY ('{25,8787,571}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=5
(5 rows)

deallocate like_test;
-- Same, but this time as a backwards scan:
prepare like_test as
select stringu1, tenthous from tenk1_skipscan
where
  stringu1 > 'Y'::text and stringu1 <= 'Z{'::text and tenthous in (25, 8787, 571)
order by stringu1 desc, tenthous desc;
execute like_test;
 stringu1 | tenthous 
----------+----------
 ZZAAAA   |     8787
 ZVAAAA   |      571
 ZAAAAA   |       25
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
execute like_test;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Index Only Scan using stringu1_tenthous_desc_idx on tenk1_skipscan  (cost=0.29..17.86 rows=1 width=68) (actual rows=3.00 loops=1)
   Index Cond: ((stringu1 > 'Y'::text) AND (stringu1 <= 'Z{'::text) AND (tenthous = ANY ('{25,8787,571}'::integer[])))
   Heap Fetches: 0
   Index Searches: 1
   Buffers: shared hit=5
(5 rows)

deallocate like_test;
---------------------------
-- Wisconsin table tests --
---------------------------
set client_min_messages=error;
drop table if exists wisconsin;
reset client_min_messages;
create unlogged table wisconsin
(
unique1 int4,
unique2 int4,
two int4,
four int4,
ten int4,
twenty int4,
onepercent int4,
tenpercent int4,
twentypercent int4,
fiftypercent int4,
unique3 int4,
evenonepercent int4,
oddonepercent int4,
stringu1 text,
stringu2 text,
string4 text
);
\set filename :abs_srcdir '/data/wisconsin.csv'
COPY wisconsin FROM :'filename' with (format csv, encoding 'win1252', header false, null $$$$, quote $$'$$); -- Fix the syntax highlighting: '
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select
  5555,
  5555,
  2147483646,
  2147483646,
  2147483646,
  2147483646,
  2147483646;
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select
  5555,
  5555,
  2147483647,
  2147483647,
  2147483647,
  2147483647,
  2147483647;
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select
  5555,
  5555,
(-2147483647),
(-2147483647),
(-2147483647),
(-2147483647),
(-2147483647);
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select
  5555,
  5555,(-2147483648),
(-2147483648),
(-2147483648),
(-2147483648),
(-2147483648);
vacuum analyze wisconsin;
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Two:
create index two_idx on wisconsin (two, unique1);
select two, unique1 from wisconsin where unique1 = 5555;
     two     | unique1 
-------------+---------
           0 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select two, unique1 from wisconsin where unique1 = 5555;
                          QUERY PLAN                           
---------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=5.00 loops=1)
   Recheck Cond: (unique1 = 5555)
   Heap Blocks: exact=2
   Buffers: shared hit=14
   ->  Bitmap Index Scan on two_idx (actual rows=5.00 loops=1)
         Index Cond: (unique1 = 5555)
         Index Searches: 4
         Buffers: shared hit=12
(8 rows)

drop index two_idx;
-- Four:
create index four_idx on wisconsin (four, unique1);
-- Point lookup:
select four, unique1 from wisconsin where unique1 = 5555;
    four     | unique1 
-------------+---------
           0 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select four, unique1 from wisconsin where unique1 = 5555;
                           QUERY PLAN                           
----------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=5.00 loops=1)
   Recheck Cond: (unique1 = 5555)
   Heap Blocks: exact=2
   Buffers: shared hit=20
   ->  Bitmap Index Scan on four_idx (actual rows=5.00 loops=1)
         Index Cond: (unique1 = 5555)
         Index Searches: 6
         Buffers: shared hit=18
(8 rows)

-- SAOP:
select four, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
    four     | unique1 
-------------+---------
           1 |  200000
           3 |  100000
           1 |       1
           0 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(8 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select four, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=8.00 loops=1)
   Recheck Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
   Heap Blocks: exact=5
   Buffers: shared hit=56
   ->  Bitmap Index Scan on four_idx (actual rows=8.00 loops=1)
         Index Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
         Index Searches: 17
         Buffers: shared hit=51
(8 rows)

drop index four_idx;
-- Ten:
create index ten_idx on wisconsin (ten, unique1);
-- Point lookup:
select ten, unique1 from wisconsin where unique1 = 5555;
     ten     | unique1 
-------------+---------
           2 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select ten, unique1 from wisconsin where unique1 = 5555;
                          QUERY PLAN                           
---------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=5.00 loops=1)
   Recheck Cond: (unique1 = 5555)
   Heap Blocks: exact=2
   Buffers: shared hit=38
   ->  Bitmap Index Scan on ten_idx (actual rows=5.00 loops=1)
         Index Cond: (unique1 = 5555)
         Index Searches: 12
         Buffers: shared hit=36
(8 rows)

-- Range instead of skip attribute on "ten":
prepare range_instead as
select ten, unique1 from wisconsin where ten between -10000 and 4 and unique1 = 5555;
execute range_instead;
 ten | unique1 
-----+---------
   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF)
execute range_instead;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((ten >= '-10000'::integer) AND (ten <= 4) AND (unique1 = 5555))
   Heap Blocks: exact=1
   Buffers: shared hit=19
   ->  Bitmap Index Scan on ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((ten >= '-10000'::integer) AND (ten <= 4) AND (unique1 = 5555))
         Index Searches: 6
         Buffers: shared hit=18
(8 rows)

-- Range instead of skip attribute on "ten", backwards scan:
set enable_bitmapscan to off;
set enable_indexscan to on;
prepare range_instead_backwards as
select ten, unique1 from wisconsin where ten between -10000 and 4 and unique1 = 5555 order by ten desc, unique1 desc;
execute range_instead_backwards;
 ten | unique1 
-----+---------
   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF)
execute range_instead_backwards;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Index Scan Backward using ten_idx on wisconsin (actual rows=1.00 loops=1)
   Index Cond: ((ten >= '-10000'::integer) AND (ten <= 4) AND (unique1 = 5555))
   Index Searches: 6
   Buffers: shared hit=19
(4 rows)

set enable_bitmapscan to on;
set enable_indexscan to off;
-- SAOP:
select ten, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
     ten     | unique1 
-------------+---------
           9 |  200000
           3 |  100000
           9 |       1
           2 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(8 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select ten, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=8.00 loops=1)
   Recheck Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
   Heap Blocks: exact=5
   Buffers: shared hit=128
   ->  Bitmap Index Scan on ten_idx (actual rows=8.00 loops=1)
         Index Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
         Index Searches: 41
         Buffers: shared hit=123
(8 rows)

-- Contradictory qual:
-- XXX consider adding preprocessing to detect this case.
select ten, unique1 from wisconsin where unique1 between 101 and 100;
 ten | unique1 
-----+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits, patch 0 hits, since patch detects >= and <= related contradictoriness
select ten, unique1 from wisconsin where unique1 between 101 and 100;
                          QUERY PLAN                           
---------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=0.00 loops=1)
   Recheck Cond: ((unique1 >= 101) AND (unique1 <= 100))
   Buffers: shared hit=34
   ->  Bitmap Index Scan on ten_idx (actual rows=0.00 loops=1)
         Index Cond: ((unique1 >= 101) AND (unique1 <= 100))
         Index Searches: 11
         Buffers: shared hit=34
(7 rows)

-- Contradictory qual, > and < strategies:
-- XXX consider adding preprocessing to detect this case.
select ten, unique1 from wisconsin where unique1 > 100 and unique1 < 100;
 ten | unique1 
-----+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select ten, unique1 from wisconsin where unique1 > 100 and unique1 < 100;
                          QUERY PLAN                           
---------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=0.00 loops=1)
   Recheck Cond: ((unique1 > 100) AND (unique1 < 100))
   Buffers: shared hit=34
   ->  Bitmap Index Scan on ten_idx (actual rows=0.00 loops=1)
         Index Cond: ((unique1 > 100) AND (unique1 < 100))
         Index Searches: 11
         Buffers: shared hit=34
(7 rows)

-- Contradictory qual, > and < strategies, many operators:
-- XXX consider adding preprocessing to detect this case.
select ten, unique1 from wisconsin
where
unique1 > 1 and
unique1 < 400 and
unique1 > 90 and
unique1 > 100 and
unique1 < 100
;
 ten | unique1 
-----+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select ten, unique1 from wisconsin
where
unique1 > 1 and
unique1 < 400 and
unique1 > 90 and
unique1 > 100 and
unique1 < 100
;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=0.00 loops=1)
   Recheck Cond: ((unique1 > 1) AND (unique1 < 400) AND (unique1 > 90) AND (unique1 > 100) AND (unique1 < 100))
   Buffers: shared hit=34
   ->  Bitmap Index Scan on ten_idx (actual rows=0.00 loops=1)
         Index Cond: ((unique1 > 1) AND (unique1 < 400) AND (unique1 > 90) AND (unique1 > 100) AND (unique1 < 100))
         Index Searches: 11
         Buffers: shared hit=34
(7 rows)

-- Just one constant generate by skip array (100):
select ten, unique1 from wisconsin where unique1 between 100 and 100;
 ten | unique1 
-----+---------
   9 |     100
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select ten, unique1 from wisconsin where unique1 between 100 and 100;
                          QUERY PLAN                           
---------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((unique1 >= 100) AND (unique1 <= 100))
   Heap Blocks: exact=1
   Buffers: shared hit=35
   ->  Bitmap Index Scan on ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((unique1 >= 100) AND (unique1 <= 100))
         Index Searches: 11
         Buffers: shared hit=34
(8 rows)

-- Just one constant generate by skip array (100), > and < strategies:
select unique1 from wisconsin where unique1 > 99 and unique1 < 101;
 unique1 
---------
     100
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select unique1 from wisconsin where unique1 > 99 and unique1 < 101;
                          QUERY PLAN                           
---------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((unique1 > 99) AND (unique1 < 101))
   Heap Blocks: exact=1
   Buffers: shared hit=35
   ->  Bitmap Index Scan on ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((unique1 > 99) AND (unique1 < 101))
         Index Searches: 11
         Buffers: shared hit=34
(8 rows)

-- Just one constant generate by skip array (100), > and < strategies, many operators:
select unique1 from wisconsin
where
unique1 > 1 and
unique1 < 400 and
unique1 > 90 and
unique1 > 99 and
unique1 < 101
;
 unique1 
---------
     100
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select unique1 from wisconsin
where
unique1 > 1 and
unique1 < 400 and
unique1 > 90 and
unique1 > 99 and
unique1 < 101
;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((unique1 > 1) AND (unique1 < 400) AND (unique1 > 90) AND (unique1 > 99) AND (unique1 < 101))
   Heap Blocks: exact=1
   Buffers: shared hit=35
   ->  Bitmap Index Scan on ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((unique1 > 1) AND (unique1 < 400) AND (unique1 > 90) AND (unique1 > 99) AND (unique1 < 101))
         Index Searches: 11
         Buffers: shared hit=34
(8 rows)

drop index ten_idx;
-- Four, ten:
create index four_ten_idx on wisconsin (four, ten, unique1);
-- Point lookup, skips two cols (four and ten):
select four, ten, unique1 from wisconsin where unique1 = 5555;
    four     |     ten     | unique1 
-------------+-------------+---------
           0 |           2 |    5555
  2147483646 |  2147483646 |    5555
  2147483647 |  2147483647 |    5555
 -2147483647 | -2147483647 |    5555
 -2147483648 | -2147483648 |    5555
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 1152 hits
select four, ten, unique1 from wisconsin where unique1 = 5555;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=5.00 loops=1)
   Recheck Cond: (unique1 = 5555)
   Heap Blocks: exact=2
   Buffers: shared hit=125
   ->  Bitmap Index Scan on four_ten_idx (actual rows=5.00 loops=1)
         Index Cond: (unique1 = 5555)
         Index Searches: 41
         Buffers: shared hit=123
(8 rows)

-- Point lookup, skips one col (four), range on other col after that (ten):
select four, ten, unique1 from wisconsin where ten between -10000 and 4 and unique1 = 5555;
 four | ten | unique1 
------+-----+---------
    0 |   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 1152 hits
select four, ten, unique1 from wisconsin where ten between -10000 and 4 and unique1 = 5555;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((ten >= '-10000'::integer) AND (ten <= 4) AND (unique1 = 5555))
   Heap Blocks: exact=1
   Buffers: shared hit=70
   ->  Bitmap Index Scan on four_ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((ten >= '-10000'::integer) AND (ten <= 4) AND (unique1 = 5555))
         Index Searches: 23
         Buffers: shared hit=69
(8 rows)

-- Should be able to handle BETWEEN ranges with same value for >= and <=:
prepare handle_between as
select four, ten, unique1 from wisconsin where four between 0 and 0 and unique1 = 5555;
execute handle_between;
 four | ten | unique1 
------+-----+---------
    0 |   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF)
execute handle_between;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((four >= 0) AND (four <= 0) AND (unique1 = 5555))
   Heap Blocks: exact=1
   Buffers: shared hit=34
   ->  Bitmap Index Scan on four_ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((four >= 0) AND (four <= 0) AND (unique1 = 5555))
         Index Searches: 11
         Buffers: shared hit=33
(8 rows)

-- Missing predicate is in "intermediate" column (ten) here:
select four, ten, unique1 from wisconsin where four = 0 and unique1 = 5555;
 four | ten | unique1 
------+-----+---------
    0 |   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF) -- master 290 hits, patch 33 hits
select four, ten, unique1 from wisconsin where four = 0 and unique1 = 5555;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((four = 0) AND (unique1 = 5555))
   Heap Blocks: exact=1
   Buffers: shared hit=34
   ->  Bitmap Index Scan on four_ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((four = 0) AND (unique1 = 5555))
         Index Searches: 11
         Buffers: shared hit=33
(8 rows)

-- Missing predicate is in "intermediate" column (ten) here, plus we use a
-- SAOP for unique1 this time around:
select four, ten, unique1 from wisconsin where four = 0 and unique1 in (41, 5555, 299118, 300000);
 four | ten | unique1 
------+-----+---------
    0 |   0 |      41
    0 |   2 |    5555
    0 |   8 |  299118
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF) -- master 290 hits, patch 33 hits
select four, ten, unique1 from wisconsin where four = 0 and unique1 in (41, 5555, 299118, 300000);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=3.00 loops=1)
   Recheck Cond: ((four = 0) AND (unique1 = ANY ('{41,5555,299118,300000}'::integer[])))
   Heap Blocks: exact=3
   Buffers: shared hit=36
   ->  Bitmap Index Scan on four_ten_idx (actual rows=3.00 loops=1)
         Index Cond: ((four = 0) AND (unique1 = ANY ('{41,5555,299118,300000}'::integer[])))
         Index Searches: 11
         Buffers: shared hit=33
(8 rows)

-- SAOP:
select four, ten, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
    four     |     ten     | unique1 
-------------+-------------+---------
           1 |           9 |  200000
           3 |           3 |  100000
           1 |           9 |       1
           0 |           2 |    5555
  2147483646 |  2147483646 |    5555
  2147483647 |  2147483647 |    5555
 -2147483647 | -2147483647 |    5555
 -2147483648 | -2147483648 |    5555
(8 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF) -- master 1152 hits
select four, ten, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=8.00 loops=1)
   Recheck Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
   Heap Blocks: exact=5
   Buffers: shared hit=248
   ->  Bitmap Index Scan on four_ten_idx (actual rows=8.00 loops=1)
         Index Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
         Index Searches: 81
         Buffers: shared hit=243
(8 rows)

-- backwards scans:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Simple backwards scan (failed once, simplified from next test case):
select four, ten, unique1
from wisconsin
where unique1 = 1
order by four desc, ten desc, unique1 desc;
 four | ten | unique1 
------+-----+---------
    1 |   9 |       1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF) -- master 1156 hits
select four, ten, unique1
from wisconsin
where unique1 = 1
order by four desc, ten desc, unique1 desc;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Index Scan Backward using four_ten_idx on wisconsin (actual rows=1.00 loops=1)
   Index Cond: (unique1 = 1)
   Index Searches: 21
   Buffers: shared hit=64
(4 rows)

-- SAOP backwards scan:
select four, ten, unique1
from wisconsin
where unique1 in (1, 5555, 100000, 200000)
order by four desc, ten desc, unique1 desc;
    four     |     ten     | unique1 
-------------+-------------+---------
  2147483647 |  2147483647 |    5555
  2147483646 |  2147483646 |    5555
           3 |           3 |  100000
           1 |           9 |  200000
           1 |           9 |       1
           0 |           2 |    5555
 -2147483647 | -2147483647 |    5555
 -2147483648 | -2147483648 |    5555
(8 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF) -- master 1156 hits
select four, ten, unique1
from wisconsin
where unique1 in (1, 5555, 100000, 200000)
order by four desc, ten desc, unique1 desc;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Index Scan Backward using four_ten_idx on wisconsin (actual rows=8.00 loops=1)
   Index Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
   Index Searches: 81
   Buffers: shared hit=249
(4 rows)

-- One omitted attribute (four) followed by two SAOPs
select four, ten, unique1
from wisconsin
where
  ten in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  and unique1 in (41, 5555, 299118, 300000);
 four | ten | unique1 
------+-----+---------
    0 |   0 |      41
    0 |   2 |    5555
    0 |   8 |  299118
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF)
select four, ten, unique1
from wisconsin
where
  ten in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  and unique1 in (41, 5555, 299118, 300000);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Index Scan using four_ten_idx on wisconsin (actual rows=3.00 loops=1)
   Index Cond: ((ten = ANY ('{0,1,2,3,4,5,6,7,8,9}'::integer[])) AND (unique1 = ANY ('{41,5555,299118,300000}'::integer[])))
   Index Searches: 44
   Buffers: shared hit=135
(4 rows)

drop index four_ten_idx;
-- SAOP, DESC index, forward scan (forward relative to DESC direction):
create index four_desc_ten_desc_idx on wisconsin (four desc, ten desc, unique1 desc);
select four, ten, unique1
from wisconsin
where unique1 in (1, 5555, 100000, 200000)
order by four desc, ten desc, unique1 desc;
    four     |     ten     | unique1 
-------------+-------------+---------
  2147483647 |  2147483647 |    5555
  2147483646 |  2147483646 |    5555
           3 |           3 |  100000
           1 |           9 |  200000
           1 |           9 |       1
           0 |           2 |    5555
 -2147483647 | -2147483647 |    5555
 -2147483648 | -2147483648 |    5555
(8 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF) -- master 1156 hits
select four, ten, unique1
from wisconsin
where unique1 in (1, 5555, 100000, 200000)
order by four desc, ten desc, unique1 desc;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Index Scan using four_desc_ten_desc_idx on wisconsin (actual rows=8.00 loops=1)
   Index Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
   Index Searches: 81
   Buffers: shared hit=249
(4 rows)

-- SAOP, DESC index, backward scan (backward relative to DESC direction):
select four, ten, unique1
from wisconsin
where unique1 in (1, 5555, 100000, 200000)
order by four, ten, unique1;
    four     |     ten     | unique1 
-------------+-------------+---------
 -2147483648 | -2147483648 |    5555
 -2147483647 | -2147483647 |    5555
           0 |           2 |    5555
           1 |           9 |       1
           1 |           9 |  200000
           3 |           3 |  100000
  2147483646 |  2147483646 |    5555
  2147483647 |  2147483647 |    5555
(8 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF) -- master 1156 hits
select four, ten, unique1
from wisconsin
where unique1 in (1, 5555, 100000, 200000)
order by four, ten, unique1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Index Scan Backward using four_desc_ten_desc_idx on wisconsin (actual rows=8.00 loops=1)
   Index Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
   Index Searches: 81
   Buffers: shared hit=249
(4 rows)

drop index four_desc_ten_desc_idx;
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Twenty:
create index twenty_idx on wisconsin (twenty, unique1);
-- Point lookup:
select twenty, unique1 from wisconsin where unique1 = 5555;
   twenty    | unique1 
-------------+---------
          12 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select twenty, unique1 from wisconsin where unique1 = 5555;
                            QUERY PLAN                            
------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=5.00 loops=1)
   Recheck Cond: (unique1 = 5555)
   Heap Blocks: exact=2
   Buffers: shared hit=66
   ->  Bitmap Index Scan on twenty_idx (actual rows=5.00 loops=1)
         Index Cond: (unique1 = 5555)
         Index Searches: 21
         Buffers: shared hit=64
(8 rows)

-- SAOP:
select twenty, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
   twenty    | unique1 
-------------+---------
           9 |  200000
           3 |  100000
           9 |       1
          12 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(8 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select twenty, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=8.00 loops=1)
   Recheck Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
   Heap Blocks: exact=5
   Buffers: shared hit=245
   ->  Bitmap Index Scan on twenty_idx (actual rows=8.00 loops=1)
         Index Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
         Index Searches: 80
         Buffers: shared hit=240
(8 rows)

drop index twenty_idx;
-- Hundred/onepercent:
create index onepercent_idx on wisconsin (onepercent, unique1);
-- Point lookup:
select onepercent, unique1 from wisconsin where unique1 = 5555;
 onepercent  | unique1 
-------------+---------
          32 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(5 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select onepercent, unique1 from wisconsin where unique1 = 5555;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=5.00 loops=1)
   Recheck Cond: (unique1 = 5555)
   Heap Blocks: exact=2
   Buffers: shared hit=306
   ->  Bitmap Index Scan on onepercent_idx (actual rows=5.00 loops=1)
         Index Cond: (unique1 = 5555)
         Index Searches: 101
         Buffers: shared hit=304
(8 rows)

-- SAOP:
select onepercent, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
 onepercent  | unique1 
-------------+---------
          89 |  200000
          43 |  100000
           9 |       1
          32 |    5555
  2147483646 |    5555
  2147483647 |    5555
 -2147483647 |    5555
 -2147483648 |    5555
(8 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select onepercent, unique1 from wisconsin where unique1 in (1, 5555, 100000, 200000);
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=8.00 loops=1)
   Recheck Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
   Heap Blocks: exact=5
   Buffers: shared hit=956
   ->  Bitmap Index Scan on onepercent_idx (actual rows=8.00 loops=1)
         Index Cond: (unique1 = ANY ('{1,5555,100000,200000}'::integer[]))
         Index Searches: 317
         Buffers: shared hit=951
(8 rows)

-- (June 14, day after going into JFK 27 to have lunch (later dinner) with
-- jkatz)
--
-- Test case showing bug in _bt_advance_skip_array_increment when we wrap
-- around a scan key whose sk_argument is already INT_MAX.  We should
-- "increment" its scan key to NULL, the true final value.  The bug that we
-- saw here involved not returning the row with a NULL oncepercent and a
-- unique1 value of -666.  We'd actually skip straight past NULL, wrapping
-- back around to INT_MIN again, which was just wrong.
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select 1, 1, 1, 1, 1, 1, 2147483647 from generate_series(1, 1500) i;
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select 1, 1, 1, 1, 1, 1, (-2147483648)::int4 from generate_series(1, 1500) i;
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select -666, 1, 1, 1, 1, 1, 2147483647;
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select -666, 1, 1, 1, 1, 1, (-2147483648)::int4;
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select 1, 1, 1, 1, 1, 1, NULL from generate_series(1, 1500) i;
insert into wisconsin(unique1, unique2, two, four, ten, twenty, onepercent)
select -666, 1, 1, 1, 1, 1, NULL;
vacuum analyze wisconsin;
-- Force index scan
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- Main test
select onepercent, unique1 from wisconsin where unique1 = -666;
 onepercent  | unique1 
-------------+---------
 -2147483648 |    -666
  2147483647 |    -666
             |    -666
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select onepercent, unique1 from wisconsin where unique1 = -666;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Index Scan using onepercent_idx on wisconsin (actual rows=3.00 loops=1)
   Index Cond: (unique1 = '-666'::integer)
   Index Searches: 103
   Buffers: shared hit=313
(4 rows)

-- Same again, backwards scan
select onepercent, unique1 from wisconsin where unique1 = -666
order by onepercent desc, unique1 desc;
 onepercent  | unique1 
-------------+---------
             |    -666
  2147483647 |    -666
 -2147483648 |    -666
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select onepercent, unique1 from wisconsin where unique1 = -666
order by onepercent desc, unique1 desc;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Index Scan Backward using onepercent_idx on wisconsin (actual rows=3.00 loops=1)
   Index Cond: (unique1 = '-666'::integer)
   Index Searches: 103
   Buffers: shared hit=315
(4 rows)

drop index onepercent_idx;
-- Hundred/onepercent, nulls first, repeat last two test cases:
create index onepercent_nulls_first_idx on wisconsin (onepercent desc nulls first, unique1 desc nulls first);
-- Main test
select onepercent, unique1 from wisconsin where unique1 = -666;
 onepercent  | unique1 
-------------+---------
             |    -666
  2147483647 |    -666
 -2147483648 |    -666
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select onepercent, unique1 from wisconsin where unique1 = -666;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Index Scan using onepercent_nulls_first_idx on wisconsin (actual rows=3.00 loops=1)
   Index Cond: (unique1 = '-666'::integer)
   Index Searches: 103
   Buffers: shared hit=311
(4 rows)

-- Same again, backwards scan (this variant was broken briefly, when I only
-- had forward scan handling code in _bt_advance_skip_array_increment)
select onepercent, unique1 from wisconsin where unique1 = -666
order by onepercent, unique1;
 onepercent  | unique1 
-------------+---------
 -2147483648 |    -666
  2147483647 |    -666
             |    -666
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select onepercent, unique1 from wisconsin where unique1 = -666
order by onepercent, unique1;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Index Scan Backward using onepercent_nulls_first_idx on wisconsin (actual rows=3.00 loops=1)
   Index Cond: (unique1 = '-666'::integer)
   Index Searches: 103
   Buffers: shared hit=311
(4 rows)

drop index onepercent_nulls_first_idx;
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Four, ten, twenty, unique1 (causes errors about attribute order from
-- _by_preprocess_keys):
create index on wisconsin (four, ten, twenty, unique1);
select four, ten, twenty, unique1
from wisconsin
where
  ten between 1 and 10
  and twenty in (1, 2, 3)
  and unique1 in (84396, 217539, 60814);
 four | ten | twenty | unique1 
------+-----+--------+---------
    2 |   2 |      2 |  217539
    3 |   3 |      3 |   84396
    2 |   2 |      2 |   60814
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select four, ten, twenty, unique1
from wisconsin
where
  ten between 1 and 10
  and twenty in (1, 2, 3)
  and unique1 in (84396, 217539, 60814);
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=3.00 loops=1)
   Recheck Cond: ((ten >= 1) AND (ten <= 10) AND (twenty = ANY ('{1,2,3}'::integer[])) AND (unique1 = ANY ('{84396,217539,60814}'::integer[])))
   Heap Blocks: exact=3
   Buffers: shared hit=93
   ->  Bitmap Index Scan on wisconsin_four_ten_twenty_unique1_idx (actual rows=3.00 loops=1)
         Index Cond: ((ten >= 1) AND (ten <= 10) AND (twenty = ANY ('{1,2,3}'::integer[])) AND (unique1 = ANY ('{84396,217539,60814}'::integer[])))
         Index Searches: 30
         Buffers: shared hit=90
(8 rows)

-- (January 19 2025) Contradictory scan keys should not confuse _bt_preprocess_array_keys
--
-- _bt_preprocess_array_keys shouldn't get confused about contradictory quals
-- with things like a = key and an inequality key on the same attribute.
--
-- Right now, these test cases trick _bt_preprocess_array_keys into throwing
-- errors such as:
-- ERROR:  missing oprcode for skipping equals operator 2437166984
-- Contradictory
select four, ten, unique1
from wisconsin
where
  four = -1 and four between 0 and 3
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
 four | ten | unique1 
------+-----+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, unique1
from wisconsin
where
  four = -1 and four between 0 and 3
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=0.00 loops=1)
   Recheck Cond: ((four >= 0) AND (four <= 3) AND (four = '-1'::integer) AND (ten >= 2) AND (ten <= 15) AND (unique1 = ANY ('{1,2490,7777}'::integer[])))
   ->  Bitmap Index Scan on wisconsin_four_ten_twenty_unique1_idx (actual rows=0.00 loops=1)
         Index Cond: ((four >= 0) AND (four <= 3) AND (four = '-1'::integer) AND (ten >= 2) AND (ten <= 15) AND (unique1 = ANY ('{1,2490,7777}'::integer[])))
         Index Searches: 0
(5 rows)

-- Contradictory
select four, ten, unique1
from wisconsin
where
  four between 0 and 3 and four = -1
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
 four | ten | unique1 
------+-----+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, unique1
from wisconsin
where
  four between 0 and 3 and four = -1
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=0.00 loops=1)
   Recheck Cond: ((four >= 0) AND (four <= 3) AND (four = '-1'::integer) AND (ten >= 2) AND (ten <= 15) AND (unique1 = ANY ('{1,2490,7777}'::integer[])))
   ->  Bitmap Index Scan on wisconsin_four_ten_twenty_unique1_idx (actual rows=0.00 loops=1)
         Index Cond: ((four >= 0) AND (four <= 3) AND (four = '-1'::integer) AND (ten >= 2) AND (ten <= 15) AND (unique1 = ANY ('{1,2490,7777}'::integer[])))
         Index Searches: 0
(5 rows)

-- Contradictory
select four, ten, unique1
from wisconsin
where
  four = 4 and four between 0 and 3 and four = -1
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
 four | ten | unique1 
------+-----+---------
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, unique1
from wisconsin
where
  four = 4 and four between 0 and 3 and four = -1
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
            QUERY PLAN             
-----------------------------------
 Result (actual rows=0.00 loops=1)
   One-Time Filter: false
(2 rows)

-- Partially redundant
select four, ten, unique1
from wisconsin
where
  four = 1 and four between 0 and 3
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
 four | ten | unique1 
------+-----+---------
    1 |   9 |       1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, unique1
from wisconsin
where
  four = 1 and four between 0 and 3
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((four >= 0) AND (four <= 3) AND (four = 1) AND (ten >= 2) AND (ten <= 15) AND (unique1 = ANY ('{1,2490,7777}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=34
   ->  Bitmap Index Scan on wisconsin_four_ten_twenty_unique1_idx (actual rows=1.00 loops=1)
         Index Cond: ((four >= 0) AND (four <= 3) AND (four = 1) AND (ten >= 2) AND (ten <= 15) AND (unique1 = ANY ('{1,2490,7777}'::integer[])))
         Index Searches: 11
         Buffers: shared hit=33
(8 rows)

-- Partially redundant
select four, ten, unique1
from wisconsin
where
  four between 0 and 3 and four = 1
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
 four | ten | unique1 
------+-----+---------
    1 |   9 |       1
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, unique1
from wisconsin
where
  four between 0 and 3 and four = 1
  and ten between 2 and 15
  and unique1 in (1, 2490, 7777);
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((four >= 0) AND (four <= 3) AND (four = 1) AND (ten >= 2) AND (ten <= 15) AND (unique1 = ANY ('{1,2490,7777}'::integer[])))
   Heap Blocks: exact=1
   Buffers: shared hit=34
   ->  Bitmap Index Scan on wisconsin_four_ten_twenty_unique1_idx (actual rows=1.00 loops=1)
         Index Cond: ((four >= 0) AND (four <= 3) AND (four = 1) AND (ten >= 2) AND (ten <= 15) AND (unique1 = ANY ('{1,2490,7777}'::integer[])))
         Index Searches: 11
         Buffers: shared hit=33
(8 rows)

-------------------------------------------------------------------------------
-- (July 12) Day after going for drinks with jkatz + company in East Village --
-------------------------------------------------------------------------------
drop index wisconsin_four_ten_twenty_unique1_idx;
create index four_ten_unique1_idx on wisconsin (four, ten, unique1);
-- Missing predicate is in "intermediate" column (ten) here:
-- "#define FORCE_NOSKIP_DEBUG + integer wisconsin table" broke with this
-- query at one point, but it's now fine:
prepare force_noskip_debug as
select four, ten, unique1 from wisconsin where four = 0 and unique1 = 5555;
execute force_noskip_debug;
 four | ten | unique1 
------+-----+---------
    0 |   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
execute force_noskip_debug;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin (actual rows=1.00 loops=1)
   Recheck Cond: ((four = 0) AND (unique1 = 5555))
   Heap Blocks: exact=1
   Buffers: shared hit=34
   ->  Bitmap Index Scan on four_ten_unique1_idx (actual rows=1.00 loops=1)
         Index Cond: ((four = 0) AND (unique1 = 5555))
         Index Searches: 11
         Buffers: shared hit=33
(8 rows)

-----------------------------------------
-- (July 10) Wisconsin numeric variant --
-----------------------------------------
set client_min_messages=error;
drop table if exists wisconsin_numeric;
reset client_min_messages;
create unlogged table wisconsin_numeric
(
unique1 numeric,
unique2 numeric,
two numeric,
four numeric,
ten numeric,
twenty numeric,
onepercent numeric,
tenpercent numeric,
twentypercent numeric,
fiftypercent numeric,
unique3 numeric,
evenonepercent numeric,
oddonepercent numeric,
stringu1 text,
stringu2 text,
string4 text
);
\set filename :abs_srcdir '/data/wisconsin.csv'
COPY wisconsin_numeric FROM :'filename' with (format csv, encoding 'win1252', header false, null $$$$, quote $$'$$); -- Fix the syntax highlighting: '
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select
  5555,
  5555,
  2147483646,
  2147483646,
  2147483646,
  2147483646,
  2147483646;
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select
  5555,
  5555,
  2147483647,
  2147483647,
  2147483647,
  2147483647,
  2147483647;
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select
  5555,
  5555,
(-2147483647),
(-2147483647),
(-2147483647),
(-2147483647),
(-2147483647);
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select
  5555,
  5555,(-2147483648),
(-2147483648),
(-2147483648),
(-2147483648),
(-2147483648);
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
vacuum analyze wisconsin_numeric;
-- Ten:
create index numeric_ten_idx on wisconsin_numeric (ten, unique1);
-- Range instead of skip attribute on "ten":
select ten, unique1 from wisconsin_numeric where ten between -10000 and 4 and unique1 = 5555;
 ten | unique1 
-----+---------
   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS OFF, TIMING OFF, COSTS OFF, SUMMARY OFF)
select ten, unique1 from wisconsin_numeric where ten between -10000 and 4 and unique1 = 5555;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=1.00 loops=1)
   Recheck Cond: ((ten >= '-10000'::numeric) AND (ten <= '4'::numeric) AND (unique1 = '5555'::numeric))
   Heap Blocks: exact=1
   ->  Bitmap Index Scan on numeric_ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((ten >= '-10000'::numeric) AND (ten <= '4'::numeric) AND (unique1 = '5555'::numeric))
         Index Searches: 11
(6 rows)

-- Range instead of skip attribute on "ten", backwards scan:
set enable_bitmapscan to off;
set enable_indexscan to on;
select ten, unique1 from wisconsin_numeric where ten between -10000 and 4 and unique1 = 5555 order by ten desc, unique1 desc;
 ten | unique1 
-----+---------
   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS OFF, TIMING OFF, COSTS OFF, SUMMARY OFF)
select ten, unique1 from wisconsin_numeric where ten between -10000 and 4 and unique1 = 5555 order by ten desc, unique1 desc;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan Backward using numeric_ten_idx on wisconsin_numeric (actual rows=1.00 loops=1)
   Index Cond: ((ten >= '-10000'::numeric) AND (ten <= '4'::numeric) AND (unique1 = '5555'::numeric))
   Index Searches: 10
(3 rows)

-- (July 23, Week of MIT visit, add test coverage)
--
-- Demonstrate how returning false when decrementing a non-skip-support skip
-- array with a >= inequality early due to the current array element already
-- being == the >= inequality's sk_argument.  This optimization is symmetrical
-- to the similar forward scan <= inequality case, which has plenty of code
-- coverage from other tests.
--
-- XXX UPDATE (January 22 2025) This optimization is now disabled, since it now
-- doesn't seem worth the trouble of keeping around a maybe-cross-type ORDER
-- proc and doing all of those extra comparisons just for this case.
select ten, unique1 from wisconsin_numeric where ten between 2 and 3 and unique1 = 5555 order by ten desc, unique1 desc;
 ten | unique1 
-----+---------
   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS OFF, TIMING OFF, COSTS OFF, SUMMARY OFF) -- 13 buffer hits (was 10 with optimization enabled)
select ten, unique1 from wisconsin_numeric where ten between 2 and 3 and unique1 = 5555 order by ten desc, unique1 desc;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Index Scan Backward using numeric_ten_idx on wisconsin_numeric (actual rows=1.00 loops=1)
   Index Cond: ((ten >= '2'::numeric) AND (ten <= '3'::numeric) AND (unique1 = '5555'::numeric))
   Index Searches: 4
(3 rows)

set enable_bitmapscan to on;
set enable_indexscan to off;
drop index numeric_ten_idx;
-- Four, ten:
create index numeric_four_ten_idx on wisconsin_numeric (four, ten, unique1);
-- (July 18) Make sure that we don't repeatedly access page 1 due to getting
-- confused about -inf value that lands us before the range of the column "ten"
select four, ten, unique1
from wisconsin_numeric
where ten between -10000 and 1 and unique1 = 113
limit 1; -- Just to avoid distraction of other, later pages (just care about page 1)
 four | ten | unique1 
------+-----+---------
    0 |   0 |     113
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, unique1
from wisconsin_numeric
where ten between -10000 and 1 and unique1 = 113
limit 1; -- Just to avoid distraction of other, later pages (just care about page 1)
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Limit (actual rows=1.00 loops=1)
   Buffers: shared hit=29
   ->  Bitmap Heap Scan on wisconsin_numeric (actual rows=1.00 loops=1)
         Recheck Cond: ((ten >= '-10000'::numeric) AND (ten <= '1'::numeric) AND (unique1 = '113'::numeric))
         Heap Blocks: exact=1
         Buffers: shared hit=29
         ->  Bitmap Index Scan on numeric_four_ten_idx (actual rows=1.00 loops=1)
               Index Cond: ((ten >= '-10000'::numeric) AND (ten <= '1'::numeric) AND (unique1 = '113'::numeric))
               Index Searches: 9
               Buffers: shared hit=28
(10 rows)

-- Point lookup, skips one col (four), range on other col after that (ten):
select four, ten, unique1 from wisconsin_numeric where ten between -10000 and 4 and unique1 = 5555;
 four | ten | unique1 
------+-----+---------
    0 |   2 |    5555
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, unique1 from wisconsin_numeric where ten between -10000 and 4 and unique1 = 5555;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=1.00 loops=1)
   Recheck Cond: ((ten >= '-10000'::numeric) AND (ten <= '4'::numeric) AND (unique1 = '5555'::numeric))
   Heap Blocks: exact=1
   Buffers: shared hit=76
   ->  Bitmap Index Scan on numeric_four_ten_idx (actual rows=1.00 loops=1)
         Index Cond: ((ten >= '-10000'::numeric) AND (ten <= '4'::numeric) AND (unique1 = '5555'::numeric))
         Index Searches: 25
         Buffers: shared hit=75
(8 rows)

drop index numeric_four_ten_idx;
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select 1, 1, 1, 1, 1, 1, 2147483647 from generate_series(1, 1500) i;
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select 1, 1, 1, 1, 1, 1, (-2147483648)::int4 from generate_series(1, 1500) i;
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select -666, 1, 1, 1, 1, 1, 2147483647;
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select -666, 1, 1, 1, 1, 1, (-2147483648)::int4;
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select 1, 1, 1, 1, 1, 1, NULL from generate_series(1, 1500) i;
insert into wisconsin_numeric(unique1, unique2, two, four, ten, twenty, onepercent)
select -666, 1, 1, 1, 1, 1, NULL;
vacuum analyze wisconsin_numeric;
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
create index numeric_idx_four_ten_twenty_unique1 on wisconsin_numeric (four, ten, twenty, unique1);
-- Simplest version:
select four, ten, twenty, unique1 from wisconsin_numeric where four in (2 , 3) and ten between 3 and 3 and twenty = 3 and unique1 = 84396;
 four | ten | twenty | unique1 
------+-----+--------+---------
    3 |   3 |      3 |   84396
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF)
select four, ten, twenty, unique1 from wisconsin_numeric where four in (2 , 3) and ten between 3 and 3 and twenty = 3 and unique1 = 84396;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=1.00 loops=1)
   Recheck Cond: ((four = ANY ('{2,3}'::numeric[])) AND (ten >= '3'::numeric) AND (ten <= '3'::numeric) AND (twenty = '3'::numeric) AND (unique1 = '84396'::numeric))
   Heap Blocks: exact=1
   Buffers: shared hit=10
   ->  Bitmap Index Scan on numeric_idx_four_ten_twenty_unique1 (actual rows=1.00 loops=1)
         Index Cond: ((four = ANY ('{2,3}'::numeric[])) AND (ten >= '3'::numeric) AND (ten <= '3'::numeric) AND (twenty = '3'::numeric) AND (unique1 = '84396'::numeric))
         Index Searches: 3
         Buffers: shared hit=9
(8 rows)

-- Simplest version of other, similar bug:
prepare simple_repro as
select four, ten, twenty, unique1 from wisconsin_numeric where four between 2 and 3 and ten between 2 and 3 and twenty = 3 and unique1 = 84396;
execute simple_repro;
 four | ten | twenty | unique1 
------+-----+--------+---------
    3 |   3 |      3 |   84396
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF, COSTS OFF)
execute simple_repro;
                                                                                        QUERY PLAN                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=1.00 loops=1)
   Recheck Cond: ((four >= '2'::numeric) AND (four <= '3'::numeric) AND (ten >= '2'::numeric) AND (ten <= '3'::numeric) AND (twenty = '3'::numeric) AND (unique1 = '84396'::numeric))
   Heap Blocks: exact=1
   Buffers: shared hit=19
   ->  Bitmap Index Scan on numeric_idx_four_ten_twenty_unique1 (actual rows=1.00 loops=1)
         Index Cond: ((four >= '2'::numeric) AND (four <= '3'::numeric) AND (ten >= '2'::numeric) AND (ten <= '3'::numeric) AND (twenty = '3'::numeric) AND (unique1 = '84396'::numeric))
         Index Searches: 6
         Buffers: shared hit=18
(8 rows)

-- SAOP-only version should return 2 rows:
select four, ten, twenty, unique1 from wisconsin_numeric where ten in (2,3) and twenty in (2, 3) and unique1 in (84396, 60814);
 four | ten | twenty | unique1 
------+-----+--------+---------
    3 |   3 |      3 |   84396
    2 |   2 |      2 |   60814
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, twenty, unique1 from wisconsin_numeric where ten in (2,3) and twenty in (2, 3) and unique1 in (84396, 60814);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=2.00 loops=1)
   Recheck Cond: ((ten = ANY ('{2,3}'::numeric[])) AND (twenty = ANY ('{2,3}'::numeric[])) AND (unique1 = ANY ('{84396,60814}'::numeric[])))
   Heap Blocks: exact=2
   Buffers: shared hit=44
   ->  Bitmap Index Scan on numeric_idx_four_ten_twenty_unique1 (actual rows=2.00 loops=1)
         Index Cond: ((ten = ANY ('{2,3}'::numeric[])) AND (twenty = ANY ('{2,3}'::numeric[])) AND (unique1 = ANY ('{84396,60814}'::numeric[])))
         Index Searches: 14
         Buffers: shared hit=42
(8 rows)

-- Equivalent "SAOP, range skip array" version should also return 2 rows:
select four, ten, twenty, unique1 from wisconsin_numeric where ten in (2,3) and twenty between 2 and 3 and unique1 in (84396, 60814);
 four | ten | twenty | unique1 
------+-----+--------+---------
    3 |   3 |      3 |   84396
    2 |   2 |      2 |   60814
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, twenty, unique1 from wisconsin_numeric where ten in (2,3) and twenty between 2 and 3 and unique1 in (84396, 60814);
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=2.00 loops=1)
   Recheck Cond: ((ten = ANY ('{2,3}'::numeric[])) AND (twenty >= '2'::numeric) AND (twenty <= '3'::numeric) AND (unique1 = ANY ('{84396,60814}'::numeric[])))
   Heap Blocks: exact=2
   Buffers: shared hit=47
   ->  Bitmap Index Scan on numeric_idx_four_ten_twenty_unique1 (actual rows=2.00 loops=1)
         Index Cond: ((ten = ANY ('{2,3}'::numeric[])) AND (twenty >= '2'::numeric) AND (twenty <= '3'::numeric) AND (unique1 = ANY ('{84396,60814}'::numeric[])))
         Index Searches: 15
         Buffers: shared hit=45
(8 rows)

-- Equivalent "range skip array, SAOP" version should also return 2 rows:
select four, ten, twenty, unique1 from wisconsin_numeric where ten between 2 and 3 and twenty in (2, 3) and unique1 in (84396, 60814);
 four | ten | twenty | unique1 
------+-----+--------+---------
    3 |   3 |      3 |   84396
    2 |   2 |      2 |   60814
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, twenty, unique1 from wisconsin_numeric where ten between 2 and 3 and twenty in (2, 3) and unique1 in (84396, 60814);
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=2.00 loops=1)
   Recheck Cond: ((ten >= '2'::numeric) AND (ten <= '3'::numeric) AND (twenty = ANY ('{2,3}'::numeric[])) AND (unique1 = ANY ('{84396,60814}'::numeric[])))
   Heap Blocks: exact=2
   Buffers: shared hit=50
   ->  Bitmap Index Scan on numeric_idx_four_ten_twenty_unique1 (actual rows=2.00 loops=1)
         Index Cond: ((ten >= '2'::numeric) AND (ten <= '3'::numeric) AND (twenty = ANY ('{2,3}'::numeric[])) AND (unique1 = ANY ('{84396,60814}'::numeric[])))
         Index Searches: 16
         Buffers: shared hit=48
(8 rows)

-- Equivalent "range skip array, range skip array" version should also return 2 rows:
select four, ten, twenty, unique1 from wisconsin_numeric where ten between 2 and 3 and twenty between 2 and 3 and unique1 in (84396, 60814);
 four | ten | twenty | unique1 
------+-----+--------+---------
    3 |   3 |      3 |   84396
    2 |   2 |      2 |   60814
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select four, ten, twenty, unique1 from wisconsin_numeric where ten between 2 and 3 and twenty between 2 and 3 and unique1 in (84396, 60814);
                                                                                    QUERY PLAN                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=2.00 loops=1)
   Recheck Cond: ((ten >= '2'::numeric) AND (ten <= '3'::numeric) AND (twenty >= '2'::numeric) AND (twenty <= '3'::numeric) AND (unique1 = ANY ('{84396,60814}'::numeric[])))
   Heap Blocks: exact=2
   Buffers: shared hit=50
   ->  Bitmap Index Scan on numeric_idx_four_ten_twenty_unique1 (actual rows=2.00 loops=1)
         Index Cond: ((ten >= '2'::numeric) AND (ten <= '3'::numeric) AND (twenty >= '2'::numeric) AND (twenty <= '3'::numeric) AND (unique1 = ANY ('{84396,60814}'::numeric[])))
         Index Searches: 16
         Buffers: shared hit=48
(8 rows)

-- Four, ten, twenty, unique1 (causes errors about attribute order from
-- _by_preprocess_keys) -- this is the original and more complicated version
-- of the previous tests (I broke it into smaller parts, but kept the
-- original here):
select four, ten, twenty, unique1
from wisconsin_numeric
where
  ten between 1 and 10
  and twenty in (1, 2, 3)
  and unique1 in (84396, 217539, 60814);
 four | ten | twenty | unique1 
------+-----+--------+---------
    2 |   2 |      2 |  217539
    3 |   3 |      3 |   84396
    2 |   2 |      2 |   60814
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF) -- master 822 hits
select four, ten, twenty, unique1
from wisconsin_numeric
where
  ten between 1 and 10
  and twenty in (1, 2, 3)
  and unique1 in (84396, 217539, 60814);
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on wisconsin_numeric (actual rows=3.00 loops=1)
   Recheck Cond: ((ten >= '1'::numeric) AND (ten <= '10'::numeric) AND (twenty = ANY ('{1,2,3}'::numeric[])) AND (unique1 = ANY ('{84396,217539,60814}'::numeric[])))
   Heap Blocks: exact=3
   Buffers: shared hit=93
   ->  Bitmap Index Scan on numeric_idx_four_ten_twenty_unique1 (actual rows=3.00 loops=1)
         Index Cond: ((ten >= '1'::numeric) AND (ten <= '10'::numeric) AND (twenty = ANY ('{1,2,3}'::numeric[])) AND (unique1 = ANY ('{84396,217539,60814}'::numeric[])))
         Index Searches: 30
         Buffers: shared hit=90
(8 rows)

-------------------------------------
-- (June 16) NULLS FIRST test case --
-------------------------------------
set client_min_messages=error;
drop table if exists nulls_first_test;
reset client_min_messages;
create unlogged table nulls_first_test(
  a int,
  b int
);
create index nulls_first_test_idx on nulls_first_test(a nulls first, b);
insert into nulls_first_test(a, b)
select NULL, i from generate_series(1, 3500) i;
insert into nulls_first_test(a, b)
select 2147483647, i from generate_series(1, 3500) i;
set enable_indexscan to on;
set enable_bitmapscan to off;
-- Forwards scan
select * from nulls_first_test where b = 3 order by a nulls first, b;
     a      | b 
------------+---
            | 3
 2147483647 | 3
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_first_test where b = 3 order by a nulls first, b;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Index Scan using nulls_first_test_idx on nulls_first_test  (cost=0.28..149.18 rows=35 width=8) (actual rows=2.00 loops=1)
   Index Cond: (b = 3)
   Index Searches: 2
   Buffers: shared hit=6
(4 rows)

-- Backwards scan
select * from nulls_first_test where b = 3 order by a desc nulls last, b desc;
     a      | b 
------------+---
 2147483647 | 3
            | 3
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_first_test where b = 3 order by a desc nulls last, b desc;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using nulls_first_test_idx on nulls_first_test  (cost=0.28..149.18 rows=35 width=8) (actual rows=2.00 loops=1)
   Index Cond: (b = 3)
   Index Searches: 3
   Buffers: shared hit=8
(4 rows)

-- Now add INT_MIN grouping:
insert into nulls_first_test(a, b)
select (-2147483648)::int4, i from generate_series(1, 3500) i;
-- Repeat forwards scan
select * from nulls_first_test where b = 3 order by a nulls first, b;
      a      | b 
-------------+---
             | 3
 -2147483648 | 3
  2147483647 | 3
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_first_test where b = 3 order by a nulls first, b;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Index Scan using nulls_first_test_idx on nulls_first_test  (cost=0.29..220.48 rows=53 width=8) (actual rows=3.00 loops=1)
   Index Cond: (b = 3)
   Index Searches: 3
   Buffers: shared hit=10
(4 rows)

-- Repeat backwards scan
select * from nulls_first_test where b = 3 order by a desc nulls last, b desc;
      a      | b 
-------------+---
  2147483647 | 3
 -2147483648 | 3
             | 3
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_first_test where b = 3 order by a desc nulls last, b desc;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using nulls_first_test_idx on nulls_first_test  (cost=0.29..220.48 rows=53 width=8) (actual rows=3.00 loops=1)
   Index Cond: (b = 3)
   Index Searches: 5
   Buffers: shared hit=13
(4 rows)

-- (July 7) NULLS FIRST numeric (i.e. no skip support) test case
set client_min_messages=error;
drop table if exists nulls_first_test_numeric;
reset client_min_messages;
create unlogged table nulls_first_test_numeric(
  a numeric,
  b int
);
create index nulls_first_test_numeric_idx on nulls_first_test_numeric(a nulls first, b);
insert into nulls_first_test_numeric(a, b)
select NULL, i from generate_series(1, 3500) i;
insert into nulls_first_test_numeric(a, b)
select 2147483647, i from generate_series(1, 3500) i;
set enable_indexscan to on;
set enable_bitmapscan to off;
-- Forwards scan
select * from nulls_first_test_numeric where b = 3 order by a nulls first, b;
     a      | b 
------------+---
            | 3
 2147483647 | 3
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_first_test_numeric where b = 3 order by a nulls first, b;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using nulls_first_test_numeric_idx on nulls_first_test_numeric  (cost=0.28..125.84 rows=22 width=36) (actual rows=2.00 loops=1)
   Index Cond: (b = 3)
   Index Searches: 3
   Buffers: shared hit=8
(4 rows)

-- Backwards scan
select * from nulls_first_test_numeric where b = 3 order by a desc nulls last, b desc;
     a      | b 
------------+---
 2147483647 | 3
            | 3
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_first_test_numeric where b = 3 order by a desc nulls last, b desc;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using nulls_first_test_numeric_idx on nulls_first_test_numeric  (cost=0.28..125.84 rows=22 width=36) (actual rows=2.00 loops=1)
   Index Cond: (b = 3)
   Index Searches: 3
   Buffers: shared hit=8
(4 rows)

-- Now add INT_MIN grouping:
insert into nulls_first_test_numeric(a, b)
select (-2147483648)::int4, i from generate_series(1, 3500) i;
-- Repeat forwards scan
select * from nulls_first_test_numeric where b = 3 order by a nulls first, b;
      a      | b 
-------------+---
             | 3
 -2147483648 | 3
  2147483647 | 3
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_first_test_numeric where b = 3 order by a nulls first, b;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using nulls_first_test_numeric_idx on nulls_first_test_numeric  (cost=0.28..190.06 rows=34 width=36) (actual rows=3.00 loops=1)
   Index Cond: (b = 3)
   Index Searches: 4
   Buffers: shared hit=13
(4 rows)

-- Repeat backwards scan
select * from nulls_first_test_numeric where b = 3 order by a desc nulls last, b desc;
      a      | b 
-------------+---
  2147483647 | 3
 -2147483648 | 3
             | 3
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from nulls_first_test_numeric where b = 3 order by a desc nulls last, b desc;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using nulls_first_test_numeric_idx on nulls_first_test_numeric  (cost=0.28..190.06 rows=34 width=36) (actual rows=3.00 loops=1)
   Index Cond: (b = 3)
   Index Searches: 5
   Buffers: shared hit=13
(4 rows)

-- (July 16) Coverage for "treat NULL as final value in backwards scan
-- direction" case (without skip support):
select * from nulls_first_test_numeric where b = 3130 order by a desc nulls last, b;
      a      |  b   
-------------+------
  2147483647 | 3130
 -2147483648 | 3130
             | 3130
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- This is 15 buffer hits (not 17) due to optimization
select * from nulls_first_test_numeric where b = 3130 order by a desc nulls last, b;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using nulls_first_test_numeric_idx on nulls_first_test_numeric  (cost=0.28..190.06 rows=34 width=36) (actual rows=3.00 loops=1)
   Index Cond: (b = 3130)
   Index Searches: 6
   Buffers: shared hit=15
(4 rows)

------------------------------------------------------------------------
-- (July 2) Alexander Alekseev failing "char" (not char(1)) test case --
------------------------------------------------------------------------
set client_min_messages=error;
drop table if exists alekseev_test;
reset client_min_messages;
create unlogged table alekseev_test(c "char", n bigint);
select setseed(0.5);
 setseed 
---------
 
(1 row)

insert into alekseev_test
select chr(ascii('a') + random(0,2)) as c,
random(0, 1_000_000_000) as n
from generate_series(0, 10_000);
create index alekseev_test_idx on alekseev_test using btree(c, n);
-- Force bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
-- Better not have a buggy btree/char_ops skip support function:
select count(*) from alekseev_test where n > 900_000_000;
 count 
-------
   988
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 11 buffer hits
select count(*) from alekseev_test where n > 900_000_000;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=263.14..263.15 rows=1 width=8) (actual rows=1.00 loops=1)
   Buffers: shared hit=67
   ->  Bitmap Heap Scan on alekseev_test  (cost=158.13..254.80 rows=3334 width=0) (actual rows=988.00 loops=1)
         Recheck Cond: (n > 900000000)
         Heap Blocks: exact=54
         Buffers: shared hit=67
         ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=3334 width=0) (actual rows=988.00 loops=1)
               Index Cond: (n > 900000000)
               Index Searches: 4
               Buffers: shared hit=13
(10 rows)

-- More selective query:
select c, n from alekseev_test where n = 952_200_397;
 c |     n     
---+-----------
 c | 952200397
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = 952_200_397;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.30..200.01 rows=50 width=9) (actual rows=1.00 loops=1)
   Recheck Cond: (n = 952200397)
   Heap Blocks: exact=1
   Buffers: shared hit=11
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=50 width=0) (actual rows=1.00 loops=1)
         Index Cond: (n = 952200397)
         Index Searches: 5
         Buffers: shared hit=10
(8 rows)

-- More selective query, low value that exists:
select c, n from alekseev_test where n = 24_759;
 c |   n   
---+-------
 b | 24759
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = 24_759;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.30..200.01 rows=50 width=9) (actual rows=1.00 loops=1)
   Recheck Cond: (n = 24759)
   Heap Blocks: exact=1
   Buffers: shared hit=9
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=50 width=0) (actual rows=1.00 loops=1)
         Index Cond: (n = 24759)
         Index Searches: 4
         Buffers: shared hit=8
(8 rows)

-- More selective query, low value that does not exist:
select c, n from alekseev_test where n = -1000;
 c | n 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = -1000;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.30..200.01 rows=50 width=9) (actual rows=0.00 loops=1)
   Recheck Cond: (n = '-1000'::integer)
   Buffers: shared hit=8
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=50 width=0) (actual rows=0.00 loops=1)
         Index Cond: (n = '-1000'::integer)
         Index Searches: 4
         Buffers: shared hit=8
(7 rows)

-- Extremal elements so that scan visits leftmost and rightmost tuples within
-- each individual "c" grouping:
select c, n from alekseev_test where n in (1, 24759, 999843016);
 c |     n     
---+-----------
 b |     24759
 c | 999843016
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 8 buffer hits
select c, n from alekseev_test where n in (1, 24759, 999843016);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.33..214.39 rows=150 width=9) (actual rows=2.00 loops=1)
   Recheck Cond: (n = ANY ('{1,24759,999843016}'::bigint[]))
   Heap Blocks: exact=2
   Buffers: shared hit=10
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=150 width=0) (actual rows=2.00 loops=1)
         Index Cond: (n = ANY ('{1,24759,999843016}'::bigint[]))
         Index Searches: 4
         Buffers: shared hit=8
(8 rows)

-- Middling elements in SAOP test:
select c, n
from
  alekseev_test
where
n in (500_048_538,
      500_061_970,
      500_129_489,
      500_143_236,
      500_164_863,
      500_229_159,
      500_255_696,
      500_411_856,
      500_448_495,
      500_630_870);
 c |     n     
---+-----------
 c | 500061970
 a | 500048538
 a | 500411856
 b | 500143236
 b | 500164863
 a | 500129489
 b | 500448495
 a | 500229159
 a | 500255696
 a | 500630870
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 10 buffer hits
select c, n
from
  alekseev_test
where
n in (500_048_538,
      500_061_970,
      500_129_489,
      500_143_236,
      500_164_863,
      500_229_159,
      500_255_696,
      500_411_856,
      500_448_495,
      500_630_870);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.44..219.94 rows=500 width=9) (actual rows=10.00 loops=1)
   Recheck Cond: (n = ANY ('{500048538,500061970,500129489,500143236,500164863,500229159,500255696,500411856,500448495,500630870}'::bigint[]))
   Heap Blocks: exact=10
   Buffers: shared hit=20
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=500 width=0) (actual rows=10.00 loops=1)
         Index Cond: (n = ANY ('{500048538,500061970,500129489,500143236,500164863,500229159,500255696,500411856,500448495,500630870}'::bigint[]))
         Index Searches: 5
         Buffers: shared hit=10
(8 rows)

-- Force index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
---------------------------------
-- "char" backwards scan tests --
---------------------------------
-- Extremal elements so that scan visits leftmost and rightmost tuples within
-- each individual "c" grouping:
select c, n from alekseev_test where n in (1, 24759, 999843016) order by c desc, n desc;
 c |     n     
---+-----------
 c | 999843016
 b |     24759
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 12 buffer hits
select c, n from alekseev_test where n in (1, 24759, 999843016) order by c desc, n desc;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using alekseev_test_idx on alekseev_test  (cost=0.29..268.79 rows=150 width=9) (actual rows=2.00 loops=1)
   Index Cond: (n = ANY ('{1,24759,999843016}'::bigint[]))
   Index Searches: 4
   Buffers: shared hit=10
(4 rows)

-------------------------------------------------------
-- Text tests, which can't use skip support function --
-------------------------------------------------------
-- Make "more selective query" work with text, so we have somewhat of a basis
-- of comparison:
alter table alekseev_test alter column c type text;
-- Force bitmap index scan:
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
------------------------------------
-- Now repeat queries from before --
------------------------------------
-- "Better not have a buggy btree/char_ops skip support function", but no skip
-- support function this time around (since this is text):
select count(*) from alekseev_test where n > 900_000_000;
 count 
-------
   988
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- parity with "char" test, 11 buffer hits
select count(*) from alekseev_test where n > 900_000_000;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=272.14..272.15 rows=1 width=8) (actual rows=1.00 loops=1)
   Buffers: shared hit=67
   ->  Bitmap Heap Scan on alekseev_test  (cost=158.13..263.80 rows=3334 width=0) (actual rows=988.00 loops=1)
         Recheck Cond: (n > 900000000)
         Heap Blocks: exact=54
         Buffers: shared hit=67
         ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=3334 width=0) (actual rows=988.00 loops=1)
               Index Cond: (n > 900000000)
               Index Searches: 4
               Buffers: shared hit=13
(10 rows)

-- More selective query:
select c, n from alekseev_test where n = 952_200_397;
 c |     n     
---+-----------
 c | 952200397
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = 952_200_397;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.30..202.93 rows=50 width=40) (actual rows=1.00 loops=1)
   Recheck Cond: (n = 952200397)
   Heap Blocks: exact=1
   Buffers: shared hit=13
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=50 width=0) (actual rows=1.00 loops=1)
         Index Cond: (n = 952200397)
         Index Searches: 6
         Buffers: shared hit=12
(8 rows)

-- More selective query, low value that exists:
select c, n from alekseev_test where n = 24_759;
 c |   n   
---+-------
 b | 24759
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = 24_759;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.30..202.93 rows=50 width=40) (actual rows=1.00 loops=1)
   Recheck Cond: (n = 24759)
   Heap Blocks: exact=1
   Buffers: shared hit=9
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=50 width=0) (actual rows=1.00 loops=1)
         Index Cond: (n = 24759)
         Index Searches: 4
         Buffers: shared hit=8
(8 rows)

-- More selective query, low value that does not exist:
select c, n from alekseev_test where n = -1000;
 c | n 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = -1000;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.30..202.93 rows=50 width=40) (actual rows=0.00 loops=1)
   Recheck Cond: (n = '-1000'::integer)
   Buffers: shared hit=8
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=50 width=0) (actual rows=0.00 loops=1)
         Index Cond: (n = '-1000'::integer)
         Index Searches: 4
         Buffers: shared hit=8
(7 rows)

-- Extremal elements so that scan visits leftmost and rightmost tuples within
-- each individual "c" grouping:
select c, n from alekseev_test where n in (1, 24759, 999843016);
 c |     n     
---+-----------
 b |     24759
 c | 999843016
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- parity with "char" test, 8 buffer hits
select c, n from alekseev_test where n in (1, 24759, 999843016);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.33..223.39 rows=150 width=40) (actual rows=2.00 loops=1)
   Recheck Cond: (n = ANY ('{1,24759,999843016}'::bigint[]))
   Heap Blocks: exact=2
   Buffers: shared hit=10
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=150 width=0) (actual rows=2.00 loops=1)
         Index Cond: (n = ANY ('{1,24759,999843016}'::bigint[]))
         Index Searches: 4
         Buffers: shared hit=8
(8 rows)

-- Middling elements in SAOP test:
select c, n
from
  alekseev_test
where
n in (500_048_538,
      500_061_970,
      500_129_489,
      500_143_236,
      500_164_863,
      500_229_159,
      500_255_696,
      500_411_856,
      500_448_495,
      500_630_870);
 c |     n     
---+-----------
 c | 500061970
 a | 500048538
 a | 500411856
 b | 500143236
 b | 500164863
 a | 500129489
 b | 500448495
 a | 500229159
 a | 500255696
 a | 500630870
(10 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 14 buffer hits vs 10 for "char" due to not naturally needing to visit extremal n values
select c, n
from
  alekseev_test
where
n in (500_048_538,
      500_061_970,
      500_129_489,
      500_143_236,
      500_164_863,
      500_229_159,
      500_255_696,
      500_411_856,
      500_448_495,
      500_630_870);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on alekseev_test  (cost=157.44..228.94 rows=500 width=40) (actual rows=10.00 loops=1)
   Recheck Cond: (n = ANY ('{500048538,500061970,500129489,500143236,500164863,500229159,500255696,500411856,500448495,500630870}'::bigint[]))
   Heap Blocks: exact=10
   Buffers: shared hit=24
   ->  Bitmap Index Scan on alekseev_test_idx  (cost=0.00..157.29 rows=500 width=0) (actual rows=10.00 loops=1)
         Index Cond: (n = ANY ('{500048538,500061970,500129489,500143236,500164863,500229159,500255696,500411856,500448495,500630870}'::bigint[]))
         Index Searches: 7
         Buffers: shared hit=14
(8 rows)

-- Force index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-------------------------------
-- text backwards scan tests --
-------------------------------
-- Extremal elements so that scan visits leftmost and rightmost tuples within
-- each individual "c" grouping:
select c, n from alekseev_test where n in (1, 24759, 999843016) order by c desc, n desc;
 c |     n     
---+-----------
 c | 999843016
 b |     24759
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 12 buffer hits
select c, n from alekseev_test where n in (1, 24759, 999843016) order by c desc, n desc;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using alekseev_test_idx on alekseev_test  (cost=0.29..286.79 rows=150 width=40) (actual rows=2.00 loops=1)
   Index Cond: (n = ANY ('{1,24759,999843016}'::bigint[]))
   Index Searches: 4
   Buffers: shared hit=10
(4 rows)

------------------------------
-- text NULL tests (July 7) --
------------------------------
insert into alekseev_test
select null, n from alekseev_test;
-- More selective query:
select c, n from alekseev_test where n = 952_200_397;
 c |     n     
---+-----------
 c | 952200397
   | 952200397
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = 952_200_397;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..433.70 rows=84 width=40) (actual rows=2.00 loops=1)
   Index Cond: (n = 952200397)
   Index Searches: 7
   Buffers: shared hit=16
(4 rows)

-- More selective query, low value that exists:
select c, n from alekseev_test where n = 24_759;
 c |   n   
---+-------
 b | 24759
   | 24759
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = 24_759;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..433.70 rows=84 width=40) (actual rows=2.00 loops=1)
   Index Cond: (n = 24759)
   Index Searches: 4
   Buffers: shared hit=10
(4 rows)

-- More selective query, low value that does not exist:
select c, n from alekseev_test where n = -1000;
 c | n 
---+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where n = -1000;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..433.70 rows=84 width=40) (actual rows=0.00 loops=1)
   Index Cond: (n = '-1000'::integer)
   Index Searches: 4
   Buffers: shared hit=8
(4 rows)

-- Extremal elements so that scan visits leftmost and rightmost tuples within
-- each individual "c" grouping:
select c, n from alekseev_test where n in (1, 24759, 999843016);
 c |     n     
---+-----------
 b |     24759
 c | 999843016
   |     24759
   | 999843016
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- parity with "char" test, 8 buffer hits
select c, n from alekseev_test where n in (1, 24759, 999843016);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..529.39 rows=253 width=40) (actual rows=4.00 loops=1)
   Index Cond: (n = ANY ('{1,24759,999843016}'::bigint[]))
   Index Searches: 5
   Buffers: shared hit=14
(4 rows)

-- Same again, but IS NOT NULL inequality used on skip attribute:
select c, n from alekseev_test where c is not null and n in (1, 24759, 999843016);
 c |     n     
---+-----------
 b |     24759
 c | 999843016
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- parity with "char" test, 8 buffer hits
select c, n from alekseev_test where c is not null and n in (1, 24759, 999843016);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..570.74 rows=252 width=40) (actual rows=2.00 loops=1)
   Index Cond: ((c IS NOT NULL) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 4
   Buffers: shared hit=10
(4 rows)

-- Same again, but with regular > inequality used on skip attribute:
select c, n from alekseev_test where c  > 'a' and n in (1, 24759, 999843016);
 c |     n     
---+-----------
 b |     24759
 c | 999843016
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- parity with "char" test, 8 buffer hits
select c, n from alekseev_test where c  > 'a' and n in (1, 24759, 999843016);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..241.39 rows=84 width=40) (actual rows=2.00 loops=1)
   Index Cond: ((c > 'a'::text) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 3
   Buffers: shared hit=8
(4 rows)

-- Same again, but with regular < inequality used on skip attribute:
select c, n from alekseev_test where c  < 'c' and n in (1, 24759, 999843016);
 c |   n   
---+-------
 b | 24759
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- parity with "char" test, 8 buffer hits
select c, n from alekseev_test where c  < 'c' and n in (1, 24759, 999843016);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..241.39 rows=84 width=40) (actual rows=1.00 loops=1)
   Index Cond: ((c < 'c'::text) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 3
   Buffers: shared hit=7
(4 rows)

-- Middling elements in SAOP test:
select c, n
from
  alekseev_test
where
n in (500_048_538,
      500_061_970,
      500_129_489,
      500_143_236,
      500_164_863,
      500_229_159,
      500_255_696,
      500_411_856,
      500_448_495,
      500_630_870);
 c |     n     
---+-----------
 a | 500048538
 a | 500129489
 a | 500229159
 a | 500255696
 a | 500411856
 a | 500630870
 b | 500143236
 b | 500164863
 b | 500448495
 c | 500061970
   | 500048538
   | 500061970
   | 500129489
   | 500143236
   | 500164863
   | 500229159
   | 500255696
   | 500411856
   | 500448495
   | 500630870
(20 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 14 buffer hits vs 10 for "char" due to not naturally needing to visit extremal n values
select c, n
from
  alekseev_test
where
n in (500_048_538,
      500_061_970,
      500_129_489,
      500_143_236,
      500_164_863,
      500_229_159,
      500_255_696,
      500_411_856,
      500_448_495,
      500_630_870);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..535.31 rows=844 width=40) (actual rows=20.00 loops=1)
   Index Cond: (n = ANY ('{500048538,500061970,500129489,500143236,500164863,500229159,500255696,500411856,500448495,500630870}'::bigint[]))
   Index Searches: 8
   Buffers: shared hit=36
(4 rows)

---------------------------
-- NULL + Backwards scan --
---------------------------
-- Extremal elements so that scan visits leftmost and rightmost tuples within
-- each individual "c" grouping:
select c, n from alekseev_test where n in (1, 24759, 999843016) order by c desc, n desc;
 c |     n     
---+-----------
   | 999843016
   |     24759
 c | 999843016
 b |     24759
(4 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 12 buffer hits
select c, n from alekseev_test where n in (1, 24759, 999843016) order by c desc, n desc;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using alekseev_test_idx on alekseev_test  (cost=0.29..529.39 rows=253 width=40) (actual rows=4.00 loops=1)
   Index Cond: (n = ANY ('{1,24759,999843016}'::bigint[]))
   Index Searches: 5
   Buffers: shared hit=14
(4 rows)

-- Same again, but with IS NOT NULL on c:
select c, n from alekseev_test where c is not null and n in (1, 24759, 999843016) order by c desc, n desc;
 c |     n     
---+-----------
 c | 999843016
 b |     24759
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- 12 buffer hits
select c, n from alekseev_test where c is not null and n in (1, 24759, 999843016) order by c desc, n desc;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using alekseev_test_idx on alekseev_test  (cost=0.29..570.74 rows=252 width=40) (actual rows=2.00 loops=1)
   Index Cond: ((c IS NOT NULL) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 4
   Buffers: shared hit=10
(4 rows)

-- Same again, but with regular > inequality used on skip attribute:
select c, n from alekseev_test where c  > 'a' and n in (1, 24759, 999843016) order by c desc, n desc;
 c |     n     
---+-----------
 c | 999843016
 b |     24759
(2 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- parity with "char" test, 8 buffer hits
select c, n from alekseev_test where c  > 'a' and n in (1, 24759, 999843016) order by c desc, n desc;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using alekseev_test_idx on alekseev_test  (cost=0.29..241.39 rows=84 width=40) (actual rows=2.00 loops=1)
   Index Cond: ((c > 'a'::text) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 3
   Buffers: shared hit=8
(4 rows)

-- Same again, but with regular < inequality used on skip attribute:
select c, n from alekseev_test where c  < 'c' and n in (1, 24759, 999843016) order by c desc, n desc;
 c |   n   
---+-------
 b | 24759
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF) -- parity with "char" test, 8 buffer hits
select c, n from alekseev_test where c  < 'c' and n in (1, 24759, 999843016) order by c desc, n desc;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using alekseev_test_idx on alekseev_test  (cost=0.29..241.39 rows=84 width=40) (actual rows=1.00 loops=1)
   Index Cond: ((c < 'c'::text) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 3
   Buffers: shared hit=7
(4 rows)

-- Almost the same query again, but now it's an <=:
select c, n from alekseev_test where c  <= 'b' and n in (1, 24759, 999843016) order by c desc, n desc;
 c |   n   
---+-------
 b | 24759
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where c  <= 'b' and n in (1, 24759, 999843016) order by c desc, n desc;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using alekseev_test_idx on alekseev_test  (cost=0.29..241.39 rows=84 width=40) (actual rows=1.00 loops=1)
   Index Cond: ((c <= 'b'::text) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 3
   Buffers: shared hit=7
(4 rows)

-- Same exact query again, but now it's a forwards scan:
select c, n from alekseev_test where c  < 'c' and n in (1, 24759, 999843016);
 c |   n   
---+-------
 b | 24759
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where c  < 'c' and n in (1, 24759, 999843016);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..241.39 rows=84 width=40) (actual rows=1.00 loops=1)
   Index Cond: ((c < 'c'::text) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 3
   Buffers: shared hit=7
(4 rows)

-- Almost the same query again, but now it's an <=:
select c, n from alekseev_test where c  <= 'b' and n in (1, 24759, 999843016);
 c |   n   
---+-------
 b | 24759
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select c, n from alekseev_test where c  <= 'b' and n in (1, 24759, 999843016);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Index Scan using alekseev_test_idx on alekseev_test  (cost=0.29..241.39 rows=84 width=40) (actual rows=1.00 loops=1)
   Index Cond: ((c <= 'b'::text) AND (n = ANY ('{1,24759,999843016}'::bigint[])))
   Index Searches: 3
   Buffers: shared hit=7
(4 rows)

--
--
-- (June 6) Check behavior with duplicate index column contents
--
-- From create_index.sql, failed when you first added support for skip scan on
-- an ocplass lacking a skip support routine
--
set client_min_messages=error;
drop table if exists dupindexcols;
reset client_min_messages;
CREATE UNLOGGED TABLE dupindexcols AS
  SELECT unique1 as id, stringu2::text as f1 FROM tenk1_skipscan;
CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
ANALYZE dupindexcols;
SELECT count(*) FROM dupindexcols
  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
 count 
-------
    97
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
  SELECT count(*) FROM dupindexcols
    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=156.56..156.57 rows=1 width=8) (actual rows=1.00 loops=1)
   Buffers: shared hit=104
   ->  Index Scan using dupindexcols_i on dupindexcols  (cost=0.29..156.30 rows=104 width=0) (actual rows=97.00 loops=1)
         Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
         Index Searches: 1
         Buffers: shared hit=104
 Planning:
   Buffers: shared hit=3
(8 rows)

-- (July 12) One of the last failing test cases when adding support for
-- non-skip-support opclasses.
--
-- This is based on int tests from Postgres 17 SAOP test suite, which failed
-- when I forced nbtree to not use skip support as a simple smoke test
--
-- This turned out to be an issue with NULLs, fixed like so:
-- diff --git a/src/backend/access/nbtree/nbtutils.c b/src/backend/access/nbtree/nbtutils.c
-- index 2e4cccde9..1c9519283 100644
-- --- a/src/backend/access/nbtree/nbtutils.c
-- +++ b/src/backend/access/nbtree/nbtutils.c
-- @@ -2002,20 +2002,10 @@ _bt_binsrch_skiparray_skey(FmgrInfo *orderproc,
--      {
--          if (tupnull && !array->null_elem)
--          {
-- -            if (ScanDirectionIsForward(dir))
-- -            {
-- -                if (!(cur->sk_flags & SK_BT_NULLS_FIRST))
-- -                    *set_elem_result = 1;
-- -                else
-- -                    *set_elem_result = -1;
-- -            }
-- +            if (!(cur->sk_flags & SK_BT_NULLS_FIRST))
-- +                *set_elem_result = 1;
--              else
-- -            {
-- -                if (!(cur->sk_flags & SK_BT_NULLS_FIRST))
-- -                    *set_elem_result = -1;
-- -                else
-- -                    *set_elem_result = 1;
-- -            }
-- +                *set_elem_result = -1;
--
--              return;
--          }
set client_min_messages=error;
drop table if exists redescend_numeric_test;
reset client_min_messages;
create unlogged table redescend_numeric_test (district numeric, warehouse numeric, orderid numeric, orderline numeric);
create index must_not_full_scan_numeric on redescend_numeric_test (district, warehouse, orderid, orderline) with (fillfactor=30);
insert into redescend_numeric_test
select district, warehouse, orderid, orderline
from
  generate_series(1, 3) district,
  generate_series(1, 5) warehouse,
  generate_series(1, 150) orderid,
  generate_series(1, 10) orderline
order by
district, warehouse, orderid, orderline;
-- prewarm
select count(*) from redescend_numeric_test;
 count 
-------
 22500
(1 row)

vacuum analyze redescend_numeric_test;
---------------------------------------------------------------------------------
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
set client_min_messages=error;
drop table if exists redescend_numeric_test;
reset client_min_messages;
create unlogged table redescend_numeric_test (district numeric, warehouse numeric, orderid numeric, orderline numeric);
create index must_not_full_scan_numeric_idx on redescend_numeric_test (district, warehouse, orderid, orderline) with (fillfactor=30);
insert into redescend_numeric_test
select district, warehouse, orderid, orderline
from
  generate_series(1, 3) district,
  generate_series(1, 5) warehouse,
  generate_series(1, 150) orderid,
  generate_series(1, 10) orderline
order by
district, warehouse, orderid, orderline;
-- prewarm
select count(*) from redescend_numeric_test;
 count 
-------
 22500
(1 row)

vacuum analyze redescend_numeric_test;
---------------------------------------------------------------------------------
insert into redescend_numeric_test
select district, NULL, NULL, NULL
from
  generate_series(1, 3) district,
  generate_series(1, 5) want_five_nulls_per_district;
-- (July 16) Suspected that this was a bug, but master is also affected (no
-- skip arrays here).
--
-- The fact that we have to read page 217 twice here is okay, AFAICT, because
-- the second read cannot possibly find matching tuples that are returned to
-- the scan.
--
-- Note: a bunch of later tests also read page 217 twice, in much the same
-- way.  This test memorializes the fact that this issue isn't unique to skip
-- scan.
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse = 1 and orderid = 1 and orderline in (-1, 2) -- "orderline in (-1, 1)" won't do here
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         2
        2 |         1 |       1 |         2
        1 |         1 |       1 |         2
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse = 1 and orderid = 1 and orderline in (-1, 2)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..17.46 rows=2 width=20) (actual rows=3.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse = '1'::numeric) AND (orderid = '1'::numeric) AND (orderline = ANY ('{-1,2}'::numeric[])))
   Index Searches: 4
   Buffers: shared hit=17
(4 rows)

-- Simplest possible repro:
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid = 1 and orderline = 6
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         6
        2 |         1 |       1 |         6
        1 |         1 |       1 |         6
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid = 1 and orderline = 6
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..10.18 rows=2 width=20) (actual rows=3.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse <= '1'::numeric) AND (orderid = '1'::numeric) AND (orderline = '6'::numeric))
   Index Searches: 4
   Buffers: shared hit=17
(4 rows)

select * from redescend_numeric_test where district in (1,2,3) and warehouse > 4 and orderid > 149;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         1
        1 |         5 |     150 |         2
        1 |         5 |     150 |         3
        1 |         5 |     150 |         4
        1 |         5 |     150 |         5
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        1 |         5 |     150 |         9
        1 |         5 |     150 |        10
        2 |         5 |     150 |         1
        2 |         5 |     150 |         2
        2 |         5 |     150 |         3
        2 |         5 |     150 |         4
        2 |         5 |     150 |         5
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        2 |         5 |     150 |         9
        2 |         5 |     150 |        10
        3 |         5 |     150 |         1
        3 |         5 |     150 |         2
        3 |         5 |     150 |         3
        3 |         5 |     150 |         4
        3 |         5 |     150 |         5
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
        3 |         5 |     150 |         9
        3 |         5 |     150 |        10
(30 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test where district in (1,2,3) and warehouse > 4 and orderid > 149; -- 24 buffer hits patch, 76 buffer hits master
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..27.22 rows=22 width=20) (actual rows=30.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse > '4'::numeric) AND (orderid > '149'::numeric))
   Index Searches: 6
   Buffers: shared hit=24
(4 rows)

select * from redescend_numeric_test where district in (1,2,3) and warehouse = 5 and orderid > 149;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        1 |         5 |     150 |         1
        1 |         5 |     150 |         2
        1 |         5 |     150 |         3
        1 |         5 |     150 |         4
        1 |         5 |     150 |         5
        1 |         5 |     150 |         6
        1 |         5 |     150 |         7
        1 |         5 |     150 |         8
        1 |         5 |     150 |         9
        1 |         5 |     150 |        10
        2 |         5 |     150 |         1
        2 |         5 |     150 |         2
        2 |         5 |     150 |         3
        2 |         5 |     150 |         4
        2 |         5 |     150 |         5
        2 |         5 |     150 |         6
        2 |         5 |     150 |         7
        2 |         5 |     150 |         8
        2 |         5 |     150 |         9
        2 |         5 |     150 |        10
        3 |         5 |     150 |         1
        3 |         5 |     150 |         2
        3 |         5 |     150 |         3
        3 |         5 |     150 |         4
        3 |         5 |     150 |         5
        3 |         5 |     150 |         6
        3 |         5 |     150 |         7
        3 |         5 |     150 |         8
        3 |         5 |     150 |         9
        3 |         5 |     150 |        10
(30 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test where district in (1,2,3) and warehouse = 5 and orderid > 149; -- 13 buffer hits (patch + master)
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..27.22 rows=22 width=20) (actual rows=30.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse = '5'::numeric) AND (orderid > '149'::numeric))
   Index Searches: 3
   Buffers: shared hit=13
(4 rows)

select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse < 2 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse < 2 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..28.28 rows=6 width=20) (actual rows=9.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse < '2'::numeric) AND (orderid < '2'::numeric) AND (orderline = ANY ('{6,7,8}'::numeric[])))
   Index Searches: 7
   Buffers: shared hit=26
(4 rows)

select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..28.28 rows=6 width=20) (actual rows=9.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse <= '1'::numeric) AND (orderid <= '1'::numeric) AND (orderline = ANY ('{6,7,8}'::numeric[])))
   Index Searches: 4
   Buffers: shared hit=17
(4 rows)

select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid in (0, 1) and orderline >= any ('{6,7,8}')
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |        10
        3 |         1 |       1 |         9
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |        10
        2 |         1 |       1 |         9
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |        10
        1 |         1 |       1 |         9
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(15 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid in (0, 1) and orderline >= any ('{6,7,8}')
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..71.67 rows=33 width=20) (actual rows=15.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse <= '1'::numeric) AND (orderid = ANY ('{0,1}'::numeric[])) AND (orderline >= ANY ('{6,7,8}'::numeric[])))
   Index Searches: 4
   Buffers: shared hit=17
(4 rows)

select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (-1, 6, 8, 1000)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         6
(6 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid <= 1 and orderline in (-1, 6, 8, 1000)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..33.80 rows=4 width=20) (actual rows=6.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse <= '1'::numeric) AND (orderid <= '1'::numeric) AND (orderline = ANY ('{-1,6,8,1000}'::numeric[])))
   Index Searches: 4
   Buffers: shared hit=17
(4 rows)

select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse <= 1 and orderid < 2 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..28.28 rows=6 width=20) (actual rows=9.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse <= '1'::numeric) AND (orderid < '2'::numeric) AND (orderline = ANY ('{6,7,8}'::numeric[])))
   Index Searches: 4
   Buffers: shared hit=17
(4 rows)

select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse < 2 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
 district | warehouse | orderid | orderline 
----------+-----------+---------+-----------
        3 |         1 |       1 |         8
        3 |         1 |       1 |         7
        3 |         1 |       1 |         6
        2 |         1 |       1 |         8
        2 |         1 |       1 |         7
        2 |         1 |       1 |         6
        1 |         1 |       1 |         8
        1 |         1 |       1 |         7
        1 |         1 |       1 |         6
(9 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from redescend_numeric_test
where district in (1, 2, 3) and warehouse < 2 and orderid <= 1 and orderline in (6, 7, 8)
order by district desc, warehouse desc, orderid desc, orderline desc;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using must_not_full_scan_numeric_idx on redescend_numeric_test  (cost=0.41..28.28 rows=6 width=20) (actual rows=9.00 loops=1)
   Index Cond: ((district = ANY ('{1,2,3}'::numeric[])) AND (warehouse < '2'::numeric) AND (orderid <= '1'::numeric) AND (orderline = ANY ('{6,7,8}'::numeric[])))
   Index Searches: 7
   Buffers: shared hit=26
(4 rows)

----------------------------------------------------------------------------
-- Inequalties required in opposite direction only with skip arrays tests --
----------------------------------------------------------------------------
-- (August 6) These tests were added when you finally started to get serious
-- about the need for skip-array-specific heuristics
set client_min_messages=error;
drop table if exists lessthan_skip_test;
reset client_min_messages;
-- Bitmap index scans
set enable_bitmapscan to on;
set enable_indexonlyscan to off;
set enable_indexscan to off;
create unlogged table lessthan_skip_test(skipattr int4, i int4);
create index ltidx on lessthan_skip_test (skipattr , i);
insert into lessthan_skip_test
select val, dups_per_val from generate_series(1, 90) val,
                generate_series(1,50) dups_per_val;
-- ltidx key space shows that we've truncated every pivot tuple's i key column:
-- pg@regression:5432 [309814]=# :leafkeyspace
-- ┌────┬───────┬───────┬────────┬────────┬────────────┬───────┬───────┬───────────────────┬─────────┬───────────┬────────────────────┐
-- │ i  │ blkno │ flags │ nhtids │ nhblks │ ndeadhblks │ nlive │ ndead │ nhtidschecksimple │ avgsize │ freespace │      highkey       │
-- ├────┼───────┼───────┼────────┼────────┼────────────┼───────┼───────┼───────────────────┼─────────┼───────────┼────────────────────┤
-- │  1 │     1 │     1 │    350 │     20 │          0 │   351 │     0 │                 0 │      16 │     1,128 │ (skipattr, i)=(8)  │
-- │  2 │    17 │     1 │    150 │     20 │          0 │   151 │     0 │                 0 │      16 │     5,128 │ (skipattr, i)=(11) │
-- │  3 │    12 │     1 │     50 │     20 │          0 │    51 │     0 │                 0 │      16 │     7,128 │ (skipattr, i)=(12) │
-- │  4 │    11 │     1 │    350 │     20 │          0 │   351 │     0 │                 0 │      16 │     1,128 │ (skipattr, i)=(19) │
-- │  5 │     6 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(24) │
-- │  6 │    18 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(29) │
-- │  7 │    10 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(34) │
-- │  8 │    19 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(39) │
-- │  9 │     4 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(44) │
-- │ 10 │    20 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(49) │
-- │ 11 │    13 │     1 │     50 │     20 │          0 │    51 │     0 │                 0 │      16 │     7,128 │ (skipattr, i)=(50) │
-- │ 12 │     8 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(55) │
-- │ 13 │    21 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(60) │
-- │ 14 │    14 │     1 │     50 │     20 │          0 │    51 │     0 │                 0 │      16 │     7,128 │ (skipattr, i)=(61) │
-- │ 15 │     9 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(66) │
-- │ 16 │    22 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(71) │
-- │ 17 │    15 │     1 │     50 │     20 │          0 │    51 │     0 │                 0 │      16 │     7,128 │ (skipattr, i)=(72) │
-- │ 18 │     7 │     1 │    200 │     20 │          0 │   201 │     0 │                 0 │      16 │     4,128 │ (skipattr, i)=(76) │
-- │ 19 │     5 │     1 │    200 │     20 │          0 │   201 │     0 │                 0 │      16 │     4,128 │ (skipattr, i)=(80) │
-- │ 20 │     2 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(85) │
-- │ 21 │    23 │     1 │    250 │     20 │          0 │   251 │     0 │                 0 │      16 │     3,128 │ (skipattr, i)=(90) │
-- │ 22 │    16 │     1 │     50 │     20 │          0 │    50 │     0 │                 0 │      16 │     7,148 │ ∅                  │
-- └────┴───────┴───────┴────────┴────────┴────────────┴───────┴───────┴───────────────────┴─────────┴───────────┴────────────────────┘
-- (22 rows)
--
-- This is :rootitems, just to avoid test regressions:
select itemoffset, ctid, itemlen, nulls from bt_page_items('ltidx',
  (select fastroot::int4 from bt_metap('ltidx')));
 itemoffset |  ctid  | itemlen | nulls 
------------+--------+---------+-------
          1 | (1,0)  |       8 | f
          2 | (17,1) |      16 | f
          3 | (12,1) |      16 | f
          4 | (11,1) |      16 | f
          5 | (6,1)  |      16 | f
          6 | (18,1) |      16 | f
          7 | (10,1) |      16 | f
          8 | (19,1) |      16 | f
          9 | (4,1)  |      16 | f
         10 | (20,1) |      16 | f
         11 | (13,1) |      16 | f
         12 | (8,1)  |      16 | f
         13 | (21,1) |      16 | f
         14 | (14,1) |      16 | f
         15 | (9,1)  |      16 | f
         16 | (22,1) |      16 | f
         17 | (15,1) |      16 | f
         18 | (7,1)  |      16 | f
         19 | (5,1)  |      16 | f
         20 | (2,1)  |      16 | f
         21 | (23,1) |      16 | f
         22 | (16,1) |      16 | f
(22 rows)

-- 23 index buffer hits (parity with master):
select * from lessthan_skip_test where i = 2;
 skipattr | i 
----------+---
        1 | 2
        2 | 2
        3 | 2
        4 | 2
        5 | 2
        6 | 2
        7 | 2
        8 | 2
        9 | 2
       10 | 2
       11 | 2
       12 | 2
       13 | 2
       14 | 2
       15 | 2
       16 | 2
       17 | 2
       18 | 2
       19 | 2
       20 | 2
       21 | 2
       22 | 2
       23 | 2
       24 | 2
       25 | 2
       26 | 2
       27 | 2
       28 | 2
       29 | 2
       30 | 2
       31 | 2
       32 | 2
       33 | 2
       34 | 2
       35 | 2
       36 | 2
       37 | 2
       38 | 2
       39 | 2
       40 | 2
       41 | 2
       42 | 2
       43 | 2
       44 | 2
       45 | 2
       46 | 2
       47 | 2
       48 | 2
       49 | 2
       50 | 2
       51 | 2
       52 | 2
       53 | 2
       54 | 2
       55 | 2
       56 | 2
       57 | 2
       58 | 2
       59 | 2
       60 | 2
       61 | 2
       62 | 2
       63 | 2
       64 | 2
       65 | 2
       66 | 2
       67 | 2
       68 | 2
       69 | 2
       70 | 2
       71 | 2
       72 | 2
       73 | 2
       74 | 2
       75 | 2
       76 | 2
       77 | 2
       78 | 2
       79 | 2
       80 | 2
       81 | 2
       82 | 2
       83 | 2
       84 | 2
       85 | 2
       86 | 2
       87 | 2
       88 | 2
       89 | 2
       90 | 2
(90 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i = 2;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on lessthan_skip_test  (cost=82.19..99.49 rows=23 width=8) (actual rows=90.00 loops=1)
   Recheck Cond: (i = 2)
   Heap Blocks: exact=1
   Buffers: shared hit=24
   ->  Bitmap Index Scan on ltidx  (cost=0.00..82.18 rows=23 width=0) (actual rows=90.00 loops=1)
         Index Cond: (i = 2)
         Index Searches: 1
         Buffers: shared hit=23
(8 rows)

-- Also 23 index buffer hits (also parity with master):
select * from lessthan_skip_test where i < 2;
 skipattr | i 
----------+---
        1 | 1
        2 | 1
        3 | 1
        4 | 1
        5 | 1
        6 | 1
        7 | 1
        8 | 1
        9 | 1
       10 | 1
       11 | 1
       12 | 1
       13 | 1
       14 | 1
       15 | 1
       16 | 1
       17 | 1
       18 | 1
       19 | 1
       20 | 1
       21 | 1
       22 | 1
       23 | 1
       24 | 1
       25 | 1
       26 | 1
       27 | 1
       28 | 1
       29 | 1
       30 | 1
       31 | 1
       32 | 1
       33 | 1
       34 | 1
       35 | 1
       36 | 1
       37 | 1
       38 | 1
       39 | 1
       40 | 1
       41 | 1
       42 | 1
       43 | 1
       44 | 1
       45 | 1
       46 | 1
       47 | 1
       48 | 1
       49 | 1
       50 | 1
       51 | 1
       52 | 1
       53 | 1
       54 | 1
       55 | 1
       56 | 1
       57 | 1
       58 | 1
       59 | 1
       60 | 1
       61 | 1
       62 | 1
       63 | 1
       64 | 1
       65 | 1
       66 | 1
       67 | 1
       68 | 1
       69 | 1
       70 | 1
       71 | 1
       72 | 1
       73 | 1
       74 | 1
       75 | 1
       76 | 1
       77 | 1
       78 | 1
       79 | 1
       80 | 1
       81 | 1
       82 | 1
       83 | 1
       84 | 1
       85 | 1
       86 | 1
       87 | 1
       88 | 1
       89 | 1
       90 | 1
(90 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i < 2;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on lessthan_skip_test  (cost=82.56..121.40 rows=1507 width=8) (actual rows=90.00 loops=1)
   Recheck Cond: (i < 2)
   Heap Blocks: exact=1
   Buffers: shared hit=24
   ->  Bitmap Index Scan on ltidx  (cost=0.00..82.18 rows=1507 width=0) (actual rows=90.00 loops=1)
         Index Cond: (i < 2)
         Index Searches: 1
         Buffers: shared hit=23
(8 rows)

-- Problematic case where we also expect 23 index buffer hits, for parity with
-- master:
select * from lessthan_skip_test where i > 46;
 skipattr | i  
----------+----
        1 | 47
        2 | 47
        3 | 47
        4 | 47
        5 | 47
        6 | 47
        7 | 47
        8 | 47
        9 | 47
       10 | 47
       11 | 47
       12 | 47
       13 | 47
       14 | 47
       15 | 47
       16 | 47
       17 | 47
       18 | 47
       19 | 47
       20 | 47
       21 | 47
       22 | 47
       23 | 47
       24 | 47
       25 | 47
       26 | 47
       27 | 47
       28 | 47
       29 | 47
       30 | 47
       31 | 47
       32 | 47
       33 | 47
       34 | 47
       35 | 47
       36 | 47
       37 | 47
       38 | 47
       39 | 47
       40 | 47
       41 | 47
       42 | 47
       43 | 47
       44 | 47
       45 | 47
       46 | 47
       47 | 47
       48 | 47
       49 | 47
       50 | 47
       51 | 47
       52 | 47
       53 | 47
       54 | 47
       55 | 47
       56 | 47
       57 | 47
       58 | 47
       59 | 47
       60 | 47
       61 | 47
       62 | 47
       63 | 47
       64 | 47
       65 | 47
       66 | 47
       67 | 47
       68 | 47
       69 | 47
       70 | 47
       71 | 47
       72 | 47
       73 | 47
       74 | 47
       75 | 47
       76 | 47
       77 | 47
       78 | 47
       79 | 47
       80 | 47
       81 | 47
       82 | 47
       83 | 47
       84 | 47
       85 | 47
       86 | 47
       87 | 47
       88 | 47
       89 | 47
       90 | 47
        1 | 48
        2 | 48
        3 | 48
        4 | 48
        5 | 48
        6 | 48
        7 | 48
        8 | 48
        9 | 48
       10 | 48
       11 | 48
       12 | 48
       13 | 48
       14 | 48
       15 | 48
       16 | 48
       17 | 48
       18 | 48
       19 | 48
       20 | 48
       21 | 48
       22 | 48
       23 | 48
       24 | 48
       25 | 48
       26 | 48
       27 | 48
       28 | 48
       29 | 48
       30 | 48
       31 | 48
       32 | 48
       33 | 48
       34 | 48
       35 | 48
       36 | 48
       37 | 48
       38 | 48
       39 | 48
       40 | 48
       41 | 48
       42 | 48
       43 | 48
       44 | 48
       45 | 48
       46 | 48
       47 | 48
       48 | 48
       49 | 48
       50 | 48
       51 | 48
       52 | 48
       53 | 48
       54 | 48
       55 | 48
       56 | 48
       57 | 48
       58 | 48
       59 | 48
       60 | 48
       61 | 48
       62 | 48
       63 | 48
       64 | 48
       65 | 48
       66 | 48
       67 | 48
       68 | 48
       69 | 48
       70 | 48
       71 | 48
       72 | 48
       73 | 48
       74 | 48
       75 | 48
       76 | 48
       77 | 48
       78 | 48
       79 | 48
       80 | 48
       81 | 48
       82 | 48
       83 | 48
       84 | 48
       85 | 48
       86 | 48
       87 | 48
       88 | 48
       89 | 48
       90 | 48
        1 | 49
        2 | 49
        3 | 49
        4 | 49
        5 | 49
        6 | 49
        7 | 49
        8 | 49
        9 | 49
       10 | 49
       11 | 49
       12 | 49
       13 | 49
       14 | 49
       15 | 49
       16 | 49
       17 | 49
       18 | 49
       19 | 49
       20 | 49
       21 | 49
       22 | 49
       23 | 49
       24 | 49
       25 | 49
       26 | 49
       27 | 49
       28 | 49
       29 | 49
       30 | 49
       31 | 49
       32 | 49
       33 | 49
       34 | 49
       35 | 49
       36 | 49
       37 | 49
       38 | 49
       39 | 49
       40 | 49
       41 | 49
       42 | 49
       43 | 49
       44 | 49
       45 | 49
       46 | 49
       47 | 49
       48 | 49
       49 | 49
       50 | 49
       51 | 49
       52 | 49
       53 | 49
       54 | 49
       55 | 49
       56 | 49
       57 | 49
       58 | 49
       59 | 49
       60 | 49
       61 | 49
       62 | 49
       63 | 49
       64 | 49
       65 | 49
       66 | 49
       67 | 49
       68 | 49
       69 | 49
       70 | 49
       71 | 49
       72 | 49
       73 | 49
       74 | 49
       75 | 49
       76 | 49
       77 | 49
       78 | 49
       79 | 49
       80 | 49
       81 | 49
       82 | 49
       83 | 49
       84 | 49
       85 | 49
       86 | 49
       87 | 49
       88 | 49
       89 | 49
       90 | 49
        1 | 50
        2 | 50
        3 | 50
        4 | 50
        5 | 50
        6 | 50
        7 | 50
        8 | 50
        9 | 50
       10 | 50
       11 | 50
       12 | 50
       13 | 50
       14 | 50
       15 | 50
       16 | 50
       17 | 50
       18 | 50
       19 | 50
       20 | 50
       21 | 50
       22 | 50
       23 | 50
       24 | 50
       25 | 50
       26 | 50
       27 | 50
       28 | 50
       29 | 50
       30 | 50
       31 | 50
       32 | 50
       33 | 50
       34 | 50
       35 | 50
       36 | 50
       37 | 50
       38 | 50
       39 | 50
       40 | 50
       41 | 50
       42 | 50
       43 | 50
       44 | 50
       45 | 50
       46 | 50
       47 | 50
       48 | 50
       49 | 50
       50 | 50
       51 | 50
       52 | 50
       53 | 50
       54 | 50
       55 | 50
       56 | 50
       57 | 50
       58 | 50
       59 | 50
       60 | 50
       61 | 50
       62 | 50
       63 | 50
       64 | 50
       65 | 50
       66 | 50
       67 | 50
       68 | 50
       69 | 50
       70 | 50
       71 | 50
       72 | 50
       73 | 50
       74 | 50
       75 | 50
       76 | 50
       77 | 50
       78 | 50
       79 | 50
       80 | 50
       81 | 50
       82 | 50
       83 | 50
       84 | 50
       85 | 50
       86 | 50
       87 | 50
       88 | 50
       89 | 50
       90 | 50
(360 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i > 46;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on lessthan_skip_test  (cost=82.56..121.40 rows=1507 width=8) (actual rows=360.00 loops=1)
   Recheck Cond: (i > 46)
   Heap Blocks: exact=2
   Buffers: shared hit=25
   ->  Bitmap Index Scan on ltidx  (cost=0.00..82.18 rows=1507 width=0) (actual rows=360.00 loops=1)
         Index Cond: (i > 46)
         Index Searches: 1
         Buffers: shared hit=23
(8 rows)

-- Another problematic case where we also expect 23 index buffer hits, for
-- parity with master:
select * from lessthan_skip_test where i between 40 and 46;
 skipattr | i  
----------+----
        1 | 40
        2 | 40
        3 | 40
        4 | 40
        5 | 40
        6 | 40
        7 | 40
        8 | 40
        9 | 40
       10 | 40
       11 | 40
       12 | 40
       13 | 40
       14 | 40
       15 | 40
       16 | 40
       17 | 40
       18 | 40
       19 | 40
       20 | 40
       21 | 40
       22 | 40
       23 | 40
       24 | 40
       25 | 40
       26 | 40
       27 | 40
       28 | 40
       29 | 40
       30 | 40
       31 | 40
       32 | 40
       33 | 40
       34 | 40
       35 | 40
       36 | 40
       37 | 40
       38 | 40
       39 | 40
       40 | 40
       41 | 40
       42 | 40
       43 | 40
       44 | 40
       45 | 40
       46 | 40
       47 | 40
       48 | 40
       49 | 40
       50 | 40
       51 | 40
       52 | 40
       53 | 40
       54 | 40
       55 | 40
       56 | 40
       57 | 40
       58 | 40
       59 | 40
       60 | 40
       61 | 40
       62 | 40
       63 | 40
       64 | 40
       65 | 40
       66 | 40
       67 | 40
       68 | 40
       69 | 40
       70 | 40
       71 | 40
       72 | 40
       73 | 40
       74 | 40
       75 | 40
       76 | 40
       77 | 40
       78 | 40
       79 | 40
       80 | 40
       81 | 40
       82 | 40
       83 | 40
       84 | 40
       85 | 40
       86 | 40
       87 | 40
       88 | 40
       89 | 40
       90 | 40
        1 | 41
        2 | 41
        3 | 41
        4 | 41
        5 | 41
        6 | 41
        7 | 41
        8 | 41
        9 | 41
       10 | 41
       11 | 41
       12 | 41
       13 | 41
       14 | 41
       15 | 41
       16 | 41
       17 | 41
       18 | 41
       19 | 41
       20 | 41
       21 | 41
       22 | 41
       23 | 41
       24 | 41
       25 | 41
       26 | 41
       27 | 41
       28 | 41
       29 | 41
       30 | 41
       31 | 41
       32 | 41
       33 | 41
       34 | 41
       35 | 41
       36 | 41
       37 | 41
       38 | 41
       39 | 41
       40 | 41
       41 | 41
       42 | 41
       43 | 41
       44 | 41
       45 | 41
       46 | 41
       47 | 41
       48 | 41
       49 | 41
       50 | 41
       51 | 41
       52 | 41
       53 | 41
       54 | 41
       55 | 41
       56 | 41
       57 | 41
       58 | 41
       59 | 41
       60 | 41
       61 | 41
       62 | 41
       63 | 41
       64 | 41
       65 | 41
       66 | 41
       67 | 41
       68 | 41
       69 | 41
       70 | 41
       71 | 41
       72 | 41
       73 | 41
       74 | 41
       75 | 41
       76 | 41
       77 | 41
       78 | 41
       79 | 41
       80 | 41
       81 | 41
       82 | 41
       83 | 41
       84 | 41
       85 | 41
       86 | 41
       87 | 41
       88 | 41
       89 | 41
       90 | 41
        1 | 42
        2 | 42
        3 | 42
        4 | 42
        5 | 42
        6 | 42
        7 | 42
        8 | 42
        9 | 42
       10 | 42
       11 | 42
       12 | 42
       13 | 42
       14 | 42
       15 | 42
       16 | 42
       17 | 42
       18 | 42
       19 | 42
       20 | 42
       21 | 42
       22 | 42
       23 | 42
       24 | 42
       25 | 42
       26 | 42
       27 | 42
       28 | 42
       29 | 42
       30 | 42
       31 | 42
       32 | 42
       33 | 42
       34 | 42
       35 | 42
       36 | 42
       37 | 42
       38 | 42
       39 | 42
       40 | 42
       41 | 42
       42 | 42
       43 | 42
       44 | 42
       45 | 42
       46 | 42
       47 | 42
       48 | 42
       49 | 42
       50 | 42
       51 | 42
       52 | 42
       53 | 42
       54 | 42
       55 | 42
       56 | 42
       57 | 42
       58 | 42
       59 | 42
       60 | 42
       61 | 42
       62 | 42
       63 | 42
       64 | 42
       65 | 42
       66 | 42
       67 | 42
       68 | 42
       69 | 42
       70 | 42
       71 | 42
       72 | 42
       73 | 42
       74 | 42
       75 | 42
       76 | 42
       77 | 42
       78 | 42
       79 | 42
       80 | 42
       81 | 42
       82 | 42
       83 | 42
       84 | 42
       85 | 42
       86 | 42
       87 | 42
       88 | 42
       89 | 42
       90 | 42
        1 | 43
        2 | 43
        3 | 43
        4 | 43
        5 | 43
        6 | 43
        7 | 43
        8 | 43
        9 | 43
       10 | 43
       11 | 43
       12 | 43
       13 | 43
       14 | 43
       15 | 43
       16 | 43
       17 | 43
       18 | 43
       19 | 43
       20 | 43
       21 | 43
       22 | 43
       23 | 43
       24 | 43
       25 | 43
       26 | 43
       27 | 43
       28 | 43
       29 | 43
       30 | 43
       31 | 43
       32 | 43
       33 | 43
       34 | 43
       35 | 43
       36 | 43
       37 | 43
       38 | 43
       39 | 43
       40 | 43
       41 | 43
       42 | 43
       43 | 43
       44 | 43
       45 | 43
       46 | 43
       47 | 43
       48 | 43
       49 | 43
       50 | 43
       51 | 43
       52 | 43
       53 | 43
       54 | 43
       55 | 43
       56 | 43
       57 | 43
       58 | 43
       59 | 43
       60 | 43
       61 | 43
       62 | 43
       63 | 43
       64 | 43
       65 | 43
       66 | 43
       67 | 43
       68 | 43
       69 | 43
       70 | 43
       71 | 43
       72 | 43
       73 | 43
       74 | 43
       75 | 43
       76 | 43
       77 | 43
       78 | 43
       79 | 43
       80 | 43
       81 | 43
       82 | 43
       83 | 43
       84 | 43
       85 | 43
       86 | 43
       87 | 43
       88 | 43
       89 | 43
       90 | 43
        1 | 44
        2 | 44
        3 | 44
        4 | 44
        5 | 44
        6 | 44
        7 | 44
        8 | 44
        9 | 44
       10 | 44
       11 | 44
       12 | 44
       13 | 44
       14 | 44
       15 | 44
       16 | 44
       17 | 44
       18 | 44
       19 | 44
       20 | 44
       21 | 44
       22 | 44
       23 | 44
       24 | 44
       25 | 44
       26 | 44
       27 | 44
       28 | 44
       29 | 44
       30 | 44
       31 | 44
       32 | 44
       33 | 44
       34 | 44
       35 | 44
       36 | 44
       37 | 44
       38 | 44
       39 | 44
       40 | 44
       41 | 44
       42 | 44
       43 | 44
       44 | 44
       45 | 44
       46 | 44
       47 | 44
       48 | 44
       49 | 44
       50 | 44
       51 | 44
       52 | 44
       53 | 44
       54 | 44
       55 | 44
       56 | 44
       57 | 44
       58 | 44
       59 | 44
       60 | 44
       61 | 44
       62 | 44
       63 | 44
       64 | 44
       65 | 44
       66 | 44
       67 | 44
       68 | 44
       69 | 44
       70 | 44
       71 | 44
       72 | 44
       73 | 44
       74 | 44
       75 | 44
       76 | 44
       77 | 44
       78 | 44
       79 | 44
       80 | 44
       81 | 44
       82 | 44
       83 | 44
       84 | 44
       85 | 44
       86 | 44
       87 | 44
       88 | 44
       89 | 44
       90 | 44
        1 | 45
        2 | 45
        3 | 45
        4 | 45
        5 | 45
        6 | 45
        7 | 45
        8 | 45
        9 | 45
       10 | 45
       11 | 45
       12 | 45
       13 | 45
       14 | 45
       15 | 45
       16 | 45
       17 | 45
       18 | 45
       19 | 45
       20 | 45
       21 | 45
       22 | 45
       23 | 45
       24 | 45
       25 | 45
       26 | 45
       27 | 45
       28 | 45
       29 | 45
       30 | 45
       31 | 45
       32 | 45
       33 | 45
       34 | 45
       35 | 45
       36 | 45
       37 | 45
       38 | 45
       39 | 45
       40 | 45
       41 | 45
       42 | 45
       43 | 45
       44 | 45
       45 | 45
       46 | 45
       47 | 45
       48 | 45
       49 | 45
       50 | 45
       51 | 45
       52 | 45
       53 | 45
       54 | 45
       55 | 45
       56 | 45
       57 | 45
       58 | 45
       59 | 45
       60 | 45
       61 | 45
       62 | 45
       63 | 45
       64 | 45
       65 | 45
       66 | 45
       67 | 45
       68 | 45
       69 | 45
       70 | 45
       71 | 45
       72 | 45
       73 | 45
       74 | 45
       75 | 45
       76 | 45
       77 | 45
       78 | 45
       79 | 45
       80 | 45
       81 | 45
       82 | 45
       83 | 45
       84 | 45
       85 | 45
       86 | 45
       87 | 45
       88 | 45
       89 | 45
       90 | 45
        1 | 46
        2 | 46
        3 | 46
        4 | 46
        5 | 46
        6 | 46
        7 | 46
        8 | 46
        9 | 46
       10 | 46
       11 | 46
       12 | 46
       13 | 46
       14 | 46
       15 | 46
       16 | 46
       17 | 46
       18 | 46
       19 | 46
       20 | 46
       21 | 46
       22 | 46
       23 | 46
       24 | 46
       25 | 46
       26 | 46
       27 | 46
       28 | 46
       29 | 46
       30 | 46
       31 | 46
       32 | 46
       33 | 46
       34 | 46
       35 | 46
       36 | 46
       37 | 46
       38 | 46
       39 | 46
       40 | 46
       41 | 46
       42 | 46
       43 | 46
       44 | 46
       45 | 46
       46 | 46
       47 | 46
       48 | 46
       49 | 46
       50 | 46
       51 | 46
       52 | 46
       53 | 46
       54 | 46
       55 | 46
       56 | 46
       57 | 46
       58 | 46
       59 | 46
       60 | 46
       61 | 46
       62 | 46
       63 | 46
       64 | 46
       65 | 46
       66 | 46
       67 | 46
       68 | 46
       69 | 46
       70 | 46
       71 | 46
       72 | 46
       73 | 46
       74 | 46
       75 | 46
       76 | 46
       77 | 46
       78 | 46
       79 | 46
       80 | 46
       81 | 46
       82 | 46
       83 | 46
       84 | 46
       85 | 46
       86 | 46
       87 | 46
       88 | 46
       89 | 46
       90 | 46
(630 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i between 40 and 46;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on lessthan_skip_test  (cost=93.49..110.84 rows=23 width=8) (actual rows=630.00 loops=1)
   Recheck Cond: ((i >= 40) AND (i <= 46))
   Heap Blocks: exact=4
   Buffers: shared hit=27
   ->  Bitmap Index Scan on ltidx  (cost=0.00..93.48 rows=23 width=0) (actual rows=630.00 loops=1)
         Index Cond: ((i >= 40) AND (i <= 46))
         Index Searches: 1
         Buffers: shared hit=23
(8 rows)

-- Another problematic case where we also expect 23 index buffer hits, for
-- parity with master:
select * from lessthan_skip_test where i between 50 and 51;
 skipattr | i  
----------+----
        1 | 50
        2 | 50
        3 | 50
        4 | 50
        5 | 50
        6 | 50
        7 | 50
        8 | 50
        9 | 50
       10 | 50
       11 | 50
       12 | 50
       13 | 50
       14 | 50
       15 | 50
       16 | 50
       17 | 50
       18 | 50
       19 | 50
       20 | 50
       21 | 50
       22 | 50
       23 | 50
       24 | 50
       25 | 50
       26 | 50
       27 | 50
       28 | 50
       29 | 50
       30 | 50
       31 | 50
       32 | 50
       33 | 50
       34 | 50
       35 | 50
       36 | 50
       37 | 50
       38 | 50
       39 | 50
       40 | 50
       41 | 50
       42 | 50
       43 | 50
       44 | 50
       45 | 50
       46 | 50
       47 | 50
       48 | 50
       49 | 50
       50 | 50
       51 | 50
       52 | 50
       53 | 50
       54 | 50
       55 | 50
       56 | 50
       57 | 50
       58 | 50
       59 | 50
       60 | 50
       61 | 50
       62 | 50
       63 | 50
       64 | 50
       65 | 50
       66 | 50
       67 | 50
       68 | 50
       69 | 50
       70 | 50
       71 | 50
       72 | 50
       73 | 50
       74 | 50
       75 | 50
       76 | 50
       77 | 50
       78 | 50
       79 | 50
       80 | 50
       81 | 50
       82 | 50
       83 | 50
       84 | 50
       85 | 50
       86 | 50
       87 | 50
       88 | 50
       89 | 50
       90 | 50
(90 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i between 50 and 51;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on lessthan_skip_test  (cost=93.49..110.84 rows=23 width=8) (actual rows=90.00 loops=1)
   Recheck Cond: ((i >= 50) AND (i <= 51))
   Heap Blocks: exact=1
   Buffers: shared hit=24
   ->  Bitmap Index Scan on ltidx  (cost=0.00..93.48 rows=23 width=0) (actual rows=90.00 loops=1)
         Index Cond: ((i >= 50) AND (i <= 51))
         Index Searches: 1
         Buffers: shared hit=23
(8 rows)

-- Another problematic case where master gets 23 index buffer hits:
select * from lessthan_skip_test where i between 51 and 50;
 skipattr | i 
----------+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i between 51 and 50;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on lessthan_skip_test  (cost=93.49..110.84 rows=23 width=8) (actual rows=0.00 loops=1)
   Recheck Cond: ((i >= 51) AND (i <= 50))
   Buffers: shared hit=23
   ->  Bitmap Index Scan on ltidx  (cost=0.00..93.48 rows=23 width=0) (actual rows=0.00 loops=1)
         Index Cond: ((i >= 51) AND (i <= 50))
         Index Searches: 1
         Buffers: shared hit=23
(7 rows)

-- backwards scans:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
-- 24 index buffer hits on master:
select * from lessthan_skip_test where i = 2 order by skipattr desc, i desc;
 skipattr | i 
----------+---
       90 | 2
       89 | 2
       88 | 2
       87 | 2
       86 | 2
       85 | 2
       84 | 2
       83 | 2
       82 | 2
       81 | 2
       80 | 2
       79 | 2
       78 | 2
       77 | 2
       76 | 2
       75 | 2
       74 | 2
       73 | 2
       72 | 2
       71 | 2
       70 | 2
       69 | 2
       68 | 2
       67 | 2
       66 | 2
       65 | 2
       64 | 2
       63 | 2
       62 | 2
       61 | 2
       60 | 2
       59 | 2
       58 | 2
       57 | 2
       56 | 2
       55 | 2
       54 | 2
       53 | 2
       52 | 2
       51 | 2
       50 | 2
       49 | 2
       48 | 2
       47 | 2
       46 | 2
       45 | 2
       44 | 2
       43 | 2
       42 | 2
       41 | 2
       40 | 2
       39 | 2
       38 | 2
       37 | 2
       36 | 2
       35 | 2
       34 | 2
       33 | 2
       32 | 2
       31 | 2
       30 | 2
       29 | 2
       28 | 2
       27 | 2
       26 | 2
       25 | 2
       24 | 2
       23 | 2
       22 | 2
       21 | 2
       20 | 2
       19 | 2
       18 | 2
       17 | 2
       16 | 2
       15 | 2
       14 | 2
       13 | 2
       12 | 2
       11 | 2
       10 | 2
        9 | 2
        8 | 2
        7 | 2
        6 | 2
        5 | 2
        4 | 2
        3 | 2
        2 | 2
        1 | 2
(90 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i = 2 order by skipattr desc, i desc;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using ltidx on lessthan_skip_test  (cost=0.28..112.41 rows=23 width=8) (actual rows=90.00 loops=1)
   Index Cond: (i = 2)
   Index Searches: 2
   Buffers: shared hit=25
(4 rows)

-- 24 index buffer hits on master:
select * from lessthan_skip_test where i < 2 order by skipattr desc, i desc;
 skipattr | i 
----------+---
       90 | 1
       89 | 1
       88 | 1
       87 | 1
       86 | 1
       85 | 1
       84 | 1
       83 | 1
       82 | 1
       81 | 1
       80 | 1
       79 | 1
       78 | 1
       77 | 1
       76 | 1
       75 | 1
       74 | 1
       73 | 1
       72 | 1
       71 | 1
       70 | 1
       69 | 1
       68 | 1
       67 | 1
       66 | 1
       65 | 1
       64 | 1
       63 | 1
       62 | 1
       61 | 1
       60 | 1
       59 | 1
       58 | 1
       57 | 1
       56 | 1
       55 | 1
       54 | 1
       53 | 1
       52 | 1
       51 | 1
       50 | 1
       49 | 1
       48 | 1
       47 | 1
       46 | 1
       45 | 1
       44 | 1
       43 | 1
       42 | 1
       41 | 1
       40 | 1
       39 | 1
       38 | 1
       37 | 1
       36 | 1
       35 | 1
       34 | 1
       33 | 1
       32 | 1
       31 | 1
       30 | 1
       29 | 1
       28 | 1
       27 | 1
       26 | 1
       25 | 1
       24 | 1
       23 | 1
       22 | 1
       21 | 1
       20 | 1
       19 | 1
       18 | 1
       17 | 1
       16 | 1
       15 | 1
       14 | 1
       13 | 1
       12 | 1
       11 | 1
       10 | 1
        9 | 1
        8 | 1
        7 | 1
        6 | 1
        5 | 1
        4 | 1
        3 | 1
        2 | 1
        1 | 1
(90 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i < 2 order by skipattr desc, i desc;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using ltidx on lessthan_skip_test  (cost=0.28..137.25 rows=1507 width=8) (actual rows=90.00 loops=1)
   Index Cond: (i < 2)
   Index Searches: 1
   Buffers: shared hit=24
(4 rows)

-- 203 buffer hits on master:
select * from lessthan_skip_test where i > 46 order by skipattr desc, i desc;
 skipattr | i  
----------+----
       90 | 50
       90 | 49
       90 | 48
       90 | 47
       89 | 50
       89 | 49
       89 | 48
       89 | 47
       88 | 50
       88 | 49
       88 | 48
       88 | 47
       87 | 50
       87 | 49
       87 | 48
       87 | 47
       86 | 50
       86 | 49
       86 | 48
       86 | 47
       85 | 50
       85 | 49
       85 | 48
       85 | 47
       84 | 50
       84 | 49
       84 | 48
       84 | 47
       83 | 50
       83 | 49
       83 | 48
       83 | 47
       82 | 50
       82 | 49
       82 | 48
       82 | 47
       81 | 50
       81 | 49
       81 | 48
       81 | 47
       80 | 50
       80 | 49
       80 | 48
       80 | 47
       79 | 50
       79 | 49
       79 | 48
       79 | 47
       78 | 50
       78 | 49
       78 | 48
       78 | 47
       77 | 50
       77 | 49
       77 | 48
       77 | 47
       76 | 50
       76 | 49
       76 | 48
       76 | 47
       75 | 50
       75 | 49
       75 | 48
       75 | 47
       74 | 50
       74 | 49
       74 | 48
       74 | 47
       73 | 50
       73 | 49
       73 | 48
       73 | 47
       72 | 50
       72 | 49
       72 | 48
       72 | 47
       71 | 50
       71 | 49
       71 | 48
       71 | 47
       70 | 50
       70 | 49
       70 | 48
       70 | 47
       69 | 50
       69 | 49
       69 | 48
       69 | 47
       68 | 50
       68 | 49
       68 | 48
       68 | 47
       67 | 50
       67 | 49
       67 | 48
       67 | 47
       66 | 50
       66 | 49
       66 | 48
       66 | 47
       65 | 50
       65 | 49
       65 | 48
       65 | 47
       64 | 50
       64 | 49
       64 | 48
       64 | 47
       63 | 50
       63 | 49
       63 | 48
       63 | 47
       62 | 50
       62 | 49
       62 | 48
       62 | 47
       61 | 50
       61 | 49
       61 | 48
       61 | 47
       60 | 50
       60 | 49
       60 | 48
       60 | 47
       59 | 50
       59 | 49
       59 | 48
       59 | 47
       58 | 50
       58 | 49
       58 | 48
       58 | 47
       57 | 50
       57 | 49
       57 | 48
       57 | 47
       56 | 50
       56 | 49
       56 | 48
       56 | 47
       55 | 50
       55 | 49
       55 | 48
       55 | 47
       54 | 50
       54 | 49
       54 | 48
       54 | 47
       53 | 50
       53 | 49
       53 | 48
       53 | 47
       52 | 50
       52 | 49
       52 | 48
       52 | 47
       51 | 50
       51 | 49
       51 | 48
       51 | 47
       50 | 50
       50 | 49
       50 | 48
       50 | 47
       49 | 50
       49 | 49
       49 | 48
       49 | 47
       48 | 50
       48 | 49
       48 | 48
       48 | 47
       47 | 50
       47 | 49
       47 | 48
       47 | 47
       46 | 50
       46 | 49
       46 | 48
       46 | 47
       45 | 50
       45 | 49
       45 | 48
       45 | 47
       44 | 50
       44 | 49
       44 | 48
       44 | 47
       43 | 50
       43 | 49
       43 | 48
       43 | 47
       42 | 50
       42 | 49
       42 | 48
       42 | 47
       41 | 50
       41 | 49
       41 | 48
       41 | 47
       40 | 50
       40 | 49
       40 | 48
       40 | 47
       39 | 50
       39 | 49
       39 | 48
       39 | 47
       38 | 50
       38 | 49
       38 | 48
       38 | 47
       37 | 50
       37 | 49
       37 | 48
       37 | 47
       36 | 50
       36 | 49
       36 | 48
       36 | 47
       35 | 50
       35 | 49
       35 | 48
       35 | 47
       34 | 50
       34 | 49
       34 | 48
       34 | 47
       33 | 50
       33 | 49
       33 | 48
       33 | 47
       32 | 50
       32 | 49
       32 | 48
       32 | 47
       31 | 50
       31 | 49
       31 | 48
       31 | 47
       30 | 50
       30 | 49
       30 | 48
       30 | 47
       29 | 50
       29 | 49
       29 | 48
       29 | 47
       28 | 50
       28 | 49
       28 | 48
       28 | 47
       27 | 50
       27 | 49
       27 | 48
       27 | 47
       26 | 50
       26 | 49
       26 | 48
       26 | 47
       25 | 50
       25 | 49
       25 | 48
       25 | 47
       24 | 50
       24 | 49
       24 | 48
       24 | 47
       23 | 50
       23 | 49
       23 | 48
       23 | 47
       22 | 50
       22 | 49
       22 | 48
       22 | 47
       21 | 50
       21 | 49
       21 | 48
       21 | 47
       20 | 50
       20 | 49
       20 | 48
       20 | 47
       19 | 50
       19 | 49
       19 | 48
       19 | 47
       18 | 50
       18 | 49
       18 | 48
       18 | 47
       17 | 50
       17 | 49
       17 | 48
       17 | 47
       16 | 50
       16 | 49
       16 | 48
       16 | 47
       15 | 50
       15 | 49
       15 | 48
       15 | 47
       14 | 50
       14 | 49
       14 | 48
       14 | 47
       13 | 50
       13 | 49
       13 | 48
       13 | 47
       12 | 50
       12 | 49
       12 | 48
       12 | 47
       11 | 50
       11 | 49
       11 | 48
       11 | 47
       10 | 50
       10 | 49
       10 | 48
       10 | 47
        9 | 50
        9 | 49
        9 | 48
        9 | 47
        8 | 50
        8 | 49
        8 | 48
        8 | 47
        7 | 50
        7 | 49
        7 | 48
        7 | 47
        6 | 50
        6 | 49
        6 | 48
        6 | 47
        5 | 50
        5 | 49
        5 | 48
        5 | 47
        4 | 50
        4 | 49
        4 | 48
        4 | 47
        3 | 50
        3 | 49
        3 | 48
        3 | 47
        2 | 50
        2 | 49
        2 | 48
        2 | 47
        1 | 50
        1 | 49
        1 | 48
        1 | 47
(360 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i > 46 order by skipattr desc, i desc;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using ltidx on lessthan_skip_test  (cost=0.28..137.25 rows=1507 width=8) (actual rows=360.00 loops=1)
   Index Cond: (i > 46)
   Index Searches: 2
   Buffers: shared hit=204
(4 rows)

-- 365 buffer hits on master:
select * from lessthan_skip_test where i between 40 and 46 order by skipattr desc, i desc;
 skipattr | i  
----------+----
       90 | 46
       90 | 45
       90 | 44
       90 | 43
       90 | 42
       90 | 41
       90 | 40
       89 | 46
       89 | 45
       89 | 44
       89 | 43
       89 | 42
       89 | 41
       89 | 40
       88 | 46
       88 | 45
       88 | 44
       88 | 43
       88 | 42
       88 | 41
       88 | 40
       87 | 46
       87 | 45
       87 | 44
       87 | 43
       87 | 42
       87 | 41
       87 | 40
       86 | 46
       86 | 45
       86 | 44
       86 | 43
       86 | 42
       86 | 41
       86 | 40
       85 | 46
       85 | 45
       85 | 44
       85 | 43
       85 | 42
       85 | 41
       85 | 40
       84 | 46
       84 | 45
       84 | 44
       84 | 43
       84 | 42
       84 | 41
       84 | 40
       83 | 46
       83 | 45
       83 | 44
       83 | 43
       83 | 42
       83 | 41
       83 | 40
       82 | 46
       82 | 45
       82 | 44
       82 | 43
       82 | 42
       82 | 41
       82 | 40
       81 | 46
       81 | 45
       81 | 44
       81 | 43
       81 | 42
       81 | 41
       81 | 40
       80 | 46
       80 | 45
       80 | 44
       80 | 43
       80 | 42
       80 | 41
       80 | 40
       79 | 46
       79 | 45
       79 | 44
       79 | 43
       79 | 42
       79 | 41
       79 | 40
       78 | 46
       78 | 45
       78 | 44
       78 | 43
       78 | 42
       78 | 41
       78 | 40
       77 | 46
       77 | 45
       77 | 44
       77 | 43
       77 | 42
       77 | 41
       77 | 40
       76 | 46
       76 | 45
       76 | 44
       76 | 43
       76 | 42
       76 | 41
       76 | 40
       75 | 46
       75 | 45
       75 | 44
       75 | 43
       75 | 42
       75 | 41
       75 | 40
       74 | 46
       74 | 45
       74 | 44
       74 | 43
       74 | 42
       74 | 41
       74 | 40
       73 | 46
       73 | 45
       73 | 44
       73 | 43
       73 | 42
       73 | 41
       73 | 40
       72 | 46
       72 | 45
       72 | 44
       72 | 43
       72 | 42
       72 | 41
       72 | 40
       71 | 46
       71 | 45
       71 | 44
       71 | 43
       71 | 42
       71 | 41
       71 | 40
       70 | 46
       70 | 45
       70 | 44
       70 | 43
       70 | 42
       70 | 41
       70 | 40
       69 | 46
       69 | 45
       69 | 44
       69 | 43
       69 | 42
       69 | 41
       69 | 40
       68 | 46
       68 | 45
       68 | 44
       68 | 43
       68 | 42
       68 | 41
       68 | 40
       67 | 46
       67 | 45
       67 | 44
       67 | 43
       67 | 42
       67 | 41
       67 | 40
       66 | 46
       66 | 45
       66 | 44
       66 | 43
       66 | 42
       66 | 41
       66 | 40
       65 | 46
       65 | 45
       65 | 44
       65 | 43
       65 | 42
       65 | 41
       65 | 40
       64 | 46
       64 | 45
       64 | 44
       64 | 43
       64 | 42
       64 | 41
       64 | 40
       63 | 46
       63 | 45
       63 | 44
       63 | 43
       63 | 42
       63 | 41
       63 | 40
       62 | 46
       62 | 45
       62 | 44
       62 | 43
       62 | 42
       62 | 41
       62 | 40
       61 | 46
       61 | 45
       61 | 44
       61 | 43
       61 | 42
       61 | 41
       61 | 40
       60 | 46
       60 | 45
       60 | 44
       60 | 43
       60 | 42
       60 | 41
       60 | 40
       59 | 46
       59 | 45
       59 | 44
       59 | 43
       59 | 42
       59 | 41
       59 | 40
       58 | 46
       58 | 45
       58 | 44
       58 | 43
       58 | 42
       58 | 41
       58 | 40
       57 | 46
       57 | 45
       57 | 44
       57 | 43
       57 | 42
       57 | 41
       57 | 40
       56 | 46
       56 | 45
       56 | 44
       56 | 43
       56 | 42
       56 | 41
       56 | 40
       55 | 46
       55 | 45
       55 | 44
       55 | 43
       55 | 42
       55 | 41
       55 | 40
       54 | 46
       54 | 45
       54 | 44
       54 | 43
       54 | 42
       54 | 41
       54 | 40
       53 | 46
       53 | 45
       53 | 44
       53 | 43
       53 | 42
       53 | 41
       53 | 40
       52 | 46
       52 | 45
       52 | 44
       52 | 43
       52 | 42
       52 | 41
       52 | 40
       51 | 46
       51 | 45
       51 | 44
       51 | 43
       51 | 42
       51 | 41
       51 | 40
       50 | 46
       50 | 45
       50 | 44
       50 | 43
       50 | 42
       50 | 41
       50 | 40
       49 | 46
       49 | 45
       49 | 44
       49 | 43
       49 | 42
       49 | 41
       49 | 40
       48 | 46
       48 | 45
       48 | 44
       48 | 43
       48 | 42
       48 | 41
       48 | 40
       47 | 46
       47 | 45
       47 | 44
       47 | 43
       47 | 42
       47 | 41
       47 | 40
       46 | 46
       46 | 45
       46 | 44
       46 | 43
       46 | 42
       46 | 41
       46 | 40
       45 | 46
       45 | 45
       45 | 44
       45 | 43
       45 | 42
       45 | 41
       45 | 40
       44 | 46
       44 | 45
       44 | 44
       44 | 43
       44 | 42
       44 | 41
       44 | 40
       43 | 46
       43 | 45
       43 | 44
       43 | 43
       43 | 42
       43 | 41
       43 | 40
       42 | 46
       42 | 45
       42 | 44
       42 | 43
       42 | 42
       42 | 41
       42 | 40
       41 | 46
       41 | 45
       41 | 44
       41 | 43
       41 | 42
       41 | 41
       41 | 40
       40 | 46
       40 | 45
       40 | 44
       40 | 43
       40 | 42
       40 | 41
       40 | 40
       39 | 46
       39 | 45
       39 | 44
       39 | 43
       39 | 42
       39 | 41
       39 | 40
       38 | 46
       38 | 45
       38 | 44
       38 | 43
       38 | 42
       38 | 41
       38 | 40
       37 | 46
       37 | 45
       37 | 44
       37 | 43
       37 | 42
       37 | 41
       37 | 40
       36 | 46
       36 | 45
       36 | 44
       36 | 43
       36 | 42
       36 | 41
       36 | 40
       35 | 46
       35 | 45
       35 | 44
       35 | 43
       35 | 42
       35 | 41
       35 | 40
       34 | 46
       34 | 45
       34 | 44
       34 | 43
       34 | 42
       34 | 41
       34 | 40
       33 | 46
       33 | 45
       33 | 44
       33 | 43
       33 | 42
       33 | 41
       33 | 40
       32 | 46
       32 | 45
       32 | 44
       32 | 43
       32 | 42
       32 | 41
       32 | 40
       31 | 46
       31 | 45
       31 | 44
       31 | 43
       31 | 42
       31 | 41
       31 | 40
       30 | 46
       30 | 45
       30 | 44
       30 | 43
       30 | 42
       30 | 41
       30 | 40
       29 | 46
       29 | 45
       29 | 44
       29 | 43
       29 | 42
       29 | 41
       29 | 40
       28 | 46
       28 | 45
       28 | 44
       28 | 43
       28 | 42
       28 | 41
       28 | 40
       27 | 46
       27 | 45
       27 | 44
       27 | 43
       27 | 42
       27 | 41
       27 | 40
       26 | 46
       26 | 45
       26 | 44
       26 | 43
       26 | 42
       26 | 41
       26 | 40
       25 | 46
       25 | 45
       25 | 44
       25 | 43
       25 | 42
       25 | 41
       25 | 40
       24 | 46
       24 | 45
       24 | 44
       24 | 43
       24 | 42
       24 | 41
       24 | 40
       23 | 46
       23 | 45
       23 | 44
       23 | 43
       23 | 42
       23 | 41
       23 | 40
       22 | 46
       22 | 45
       22 | 44
       22 | 43
       22 | 42
       22 | 41
       22 | 40
       21 | 46
       21 | 45
       21 | 44
       21 | 43
       21 | 42
       21 | 41
       21 | 40
       20 | 46
       20 | 45
       20 | 44
       20 | 43
       20 | 42
       20 | 41
       20 | 40
       19 | 46
       19 | 45
       19 | 44
       19 | 43
       19 | 42
       19 | 41
       19 | 40
       18 | 46
       18 | 45
       18 | 44
       18 | 43
       18 | 42
       18 | 41
       18 | 40
       17 | 46
       17 | 45
       17 | 44
       17 | 43
       17 | 42
       17 | 41
       17 | 40
       16 | 46
       16 | 45
       16 | 44
       16 | 43
       16 | 42
       16 | 41
       16 | 40
       15 | 46
       15 | 45
       15 | 44
       15 | 43
       15 | 42
       15 | 41
       15 | 40
       14 | 46
       14 | 45
       14 | 44
       14 | 43
       14 | 42
       14 | 41
       14 | 40
       13 | 46
       13 | 45
       13 | 44
       13 | 43
       13 | 42
       13 | 41
       13 | 40
       12 | 46
       12 | 45
       12 | 44
       12 | 43
       12 | 42
       12 | 41
       12 | 40
       11 | 46
       11 | 45
       11 | 44
       11 | 43
       11 | 42
       11 | 41
       11 | 40
       10 | 46
       10 | 45
       10 | 44
       10 | 43
       10 | 42
       10 | 41
       10 | 40
        9 | 46
        9 | 45
        9 | 44
        9 | 43
        9 | 42
        9 | 41
        9 | 40
        8 | 46
        8 | 45
        8 | 44
        8 | 43
        8 | 42
        8 | 41
        8 | 40
        7 | 46
        7 | 45
        7 | 44
        7 | 43
        7 | 42
        7 | 41
        7 | 40
        6 | 46
        6 | 45
        6 | 44
        6 | 43
        6 | 42
        6 | 41
        6 | 40
        5 | 46
        5 | 45
        5 | 44
        5 | 43
        5 | 42
        5 | 41
        5 | 40
        4 | 46
        4 | 45
        4 | 44
        4 | 43
        4 | 42
        4 | 41
        4 | 40
        3 | 46
        3 | 45
        3 | 44
        3 | 43
        3 | 42
        3 | 41
        3 | 40
        2 | 46
        2 | 45
        2 | 44
        2 | 43
        2 | 42
        2 | 41
        2 | 40
        1 | 46
        1 | 45
        1 | 44
        1 | 43
        1 | 42
        1 | 41
        1 | 40
(630 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i between 40 and 46 order by skipattr desc, i desc;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using ltidx on lessthan_skip_test  (cost=0.28..123.71 rows=23 width=8) (actual rows=630.00 loops=1)
   Index Cond: ((i >= 40) AND (i <= 46))
   Index Searches: 2
   Buffers: shared hit=366
(4 rows)

-- 24 index buffer hits on master:
select * from lessthan_skip_test where i between 50 and 51 order by skipattr desc, i desc;
 skipattr | i  
----------+----
       90 | 50
       89 | 50
       88 | 50
       87 | 50
       86 | 50
       85 | 50
       84 | 50
       83 | 50
       82 | 50
       81 | 50
       80 | 50
       79 | 50
       78 | 50
       77 | 50
       76 | 50
       75 | 50
       74 | 50
       73 | 50
       72 | 50
       71 | 50
       70 | 50
       69 | 50
       68 | 50
       67 | 50
       66 | 50
       65 | 50
       64 | 50
       63 | 50
       62 | 50
       61 | 50
       60 | 50
       59 | 50
       58 | 50
       57 | 50
       56 | 50
       55 | 50
       54 | 50
       53 | 50
       52 | 50
       51 | 50
       50 | 50
       49 | 50
       48 | 50
       47 | 50
       46 | 50
       45 | 50
       44 | 50
       43 | 50
       42 | 50
       41 | 50
       40 | 50
       39 | 50
       38 | 50
       37 | 50
       36 | 50
       35 | 50
       34 | 50
       33 | 50
       32 | 50
       31 | 50
       30 | 50
       29 | 50
       28 | 50
       27 | 50
       26 | 50
       25 | 50
       24 | 50
       23 | 50
       22 | 50
       21 | 50
       20 | 50
       19 | 50
       18 | 50
       17 | 50
       16 | 50
       15 | 50
       14 | 50
       13 | 50
       12 | 50
       11 | 50
       10 | 50
        9 | 50
        8 | 50
        7 | 50
        6 | 50
        5 | 50
        4 | 50
        3 | 50
        2 | 50
        1 | 50
(90 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i between 50 and 51 order by skipattr desc, i desc;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using ltidx on lessthan_skip_test  (cost=0.28..123.71 rows=23 width=8) (actual rows=90.00 loops=1)
   Index Cond: ((i >= 50) AND (i <= 51))
   Index Searches: 2
   Buffers: shared hit=25
(4 rows)

-- 23 index buffer hits on master:
select * from lessthan_skip_test where i between 51 and 50 order by skipattr desc, i desc;
 skipattr | i 
----------+---
(0 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from lessthan_skip_test where i between 51 and 50 order by skipattr desc, i desc;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using ltidx on lessthan_skip_test  (cost=0.28..123.71 rows=23 width=8) (actual rows=0.00 loops=1)
   Index Cond: ((i >= 51) AND (i <= 50))
   Index Searches: 2
   Buffers: shared hit=24
(4 rows)

-- (September 22 2024)
--
-- Sunday after Andrew's birthday.  Test case proved that I was right to be
-- paranoid about reusing NEXTPRIOR flag for backwards and forwards scans --
-- it is indeed subtly broken.
--
-- What if the scan changes direction, and "5 + infinitesimal" becomes
-- "5 - infinitesimal" without our intending it?  That wouldn't be obviously
-- broken in most cases, but it would be broken if the scan happened to have a
-- lower-order SAOP array mixed in.
set work_mem = 64;
set enable_sort = off;
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
set client_min_messages=error;
drop table if exists nextprior_duplicate_test;
reset client_min_messages;
create unlogged table nextprior_duplicate_test(dup numeric, dups_per_val numeric);
create index nextprior_test_idx on nextprior_duplicate_test (dup, dups_per_val);
insert into nextprior_duplicate_test(dup, dups_per_val)
select val, dups_per_val from generate_series(1, 20) val,
                generate_series(1,900) dups_per_val;
vacuum analyze nextprior_duplicate_test; -- Be tidy
begin;
declare nextprior_cursor cursor for
select * from nextprior_duplicate_test where dups_per_val in (1, 450) order by dup, dups_per_val;
fetch forward 2 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   1 |            1
   1 |          450
(2 rows)

fetch forward 2 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   2 |            1
   2 |          450
(2 rows)

fetch forward 2 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   3 |            1
   3 |          450
(2 rows)

-- First wrong answer was seen here with initial failing test:
fetch backward 1 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   3 |            1
(1 row)

-- Note: this line hit the familiar "precheck has invalid array keys"
-- assertion failure from the top of _bt_checkkeys, too:
-- TRAP: failed Assert("!_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts, false, 0, NULL)")
-- Naturally, these were also wrong, since the state of the array keys is now
-- corrupt:
fetch backward 1 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   2 |          450
(1 row)

fetch forward 1 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   3 |            1
(1 row)

fetch forward 1 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   3 |          450
(1 row)

fetch forward 1 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   4 |            1
(1 row)

fetch forward 1 from nextprior_cursor;
 dup | dups_per_val 
-----+--------------
   4 |          450
(1 row)

/* nextprior_cursor  */ commit;
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare nextprior_cursor cursor for
select * from nextprior_duplicate_test where dups_per_val in (1, 450) order by dup, dups_per_val;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Index Scan using nextprior_test_idx on nextprior_duplicate_test  (cost=0.29..80.53 rows=40 width=10) (actual rows=40.00 loops=1)
   Index Cond: (dups_per_val = ANY ('{1,450}'::numeric[]))
   Index Searches: 39
   Buffers: shared hit=124
(4 rows)

-- (September 23) DESC variant
--
-- Same again, but this time use "order by dup desc, dups_per_val desc".  This
-- can independently fail; it adds coverage for _bt_tuple_before_array_skeys
-- code path where the initial scan order was forward, and then becomes
-- backward due to cursor direction changing (original tested the opposite
-- transition, from forward direction to backward direction)
EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
declare nextprior_cursor_desc cursor for
select * from nextprior_duplicate_test where dups_per_val in (450, 899)
order by dup desc, dups_per_val desc;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using nextprior_test_idx on nextprior_duplicate_test  (cost=0.29..80.53 rows=40 width=10) (actual rows=40.00 loops=1)
   Index Cond: (dups_per_val = ANY ('{450,899}'::numeric[]))
   Index Searches: 41
   Buffers: shared hit=122
(4 rows)

begin;
declare nextprior_cursor_desc cursor for
select * from nextprior_duplicate_test where dups_per_val in (450, 899)
order by dup desc, dups_per_val desc;
fetch forward 2 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  20 |          899
  20 |          450
(2 rows)

fetch forward 2 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  19 |          899
  19 |          450
(2 rows)

fetch forward 2 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  18 |          899
  18 |          450
(2 rows)

-- First wrong answer was seen here, just like original "order by dup asc,
-- dups_per_val asc" version:
fetch backward 1 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  18 |          899
(1 row)

-- Naturally, these were also wrong, since the state of the array keys is now
-- corrupt:
fetch backward 1 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  19 |          450
(1 row)

fetch forward 1 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  18 |          899
(1 row)

fetch forward 1 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  18 |          450
(1 row)

fetch forward 1 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  17 |          899
(1 row)

fetch forward 1 from nextprior_cursor_desc;
 dup | dups_per_val 
-----+--------------
  17 |          450
(1 row)

/* nextprior_cursor_desc  */ commit;
-- (November 23) Add test coverage for "mixed cardinality" cases where
-- leftmost pages have lots of distinct values in leading skippy column, but
-- then we encounter a few very large groupings across the index key space
--
-- Original intent of this was to get test coverage for experimental
-- optimization:
/*
commit b4a50b6441440b2a56d84c2c357b31befa945cc3
Refs: [skip-scan-2024-v17.1]
Author:     Peter Geoghegan <pg@bowt.ie>
AuthorDate: 2024-11-23 13:09:59 -0500
Commit:     Peter Geoghegan <pg@bowt.ie>
CommitDate: 2024-11-23 14:20:45 -0500

    Experiment, which doesn't increase any buffers accessed by more than one or two, suggesting a gap in test coverage
---
 src/backend/access/nbtree/nbtsearch.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/backend/access/nbtree/nbtsearch.c b/src/backend/access/nbtree/nbtsearch.c
index 34deb970e..1cb8ffc93 100644
--- a/src/backend/access/nbtree/nbtsearch.c
+++ b/src/backend/access/nbtree/nbtsearch.c
@@ -1841,16 +1841,16 @@ _bt_readpage(IndexScanDesc scan, ScanDirection dir, OffsetNumber offnum,
            IndexTuple  itup = (IndexTuple) PageGetItem(page, iid);
            int         truncatt;

-           truncatt = BTreeTupleGetNAtts(itup, rel);
-           pstate.prechecked = false;  / precheck didn't cover HIKEY /
            if (pstate.skipskip)
            {
                Assert(itup == pstate.finaltup);
-
-               _bt_start_array_keys(scan, dir);
-               pstate.skipskip = false;    / reset for finaltup /
            }
-           _bt_checkkeys(scan, &pstate, arrayKeys, itup, truncatt);
+           else
+           {
+               truncatt = BTreeTupleGetNAtts(itup, rel);
+               pstate.prechecked = false;  / precheck didn't cover HIKEY /
+               _bt_checkkeys(scan, &pstate, arrayKeys, itup, truncatt);
+           }
        }

        if (!pstate.continuescan)
*/
set client_min_messages=error;
drop table if exists high_low_high_card;
reset client_min_messages;
create unlogged table high_low_high_card(
  skippy int4,
  key int4,
  type text
);
create index on high_low_high_card(skippy, key);
insert into high_low_high_card
select
  -- "+ 250" here to make sure that there are leftmost pages full of tuples with
  -- distinct "skippy" vals:
  (abs(hashint4(i % 5)) + 250) % (10000 + 250),
  abs(hashint4(i + 42)) % 100_000,
  'fat'
from
  generate_series(1, 100_000) i;
with card as (
  select
    i skippy,
    abs(hashint4(i + j)) % 10000,
    'skinny'
  from
    generate_series(1, 10000) i,
    generate_series(1, 10) j
),
oth as (
  select
    *
  from
    card c
  where
    not exists (
      select
        *
      from
        high_low_high_card h
      where
        c.skippy = h.skippy)
)
insert into high_low_high_card
select
  *
from
  oth;
vacuum analyze high_low_high_card;
-- Index scan:
set enable_bitmapscan to off;
set enable_indexonlyscan to off;
set enable_indexscan to on;
--------------------
-- Forwards scans --
--------------------
select * from high_low_high_card where key = 40 order by skippy, key;
 skippy | key |  type  
--------+-----+--------
   1615 |  40 | skinny
   1616 |  40 | skinny
   1617 |  40 | skinny
   1618 |  40 | skinny
   1619 |  40 | skinny
   1620 |  40 | skinny
   1621 |  40 | skinny
   1622 |  40 | skinny
   1623 |  40 | skinny
   1624 |  40 | skinny
   5526 |  40 | fat
   9481 |  40 | skinny
   9482 |  40 | skinny
   9483 |  40 | skinny
   9484 |  40 | skinny
   9485 |  40 | skinny
   9486 |  40 | skinny
   9487 |  40 | skinny
   9488 |  40 | skinny
   9489 |  40 | skinny
   9490 |  40 | skinny
(21 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 40 order by skippy, key;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=21.00 loops=1)
   Index Cond: (key = 40)
   Index Searches: 6
   Buffers: shared hit=433
(4 rows)

select * from high_low_high_card where key = 37 order by skippy, key;
 skippy | key |  type  
--------+-----+--------
    255 |  37 | fat
   7080 |  37 | skinny
   7081 |  37 | skinny
   7082 |  37 | skinny
   7083 |  37 | skinny
   7084 |  37 | skinny
   7085 |  37 | skinny
   7086 |  37 | skinny
   7087 |  37 | skinny
   7088 |  37 | skinny
   7089 |  37 | skinny
(11 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 37 order by skippy, key;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=11.00 loops=1)
   Index Cond: (key = 37)
   Index Searches: 6
   Buffers: shared hit=423
(4 rows)

select * from high_low_high_card where key = 38 order by skippy, key;
 skippy | key | type 
--------+-----+------
   5526 |  38 | fat
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 38 order by skippy, key;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Index Scan using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=1.00 loops=1)
   Index Cond: (key = 38)
   Index Searches: 6
   Buffers: shared hit=413
(4 rows)

select * from high_low_high_card where key = 13 order by skippy, key;
 skippy | key |  type  
--------+-----+--------
   4381 |  13 | skinny
   4382 |  13 | skinny
   4383 |  13 | skinny
   4384 |  13 | skinny
   4385 |  13 | skinny
   4386 |  13 | skinny
   4387 |  13 | skinny
   4388 |  13 | skinny
   4389 |  13 | skinny
   4390 |  13 | skinny
   4726 |  13 | fat
   7836 |  13 | skinny
   7837 |  13 | skinny
   7838 |  13 | skinny
   7839 |  13 | skinny
   7840 |  13 | skinny
   7841 |  13 | skinny
   7842 |  13 | skinny
   7843 |  13 | skinny
   7844 |  13 | skinny
   7845 |  13 | skinny
(21 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 13 order by skippy, key;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Scan using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=21.00 loops=1)
   Index Cond: (key = 13)
   Index Searches: 6
   Buffers: shared hit=433
(4 rows)

select * from high_low_high_card where key = 15 order by skippy, key;
 skippy | key | type 
--------+-----+------
   4726 |  15 | fat
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 15 order by skippy, key;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Index Scan using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=1.00 loops=1)
   Index Cond: (key = 15)
   Index Searches: 6
   Buffers: shared hit=413
(4 rows)

---------------------
-- Backwards scans --
---------------------
select * from high_low_high_card where key = 40 order by skippy desc, key desc;
 skippy | key |  type  
--------+-----+--------
   9490 |  40 | skinny
   9489 |  40 | skinny
   9488 |  40 | skinny
   9487 |  40 | skinny
   9486 |  40 | skinny
   9485 |  40 | skinny
   9484 |  40 | skinny
   9483 |  40 | skinny
   9482 |  40 | skinny
   9481 |  40 | skinny
   5526 |  40 | fat
   1624 |  40 | skinny
   1623 |  40 | skinny
   1622 |  40 | skinny
   1621 |  40 | skinny
   1620 |  40 | skinny
   1619 |  40 | skinny
   1618 |  40 | skinny
   1617 |  40 | skinny
   1616 |  40 | skinny
   1615 |  40 | skinny
(21 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 40 order by skippy desc, key desc;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Scan Backward using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=21.00 loops=1)
   Index Cond: (key = 40)
   Index Searches: 8
   Buffers: shared hit=437
(4 rows)

select * from high_low_high_card where key = 37 order by skippy desc, key desc;
 skippy | key |  type  
--------+-----+--------
   7089 |  37 | skinny
   7088 |  37 | skinny
   7087 |  37 | skinny
   7086 |  37 | skinny
   7085 |  37 | skinny
   7084 |  37 | skinny
   7083 |  37 | skinny
   7082 |  37 | skinny
   7081 |  37 | skinny
   7080 |  37 | skinny
    255 |  37 | fat
(11 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 37 order by skippy desc, key desc;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Scan Backward using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=11.00 loops=1)
   Index Cond: (key = 37)
   Index Searches: 8
   Buffers: shared hit=427
(4 rows)

select * from high_low_high_card where key = 38 order by skippy desc, key desc;
 skippy | key | type 
--------+-----+------
   5526 |  38 | fat
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 38 order by skippy desc, key desc;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Scan Backward using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=1.00 loops=1)
   Index Cond: (key = 38)
   Index Searches: 8
   Buffers: shared hit=417
(4 rows)

select * from high_low_high_card where key = 13 order by skippy desc, key desc;
 skippy | key |  type  
--------+-----+--------
   7845 |  13 | skinny
   7844 |  13 | skinny
   7843 |  13 | skinny
   7842 |  13 | skinny
   7841 |  13 | skinny
   7840 |  13 | skinny
   7839 |  13 | skinny
   7838 |  13 | skinny
   7837 |  13 | skinny
   7836 |  13 | skinny
   4726 |  13 | fat
   4390 |  13 | skinny
   4389 |  13 | skinny
   4388 |  13 | skinny
   4387 |  13 | skinny
   4386 |  13 | skinny
   4385 |  13 | skinny
   4384 |  13 | skinny
   4383 |  13 | skinny
   4382 |  13 | skinny
   4381 |  13 | skinny
(21 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 13 order by skippy desc, key desc;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Scan Backward using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=21.00 loops=1)
   Index Cond: (key = 13)
   Index Searches: 8
   Buffers: shared hit=437
(4 rows)

select * from high_low_high_card where key = 15 order by skippy desc, key desc;
 skippy | key | type 
--------+-----+------
   4726 |  15 | fat
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, COSTS OFF, SUMMARY OFF)
select * from high_low_high_card where key = 15 order by skippy desc, key desc;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Index Scan Backward using high_low_high_card_skippy_key_idx on high_low_high_card (actual rows=1.00 loops=1)
   Index Cond: (key = 15)
   Index Searches: 8
   Buffers: shared hit=417
(4 rows)

-----------------------------------------------
-- RowCompare skipskip test (January 1 2025) --
-----------------------------------------------
set client_min_messages=error;
drop table if exists rowcompare_skipskip_test;
reset client_min_messages;
create unlogged table rowcompare_skipskip_test(
  a int4,
  b int4,
  c int4
);
create index on rowcompare_skipskip_test(a, b, c);
-- Create table with 3 columns, all of which are high cardinality -- making
-- this a poor target for skip scan in general:
insert into rowcompare_skipskip_test
select
  i, i, i
from generate_series(1, 1000) i;
-- Lower-order RowCompare query, which makes use of skipskip optimization to
-- avoid perf regressions relative to master branch:
--
-- Original assertion failure caused by this query:
--
-- TRAP: failed Assert("!pstate->skipskip"), File:
-- "../source/src/backend/access/nbtree/nbtutils.c", Line: 4995, PID: 3455365
-- [0x5624bbbb24aa] _bt_checkkeys: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtutils.c:4995
-- [0x5624bbbab19c] _bt_readpage: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtsearch.c:1790
-- [0x5624bbbaa10d] _bt_readnextpage: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtsearch.c:2405
-- [0x5624bbbaa7bd] _bt_next: /mnt/nvme/postgresql/patch/build_meson_dc/../source/src/backend/access/nbtree/nbtsearch.c:0
select * from rowcompare_skipskip_test where (b,c) < (4, 2);
 a | b | c 
---+---+---
 1 | 1 | 1
 2 | 2 | 2
 3 | 3 | 3
(3 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from rowcompare_skipskip_test where (b,c) < (4, 2);
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using rowcompare_skipskip_test_a_b_c_idx on rowcompare_skipskip_test  (cost=0.28..54.38 rows=680 width=12) (actual rows=3.00 loops=1)
   Index Cond: (ROW(b, c) < ROW(4, 2))
   Index Searches: 1
   Buffers: shared hit=6
(4 rows)

-----------------------------------------------------------------------------------------------------
-- (Feb 11 2025) test for logic in _bt_forcenonrequired with mixed range and non-range skip arrays --
-----------------------------------------------------------------------------------------------------
set client_min_messages=error;
drop table if exists forcenonrequired_test;
reset client_min_messages;
create unlogged table forcenonrequired_test(a int, b int, c int);
create index forcenonrequired_test_idx on forcenonrequired_test (a, b, c);
-- Setup
-- set skipscan_prefix_cols = 0;
select setseed(0.5);
 setseed 
---------
 
(1 row)

insert into forcenonrequired_test
select
  (random() * 100)::int4 as a,
  (random() * 10)::int4 as b,
  (random() * 10)::int4 as c from generate_series(1, 20_000) i;
-- This was wrong because I somehow got the idea that a non-range skip array
-- doesn't represent the lack of an inequality constraint (regardless of
-- whether or not we proved that its column value never changed on the page):
select count(*) from forcenonrequired_test where b between 6 and 6 and c = 1;
 count 
-------
   206
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from forcenonrequired_test where b between 6 and 6 and c = 1;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=424.25..424.26 rows=1 width=8) (actual rows=1.00 loops=1)
   Buffers: shared hit=273
   ->  Index Scan using forcenonrequired_test_idx on forcenonrequired_test  (cost=0.29..424.25 rows=1 width=0) (actual rows=206.00 loops=1)
         Index Cond: ((b >= 6) AND (b <= 6) AND (c = 1))
         Index Searches: 1
         Buffers: shared hit=273
(6 rows)

-- This variant that gives the same answer was okay at the time, though:
select count(*) from forcenonrequired_test where a between 0 and 100 and b between 6 and 6 and c = 1;
 count 
-------
   206
(1 row)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select count(*) from forcenonrequired_test where a between 0 and 100 and b between 6 and 6 and c = 1;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=6.24..6.25 rows=1 width=8) (actual rows=1.00 loops=1)
   Buffers: shared hit=273
   ->  Index Scan using forcenonrequired_test_idx on forcenonrequired_test  (cost=0.29..6.24 rows=1 width=0) (actual rows=206.00 loops=1)
         Index Cond: ((a >= 0) AND (a <= 100) AND (b >= 6) AND (b <= 6) AND (c = 1))
         Index Searches: 1
         Buffers: shared hit=273
(6 rows)

-- (Feb 11 2025) SAOP array test case had wrong answers because we didn't
-- actually check if "a" scan key is satisfied by any "a" value on the page,
-- spuriously deciding that "a" scan key must be satisfied just because "a"
-- only has one distinct value.  This causes wrong answers on the page that
-- exclusively contains "a = 93" values, which shouldn't be returning any
-- tuples here.
select * from forcenonrequired_test where a in (91,92,94) and c = 1 order by a desc, b desc;
 a  | b  | c 
----+----+---
 94 | 10 | 1
 94 |  9 | 1
 94 |  9 | 1
 94 |  8 | 1
 94 |  8 | 1
 94 |  6 | 1
 94 |  6 | 1
 94 |  5 | 1
 94 |  5 | 1
 94 |  4 | 1
 94 |  4 | 1
 94 |  4 | 1
 94 |  4 | 1
 94 |  4 | 1
 94 |  3 | 1
 94 |  2 | 1
 94 |  2 | 1
 94 |  2 | 1
 94 |  2 | 1
 94 |  1 | 1
 94 |  1 | 1
 94 |  1 | 1
 94 |  0 | 1
 94 |  0 | 1
 92 |  9 | 1
 92 |  9 | 1
 92 |  9 | 1
 92 |  9 | 1
 92 |  8 | 1
 92 |  8 | 1
 92 |  8 | 1
 92 |  7 | 1
 92 |  7 | 1
 92 |  6 | 1
 92 |  5 | 1
 92 |  5 | 1
 92 |  3 | 1
 92 |  2 | 1
 92 |  1 | 1
 92 |  1 | 1
 92 |  1 | 1
 92 |  1 | 1
 92 |  1 | 1
 92 |  1 | 1
 91 | 10 | 1
 91 | 10 | 1
 91 |  9 | 1
 91 |  9 | 1
 91 |  8 | 1
 91 |  7 | 1
 91 |  7 | 1
 91 |  7 | 1
 91 |  7 | 1
 91 |  6 | 1
 91 |  6 | 1
 91 |  5 | 1
 91 |  4 | 1
 91 |  4 | 1
 91 |  2 | 1
 91 |  1 | 1
 91 |  1 | 1
 91 |  0 | 1
 91 |  0 | 1
 91 |  0 | 1
(64 rows)

EXPLAIN (ANALYZE, BUFFERS, TIMING OFF, SUMMARY OFF)
select * from forcenonrequired_test where a in (91,92,94) and c = 1 order by a desc, b desc;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan Backward using forcenonrequired_test_idx on forcenonrequired_test  (cost=0.29..14.21 rows=2 width=12) (actual rows=64.00 loops=1)
   Index Cond: ((a = ANY ('{91,92,94}'::integer[])) AND (c = 1))
   Index Searches: 1
   Buffers: shared hit=69
(4 rows)

